#!/usr/bin/env python3
#encoding=utf-8
import argparse
import base64
import json
import logging
import asyncio
import os
import pathlib
import platform
import random
import ssl
import subprocess
import sys
import threading
import time
import warnings
import webbrowser
from datetime import datetime

# 強制使用 UTF-8 編碼輸出（解決 Windows CP950 編碼問題）
# 適用於所有輸出環境（終端、IDE、重定向、管道）
if sys.platform == 'win32':
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace', line_buffering=True)
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace', line_buffering=True)

import nodriver as uc
from nodriver import cdp
from nodriver.core.config import Config
from urllib3.exceptions import InsecureRequestWarning
import urllib.parse

import util
import settings
import chrome_downloader
from NonBrowser import NonBrowser

try:
    import ddddocr
except Exception as exc:
    print(exc)
    pass

CONST_APP_VERSION = "TicketsHunter (2026.02.09)"


CONST_MAXBOT_ANSWER_ONLINE_FILE = "MAXBOT_ONLINE_ANSWER.txt"
CONST_MAXBOT_CONFIG_FILE = "settings.json"
CONST_MAXBOT_EXTENSION_NAME = "Maxbotplus_1.0.0"
CONST_MAXBOT_INT28_FILE = "MAXBOT_INT28_IDLE.txt"
CONST_MAXBOT_LAST_URL_FILE = "MAXBOT_LAST_URL.txt"
CONST_MAXBOT_QUESTION_FILE = "MAXBOT_QUESTION.txt"
CONST_MAXBLOCK_EXTENSION_NAME = "Maxblockplus_1.0.0"
CONST_MAXBLOCK_EXTENSION_FILTER =[
"*.doubleclick.net/*",
"*.googlesyndication.com/*",
"*.ssp.hinet.net/*",
"*a.amnet.tw/*",
"*anymind360.com/*",
"*.appier.net/*",
"*.c.appier.net/*",
"*cdn.cookielaw.org/*",
"*cdnjs.cloudflare.com/ajax/libs/clipboard.js/*",
"*clarity.ms/*",
"*cloudfront.com/*",
"*cms.analytics.yahoo.com/*",
"*e2elog.fetnet.net/*",
"*fundingchoicesmessages.google.com/*",
"*ghtinc.com/*",
"*google-analytics.com/*",
"*googletagmanager.com/*",
"*googletagservices.com/*",
"*img.uniicreative.com/*",
"*lndata.com/*",
"*match.adsrvr.org/*",
"*onead.onevision.com.tw/*",
"*play.google.com/log?*",
"*popin.cc/*",
"*rollbar.com/*",
"*sb.scorecardresearch.com/*",
"*tagtoo.co/*",
"*ticketmaster.sg/js/adblock*",
"*ticketmaster.sg/js/adblock.js*",
"*ticketmaster.sg/js/ads.js*",
"*ticketmaster.sg/epsf/asset/eps.js*",
"*tixcraft.com/js/analytics.js*",
"*tixcraft.com/js/common.js*",
"*tixcraft.com/js/custom.js*",
"*treasuredata.com/*",
"*www.youtube.com/youtubei/v1/player/heartbeat*",
]

CONST_CITYLINE_SIGN_IN_URL = "https://www.cityline.com/Login.html?targetUrl=https%3A%2F%2Fwww.cityline.com%2FEvents.html"
CONST_FAMI_SIGN_IN_URL = "https://www.famiticket.com.tw/Home/User/SignIn"
CONST_HKTICKETING_SIGN_IN_URL = "https://premier.hkticketing.com/Secure/ShowLogin.aspx"
CONST_HKTICKETING_TYPE02_SIGN_IN_URL = "https://hkt.hkticketing.com/hant/#/login"
CONST_KHAM_SIGN_IN_URL = "https://kham.com.tw/application/UTK13/UTK1306_.aspx"
CONST_KKTIX_SIGN_IN_URL = "https://kktix.com/users/sign_in?back_to=%s"
CONST_TICKET_SIGN_IN_URL = "https://ticket.com.tw/application/utk13/utk1306_.aspx"
CONST_UDN_SIGN_IN_URL = "https://tickets.udnfunlife.com/application/UTK01/UTK0101_.aspx"
CONST_URBTIX_SIGN_IN_URL = "https://www.urbtix.hk/member-login"

CONST_FROM_TOP_TO_BOTTOM = "from top to bottom"
CONST_FROM_BOTTOM_TO_TOP = "from bottom to top"
CONST_CENTER = "center"
CONST_RANDOM = "random"
CONST_SELECT_ORDER_DEFAULT = CONST_FROM_TOP_TO_BOTTOM

CONT_STRING_1_SEATS_REMAINING = ['@1 seat(s) remaining','剩餘 1@','@1 席残り']

CONST_OCR_CAPTCH_IMAGE_SOURCE_NON_BROWSER = "NonBrowser"
CONST_OCR_CAPTCH_IMAGE_SOURCE_CANVAS = "canvas"

CONST_WEBDRIVER_TYPE_NODRIVER = "nodriver"
CONST_CHROME_FAMILY = ["chrome","edge","brave"]
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"

# ===== Cloudflare 繞過模式設定 =====
# 模式說明：
# "auto"   - 自動靜默執行，無額外輸出（建議日常使用）
# "debug"  - 顯示詳細處理過程，適合除錯
# "manual" - 只偵測並提示，不自動處理
# "off"    - 完全停用 Cloudflare 繞過功能
CLOUDFLARE_BYPASS_MODE = "auto"
CLOUDFLARE_MAX_RETRY = 3         # 最大重試次數
CLOUDFLARE_WAIT_TIME = 3         # 每次嘗試後的等待時間（秒）
CLOUDFLARE_ENABLE_EXPERT_MODE = False  # True 會啟用更激進的瀏覽器參數（參考 stackoverflow.max-everyday.com）

warnings.simplefilter('ignore',InsecureRequestWarning)
ssl._create_default_https_context = ssl._create_unverified_context
logging.basicConfig()
logger = logging.getLogger('logger')


def get_config_dict(args):
    app_root = util.get_app_root()
    config_filepath = os.path.join(app_root, CONST_MAXBOT_CONFIG_FILE)

    if args.input and len(args.input) > 0:
        config_filepath = args.input

    config_dict = None
    if os.path.isfile(config_filepath):
        with open(config_filepath, encoding='utf-8') as json_data:
            config_dict = json.load(json_data)

            # Define a dictionary to map argument names to their paths in the config_dict
            arg_to_path = {
                "headless": ["advanced", "headless"],
                "homepage": ["homepage"],
                "ticket_number": ["ticket_number"],
                "browser": ["browser"],
                "proxy_server": ["advanced", "proxy_server_port"],
                "window_size": ["advanced", "window_size"],
                "date_auto_select_mode": ["date_auto_select", "mode"],
                "date_keyword": ["date_auto_select", "date_keyword"],
                "area_auto_select_mode": ["area_auto_select", "mode"],
                "area_keyword": ["area_auto_select", "area_keyword"]
            }

            # Update the config_dict based on the arguments
            for arg, path in arg_to_path.items():
                value = getattr(args, arg)
                if value and len(str(value)) > 0:
                    d = config_dict
                    for key in path[:-1]:
                        d = d[key]
                    d[path[-1]] = value

            # special case for headless to enable away from keyboard mode.
            is_headless_enable_ocr = False
            if config_dict["advanced"]["headless"]:
                # for tixcraft headless.
                if len(config_dict["accounts"]["tixcraft_sid"]) > 1:
                    is_headless_enable_ocr = True

            if is_headless_enable_ocr:
                config_dict["ocr_captcha"]["enable"] = True
                config_dict["ocr_captcha"]["force_submit"] = True

    return config_dict

def write_question_to_file(question_text):
    working_dir = os.path.dirname(os.path.realpath(__file__))
    target_path = os.path.join(working_dir, CONST_MAXBOT_QUESTION_FILE)
    util.write_string_to_file(target_path, question_text)

def write_last_url_to_file(url):
    working_dir = os.path.dirname(os.path.realpath(__file__))
    target_path = os.path.join(working_dir, CONST_MAXBOT_LAST_URL_FILE)
    util.write_string_to_file(target_path, url)

def read_last_url_from_file():
    ret = ""
    with open(CONST_MAXBOT_LAST_URL_FILE, "r") as text_file:
        ret = text_file.readline()
    return ret

def play_sound_while_ordering(config_dict):
    app_root = util.get_app_root()
    captcha_sound_filename = os.path.join(app_root, config_dict["advanced"]["play_sound"]["filename"].strip())
    util.play_mp3_async(captcha_sound_filename)

def send_discord_notification(config_dict, stage, platform_name):
    """Send Discord webhook notification if configured.

    Args:
        config_dict: Configuration dictionary
        stage: "ticket" or "order"
        platform_name: Platform name (e.g., "TixCraft", "iBon")
    """
    webhook_url = config_dict.get("advanced", {}).get("discord_webhook_url", "")
    if webhook_url:
        verbose = config_dict.get("advanced", {}).get("verbose", False)
        util.send_discord_webhook_async(webhook_url, stage, platform_name, verbose=verbose)

async def nodriver_press_button(tab, select_query):
    if tab:
        try:
            element = await tab.query_selector(select_query)
            if element:
                await element.click()
            else:
                #print("element not found:", select_query)
                pass
        except Exception as e:
            #print("click fail for selector:", select_query)
            print(e)
            pass

from typing import Optional

async def nodriver_check_checkbox(tab: Optional[object], select_query: str, value: str = 'true') -> bool:
    if tab:
        try:
            # 使用 JavaScript 檢查 checkbox 狀態並避免重複點擊
            result = await tab.evaluate(f'''
                (function() {{
                    const checkboxes = document.querySelectorAll('{select_query}');
                    let targetCheckbox = null;

                    // 尋找第一個非記得密碼的 checkbox
                    for (let i = 0; i < checkboxes.length; i++) {{
                        const checkbox = checkboxes[i];
                        const id = checkbox.id || '';
                        const name = checkbox.name || '';
                        const className = checkbox.className || '';
                        const labelText = checkbox.labels && checkbox.labels[0] ? checkbox.labels[0].textContent : '';

                        // 檢查是否為記得密碼相關的 checkbox
                        const isRememberCheckbox =
                            id.toLowerCase().includes('remember') ||
                            name.toLowerCase().includes('remember') ||
                            className.toLowerCase().includes('remember') ||
                            labelText.includes('記得') ||
                            labelText.includes('記住') ||
                            labelText.includes('Remember') ||
                            labelText.includes('密碼');

                        if (!isRememberCheckbox) {{
                            targetCheckbox = checkbox;
                            break;
                        }}
                    }}

                    if (!targetCheckbox) return false;

                    // 如果已經勾選，直接回傳成功
                    if (targetCheckbox.checked) return true;

                    // 只在未勾選時才點擊
                    try {{
                        targetCheckbox.click();
                        return targetCheckbox.checked;
                    }} catch(e) {{
                        // fallback: 直接設定 checked 屬性
                        targetCheckbox.checked = true;
                        return targetCheckbox.checked;
                    }}
                }})();
            ''')
            return bool(result)
        except Exception as exc:
            print(exc)
    return False

async def nodriver_force_check_checkbox(tab, checkbox_element):
    """強制勾選 checkbox，參考 Chrome 版本的 force_check_checkbox 邏輯"""
    is_finish_checkbox_click = False

    if checkbox_element:
        try:
            # 使用 JavaScript 檢查和設定 checkbox 狀態
            result = await tab.evaluate('''
                (function(element) {
                    if (!element) return false;

                    // 檢查是否已勾選
                    if (element.checked) return true;

                    // 嘗試點擊勾選
                    try {
                        element.click();
                        return element.checked;
                    } catch(e) {
                        // fallback: 直接設定 checked 屬性
                        element.checked = true;
                        return element.checked;
                    }
                })(arguments[0]);
            ''', checkbox_element)

            is_finish_checkbox_click = bool(result)

        except Exception as exc:
            pass

    return is_finish_checkbox_click

async def nodriver_check_checkbox_enhanced(tab, select_query, show_debug_message=False):
    """增強版勾選函式，直接使用 JavaScript 操作"""
    is_checkbox_checked = False

    try:
        if show_debug_message:
            print(f"Checking checkbox: {select_query}")

        # 直接使用 JavaScript 查找並勾選
        result = await tab.evaluate(f'''
            (function() {{
                const checkbox = document.querySelector('{select_query}');
                if (!checkbox) return false;

                if (checkbox.checked) return true;

                try {{
                    checkbox.click();
                    return checkbox.checked;
                }} catch(e) {{
                    checkbox.checked = true;
                    return checkbox.checked;
                }}
            }})();
        ''')

        is_checkbox_checked = bool(result)

        if show_debug_message:
            print(f"Checkbox result: {is_checkbox_checked}")

    except Exception as exc:
        if show_debug_message:
            print(f"Checkbox error: {exc}")

    return is_checkbox_checked

async def nodriver_facebook_login(tab, facebook_account, facebook_password):
    if tab:
        try:
            account = await tab.query_selector("#email")
            if account:
                await account.send_keys(facebook_account)
            else:
                print("account not found")

            password = await tab.query_selector("#pass")
            if password:
                await password.send_keys(facebook_password)
                await tab.send(cdp.input_.dispatch_key_event("keyDown", code="Enter", key="Enter", text="\r", windows_virtual_key_code=13))
                await tab.send(cdp.input_.dispatch_key_event("keyUp", code="Enter", key="Enter", text="\r", windows_virtual_key_code=13))
                await asyncio.sleep(2)
            else:
                print("password not found")
        except Exception as e:
            print("send_keys fail.")
            print(e)
            pass


async def detect_cloudflare_challenge(tab, show_debug=False):
    """
    偵測是否遇到 Cloudflare 挑戰頁面

    Returns:
        bool: True 如果偵測到 Cloudflare 挑戰頁面
    """
    try:
        html_content = await tab.get_content()
        if not html_content:
            return False

        html_lower = html_content.lower()

        # Cloudflare 挑戰頁面的特徵標記
        cloudflare_indicators = [
            "cloudflare",
            "cf-browser-verification",
            "challenge-platform",
            "checking your browser",
            "please wait while we verify",
            "verify you are human",
            "正在驗證",
            "驗證你是人類",
            "cf-challenge-running",
            "cf-spinner-allow-5-secs"
        ]

        detected = any(indicator in html_lower for indicator in cloudflare_indicators)

        if detected:
            # 只在首次偵測到時顯示訊息，避免重複輸出
            # print("[CLOUDFLARE] 偵測到 Cloudflare 挑戰頁面")  # 移除重複訊息
            pass

        return detected

    except Exception as exc:
        if show_debug:
            print(f"Cloudflare detection error: {exc}")
        return False


async def handle_cloudflare_challenge(tab, config_dict, max_retry=None):
    """
    處理 Cloudflare 挑戰頁面 - 增強版

    Args:
        tab: nodriver tab 物件
        config_dict: 設定字典
        max_retry: 最大重試次數（若為 None 則使用全域設定）

    Returns:
        bool: True 如果成功繞過 Cloudflare
    """
    # 使用全域設定或傳入值
    max_retry = max_retry or CLOUDFLARE_MAX_RETRY

    # 根據模式決定是否顯示訊息
    show_debug_message = (config_dict["advanced"]["verbose"] or
                         CLOUDFLARE_BYPASS_MODE == "debug")

    # 自動模式下靜默執行
    if CLOUDFLARE_BYPASS_MODE == "auto":
        show_debug_message = False

    if show_debug_message:
        print("[CLOUDFLARE] Starting to handle Cloudflare challenge...")

    for retry_count in range(max_retry):
        try:
            if retry_count > 0:
                if show_debug_message:
                    print(f"[CLOUDFLARE] Retry attempt {retry_count}...")
                # Increase retry interval
                await tab.sleep(3 + retry_count)

            # Method 1: Use verify_cf with multiple templates
            verify_success = await util.verify_cf_with_templates(tab, show_debug=show_debug_message)

            # Method 2: Fallback - try clicking verification box directly
            if not verify_success:
                try:
                    verify_box = await tab.query_selector('input[type="checkbox"]')
                    if verify_box:
                        await verify_box.click()
                        if show_debug_message:
                            print("[CLOUDFLARE] Clicked verification checkbox directly")
                except Exception:
                    pass

            # Wait for challenge completion (dynamically adjust wait time)
            wait_time = CLOUDFLARE_WAIT_TIME + (retry_count * 2)
            await tab.sleep(wait_time)

            # Check if successfully bypassed
            if not await detect_cloudflare_challenge(tab, show_debug_message):
                if show_debug_message:
                    print("[CLOUDFLARE] Cloudflare challenge bypassed successfully")
                return True
            else:
                if show_debug_message:
                    print(f"[CLOUDFLARE] Attempt {retry_count + 1} unsuccessful")

                # Last attempt: Refresh page
                if retry_count == max_retry - 1:
                    try:
                        if show_debug_message:
                            print("[CLOUDFLARE] Last attempt: Refreshing page")
                        await tab.reload()
                        await tab.sleep(5)
                        if not await detect_cloudflare_challenge(tab, show_debug_message):
                            return True
                    except Exception:
                        pass

        except Exception as exc:
            if show_debug_message:
                print(f"[CLOUDFLARE] Error during processing: {exc}")

    if show_debug_message:
        print("[CLOUDFLARE] Cloudflare challenge handling failed, max retries reached")
        print("[CLOUDFLARE] Suggestion: Check network connection or try again later")
    return False




async def nodriver_kktix_signin(tab, url, config_dict):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = util.get_debug_mode(config_dict)

    if show_debug_message:
        print("nodriver_kktix_signin:", url)

    # 解析 back_to 參數取得真正的目標頁面
    import urllib.parse
    target_url = config_dict["homepage"]  # 預設值
    try:
        parsed_url = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed_url.query)
        if 'back_to' in params and len(params['back_to']) > 0:
            target_url = params['back_to'][0]
    except Exception as exc:
        print(f"解析 back_to 參數失敗: {exc}")

    # for like human.
    await asyncio.sleep(random.uniform(1, 3))

    kktix_account = config_dict["accounts"]["kktix_account"]
    kktix_password = config_dict["accounts"]["kktix_password"].strip()

    has_redirected = False
    if len(kktix_account) > 4:
        try:
            account = await tab.query_selector("#user_login")
            if account:
                await account.send_keys(kktix_account)
                await asyncio.sleep(random.uniform(0.3, 1.2))

            password = await tab.query_selector("#user_password")
            if password:
                await password.send_keys(kktix_password)
                await asyncio.sleep(random.uniform(0.3, 1.2))

            await tab.evaluate('''
                const loginBtn = document.querySelector('input[type="submit"][value="登入"]');
                if (loginBtn) {
                    loginBtn.click();
                }
            ''')

            # Smart polling: wait for login completion (URL change from sign_in page)
            max_wait = 10
            check_interval = 0.3
            max_attempts = int(max_wait / check_interval)
            login_completed = False

            for attempt in range(max_attempts):
                # 登入後檢查暫停
                if await check_and_handle_pause(config_dict):
                    return False

                try:
                    current_url = await tab.evaluate('window.location.href')

                    # Detect if left sign_in page (login completed)
                    if '/users/sign_in' not in current_url:
                        login_completed = True
                        if show_debug_message:
                            print(f"[KKTIX SIGNIN] Login completed after {attempt * check_interval:.1f}s, redirected to: {current_url}")
                        break
                except Exception as exc:
                    if show_debug_message and attempt == max_attempts - 1:
                        print(f"[KKTIX SIGNIN] Error checking URL: {exc}")

                if attempt < max_attempts - 1:
                    await asyncio.sleep(check_interval)

            if not login_completed:
                if show_debug_message:
                    print(f"[KKTIX SIGNIN] Login timeout after {max_wait}s")

            # Check if need to manually redirect to back_to URL
            try:
                current_url = await tab.evaluate('window.location.href')
                if current_url and ('kktix.com/' in current_url or 'kktix.cc/' in current_url):
                    # If on homepage or user page, manually redirect to back_to URL
                    if (current_url.endswith('/') or '/users/' in current_url) and target_url != current_url:
                        if show_debug_message:
                            print(f"[KKTIX SIGNIN] Currently on homepage/user page, redirecting to: {target_url}")
                        await tab.get(target_url)
                        await asyncio.sleep(random.uniform(1.2, 2.3))
                        has_redirected = True
                    elif show_debug_message:
                        print(f"[KKTIX SIGNIN] Already on target page: {current_url}")
            except Exception as redirect_error:
                print(f"跳轉失敗: {redirect_error}")

        except Exception as e:
            print(e)
            pass

    return has_redirected

async def nodriver_kktix_paused_main(tab, url, config_dict):
    show_debug_message = util.get_debug_mode(config_dict)

    is_url_contain_sign_in = False
    if '/users/sign_in?' in url:
        redirect_needed = await nodriver_kktix_signin(tab, url, config_dict)
        is_url_contain_sign_in = True

        return redirect_needed

    return False

async def nodriver_goto_homepage(driver, config_dict):
    homepage = config_dict["homepage"]
    if 'kktix.c' in homepage:
        # for like human.
        try:
            tab = await driver.get(homepage)
            await asyncio.sleep(random.uniform(1.0, 2.5))
        except Exception as e:
            pass
        

        if len(config_dict["accounts"]["kktix_account"])>0:
            if not 'https://kktix.com/users/sign_in?' in homepage:
                homepage = CONST_KKTIX_SIGN_IN_URL % (homepage)

    if 'famiticket.com' in homepage:
        if len(config_dict["accounts"]["fami_account"])>0:
            homepage = CONST_FAMI_SIGN_IN_URL

    if 'kham.com' in homepage:
        if len(config_dict["accounts"]["kham_account"])>0:
            homepage = CONST_KHAM_SIGN_IN_URL

    if 'ticket.com.tw' in homepage:
        if len(config_dict["accounts"]["ticket_account"])>0:
            homepage = CONST_TICKET_SIGN_IN_URL

    if 'udnfunlife.com' in homepage:
        if len(config_dict["accounts"]["udn_account"])>0:
            homepage = CONST_UDN_SIGN_IN_URL

    if 'urbtix.hk' in homepage:
        if len(config_dict["accounts"]["urbtix_account"])>0:
            homepage = CONST_URBTIX_SIGN_IN_URL

    if 'cityline.com' in homepage:
        if len(config_dict["accounts"]["cityline_account"])>0:
            homepage = CONST_CITYLINE_SIGN_IN_URL

    if 'hkticketing.com' in homepage:
        if len(config_dict["accounts"]["hkticketing_account"])>0:
            if 'hkt.hkticketing.com' in homepage:
                # Type02: hkt.hkticketing.com SPA
                homepage = CONST_HKTICKETING_TYPE02_SIGN_IN_URL
            else:
                # Type01: premier.hkticketing.com
                homepage = CONST_HKTICKETING_SIGN_IN_URL

    # https://ticketplus.com.tw/*
    if 'ticketplus.com.tw' in homepage:
        if len(config_dict["accounts"]["ticketplus_account"]) > 1:
            homepage = "https://ticketplus.com.tw/"

    try:
        tab = await driver.get(homepage)
        await asyncio.sleep(random.uniform(1.0, 2.5))
    except Exception as e:
        pass

    tixcraft_family = False
    if 'tixcraft.com' in homepage:
        tixcraft_family = True

    if 'indievox.com' in homepage:
        tixcraft_family = True

    if 'ticketmaster.' in homepage:
        tixcraft_family = True

    if tixcraft_family:
        # Determine correct cookie domain and name based on homepage
        # Each site uses different session cookie names (Issue #207)
        if 'ticketmaster.sg' in homepage:
            cookie_domain = "ticketmaster.sg"
            cookie_name = "TIXPUISID"
        elif 'ticketmaster.com' in homepage:
            cookie_domain = ".ticketmaster.com"
            cookie_name = "TIXUISID"
        elif 'indievox.com' in homepage:
            cookie_domain = "www.indievox.com"
            cookie_name = "IVUISID"
        else:
            cookie_domain = ".tixcraft.com"
            cookie_name = "TIXUISID"

        tixcraft_sid = config_dict["accounts"]["tixcraft_sid"]
        if len(tixcraft_sid) > 1:
            if util.get_debug_mode(config_dict):
                print(f"Setting tixcraft {cookie_name} cookie, length: {len(tixcraft_sid)}")

            try:
                from nodriver import cdp

                # Step 1: Delete existing cookies (both legacy SID and session cookie)
                try:
                    await tab.send(cdp.network.delete_cookies(
                        name="SID",
                        domain=cookie_domain
                    ))
                    await tab.send(cdp.network.delete_cookies(
                        name=cookie_name,
                        domain=cookie_domain
                    ))
                    # Delete cookies from alternate domain to avoid conflicts
                    if 'indievox.com' in homepage:
                        await tab.send(cdp.network.delete_cookies(
                            name=cookie_name,
                            domain=".indievox.com"
                        ))
                    if 'ticketmaster.sg' in homepage:
                        await tab.send(cdp.network.delete_cookies(
                            name=cookie_name,
                            domain=".ticketmaster.sg"
                        ))
                    if util.get_debug_mode(config_dict):
                        print(f"Deleted existing SID and {cookie_name} cookies for domain: {cookie_domain}")
                except Exception as del_e:
                    if util.get_debug_mode(config_dict):
                        print(f"Note: Could not delete existing cookies: {del_e}")

                # Step 2: Set new session cookie using CDP
                cookie_result = await tab.send(cdp.network.set_cookie(
                    name=cookie_name,
                    value=tixcraft_sid,
                    domain=cookie_domain,
                    path="/",
                    secure=True,
                    http_only=True
                ))

                if util.get_debug_mode(config_dict):
                    print(f"CDP setCookie result: {cookie_result}")
                    print(f"tixcraft {cookie_name} cookie set successfully")

                # Verify cookie was set
                updated_cookies = await driver.cookies.get_all()
                sid_cookies = [c for c in updated_cookies if c.name == cookie_name]
                if not sid_cookies:
                    if util.get_debug_mode(config_dict):
                        print(f"Warning: TixCraft {cookie_name} cookie not found after setting")
                elif util.get_debug_mode(config_dict):
                    print(f"Verified {cookie_name} cookie: domain={sid_cookies[0].domain}, value length={len(sid_cookies[0].value)}")

            except Exception as e:
                if util.get_debug_mode(config_dict):
                    print(f"Error setting TixCraft {cookie_name} cookie: {str(e)}")
                    import traceback
                    traceback.print_exc()
                    print("Falling back to old method...")

                # Fallback to old method if CDP fails
                cookies = await driver.cookies.get_all()
                # Filter out all existing SID and session cookies to avoid conflicts
                cookies_filtered = [c for c in cookies if c.name not in ('SID', cookie_name)]
                # Create new session cookie with correct attributes (Issue #144, #207)
                new_cookie = cdp.network.CookieParam(
                    cookie_name,
                    tixcraft_sid,
                    domain=cookie_domain,
                    path="/",
                    http_only=True,
                    secure=True
                )
                cookies_filtered.append(new_cookie)
                await driver.cookies.set_all(cookies_filtered)

                if util.get_debug_mode(config_dict):
                    print(f"tixcraft {cookie_name} cookie set successfully (fallback method)")

    if 'ibon.com' in homepage:
        # Special handling for tour.ibon.com.tw:
        # Need to visit ticket.ibon.com.tw first to complete OAuth and get _at_e token
        is_tour_ibon = 'tour.ibon.com.tw' in homepage
        original_homepage = homepage

        if is_tour_ibon:
            if util.get_debug_mode(config_dict):
                print("[TOUR IBON] Detected tour.ibon.com.tw homepage")
                print("[TOUR IBON] Step 1: Visiting ticket.ibon.com.tw first for OAuth...")

            # Step 1: Visit ticket.ibon.com.tw homepage first
            try:
                tab = await driver.get("https://ticket.ibon.com.tw/")
                await asyncio.sleep(random.uniform(1.5, 2.5))
            except Exception as e:
                if util.get_debug_mode(config_dict):
                    print(f"[TOUR IBON] Error visiting ticket.ibon.com.tw: {e}")

        # Step 2: Set ibon cookie
        login_result = await nodriver_ibon_login(tab, config_dict, driver)

        if util.get_debug_mode(config_dict):
            if login_result['success']:
                print("ibon login process completed successfully")
            else:
                print(f"ibon login process failed: {login_result.get('reason', 'unknown')}")
                if 'error' in login_result:
                    print(f"Error details: {login_result['error']}")

        # Step 3: For tour.ibon.com.tw, navigate to original homepage after OAuth
        if is_tour_ibon:
            if util.get_debug_mode(config_dict):
                print(f"[TOUR IBON] Step 2: Navigating to tour.ibon homepage: {original_homepage}")

            try:
                tab = await driver.get(original_homepage)
                await asyncio.sleep(random.uniform(1.5, 2.5))
            except Exception as e:
                if util.get_debug_mode(config_dict):
                    print(f"[TOUR IBON] Error navigating to tour.ibon homepage: {e}")

        # 不管成功與否，都繼續後續處理，讓使用者手動處理登入問題
        # 這樣可以避免完全中斷搶票流程

    # FunOne cookie injection (same pattern as TixCraft/iBon)
    if 'tickets.funone.io' in homepage:
        funone_cookie = config_dict["accounts"].get("funone_session_cookie", "").strip()
        if len(funone_cookie) > 1:
            if util.get_debug_mode(config_dict):
                print(f"[FUNONE] Setting ticket_session cookie, length: {len(funone_cookie)}")

            try:
                from nodriver import cdp

                # Set ticket_session cookie using CDP
                await tab.send(cdp.network.set_cookie(
                    name="ticket_session",
                    value=funone_cookie,
                    domain="tickets.funone.io",
                    path="/",
                    secure=False,
                    http_only=True
                ))

                if util.get_debug_mode(config_dict):
                    print("[FUNONE] ticket_session cookie set successfully")

                # Verify cookie was set
                updated_cookies = await driver.cookies.get_all()
                funone_cookies = [c for c in updated_cookies if c.name == 'ticket_session']
                if funone_cookies:
                    if util.get_debug_mode(config_dict):
                        print(f"[FUNONE] Verified cookie: domain={funone_cookies[0].domain}, value length={len(funone_cookies[0].value)}")

                    # Reload page to apply cookie
                    if util.get_debug_mode(config_dict):
                        print("[FUNONE] Reloading page to apply cookie...")
                    await tab.reload()
                    await asyncio.sleep(1.5)
                else:
                    if util.get_debug_mode(config_dict):
                        print("[FUNONE] Warning: ticket_session cookie not found after setting")

            except Exception as e:
                if util.get_debug_mode(config_dict):
                    print(f"[FUNONE] Error setting cookie: {str(e)}")

    return tab

async def nodriver_kktix_travel_price_list(tab, config_dict, kktix_area_auto_select_mode, kktix_area_keyword):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return True, False, None

    show_debug_message = util.get_debug_mode(config_dict)

    ticket_number = config_dict["ticket_number"]

    areas = None
    pending_tickets = None
    is_ticket_number_assigned = False

    ticket_price_list = None
    try:
        # 舊版優先
        ticket_price_list = await tab.query_selector_all('div.display-table-row')
        # 若舊版找不到，使用新版選擇器
        if not ticket_price_list or len(ticket_price_list) == 0:
            ticket_price_list = await tab.query_selector_all('div.ticket-item')
    except Exception as exc:
        ticket_price_list = None
        print("find ticket-price Exception:")
        print(exc)
        pass

    is_dom_ready = True
    price_list_count = 0
    if not ticket_price_list is None:
        price_list_count = len(ticket_price_list)
        if show_debug_message:
            print("found price count:", price_list_count)
    else:
        is_dom_ready = False
        print("find ticket-price fail")

    if price_list_count > 0:
        areas = []
        pending_tickets = []  # Track matched tickets waiting for "not yet open" to open
        input_index = 0  # Track valid input index

        # Parse area keywords (space-separated = AND logic)
        # Support N keywords (previously limited to 2)
        kktix_area_keyword_array = [kw.strip() for kw in kktix_area_keyword.split(' ') if kw.strip()]
        # Clean stop words for all keywords
        kktix_area_keyword_array = [util.format_keyword_string(kw) for kw in kktix_area_keyword_array]

        if show_debug_message:
            print(f'[KKTIX AREA] Keywords (AND logic): {kktix_area_keyword_array}')

        for i, row in enumerate(ticket_price_list):
            row_text = ""
            row_html = ""
            row_input = None
            current_ticket_number = "0"
            try:
                # 使用 JavaScript 一次取得所有資料，避免使用元素物件方法
                result = await tab.evaluate(f'''
                    (function() {{
                        // 舊版優先
                        let rows = document.querySelectorAll('div.display-table-row');
                        // 若舊版找不到，使用新版選擇器
                        if (rows.length === 0) {{
                            rows = document.querySelectorAll('div.ticket-item');
                        }}
                        if (rows[{i}]) {{
                            const row = rows[{i}];
                            const input = row.querySelector('input');
                            return {{
                                html: row.innerHTML,
                                text: row.textContent || row.innerText || "",
                                hasInput: !!input,
                                inputValue: input ? input.value : "0"
                            }};
                        }}
                        return {{ html: "", text: "", hasInput: false, inputValue: "0" }};
                    }})();
                ''')

                # 使用統一解析函數處理返回值
                result = util.parse_nodriver_result(result)
                if result:
                    row_html = result.get('html', '')
                    row_text = util.remove_html_tags(row_html)
                    current_ticket_number = result.get('inputValue', '0')
                    if result.get('hasInput'):
                        row_input = input_index  # 儲存有效 input 的索引
            except Exception as exc:
                is_dom_ready = False
                if show_debug_message:
                    print(f"Error in nodriver_kktix_travel_price_list: {exc}")
                # error, exit loop
                break

            if len(row_text) > 0:
                # Preserve "not yet open" tickets for keyword matching
                # Only filter permanently unavailable tickets (sold out)

                # Multi-language "sold out" keyword filtering
                sold_out_keywords = ['暫無票', '已售完', 'Sold Out', 'sold out', '完売']
                is_sold_out = any(kw in row_text for kw in sold_out_keywords)

                if is_sold_out:
                    row_text = ""
                    if show_debug_message:
                        print(f"  -> Filtered: sold out")

                # Multi-language "not yet open" check (preserve these tickets for keyword matching)
                not_yet_open_keywords = [
                    '未開賣', '尚未開賣', '尚未開始', '即將開賣',
                    'Not Started', 'not started',
                    'まだ発売'
                ]
                has_not_yet_open_status = any(kw in row_text for kw in not_yet_open_keywords)

                if has_not_yet_open_status and show_debug_message:
                    print(f"  -> Preserved ticket with 'not yet open' status for keyword matching")

                # Filter tickets without input field, EXCEPT "not yet open" tickets
                if len(row_text) > 0 and not('<input type=' in row_html):
                    if not has_not_yet_open_status:
                        row_text = ""
                        if show_debug_message:
                            print(f"  -> Filtered: no input field and not 'not yet open'")
                    else:
                        if show_debug_message:
                            print(f"  -> Kept 'not yet open' ticket for keyword matching (no input yet)")

            if len(row_text) > 0:
                if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                    row_text = ""

            if len(row_text) > 0:
                # clean stop word.
                row_text = util.format_keyword_string(row_text)

            if len(row_text) > 0:
                if ticket_number > 1:
                    # start to check danger notice.
                    # 剩 n 張票 / n Left / 残り n 枚
                    ticket_count = 999
                    # for cht.
                    if ' danger' in row_html and '剩' in row_text and '張' in row_text:
                        tmp_array = row_html.split('剩')
                        tmp_array = tmp_array[1].split('張')
                        if len(tmp_array) > 0:
                            tmp_ticket_count = tmp_array[0].strip()
                            if tmp_ticket_count.isdigit():
                                ticket_count = int(tmp_ticket_count)
                                if show_debug_message:
                                    print("found ticket 剩:", tmp_ticket_count)
                    # for ja.
                    if ' danger' in row_html and '残り' in row_text and '枚' in row_text:
                        tmp_array = row_html.split('残り')
                        tmp_array = tmp_array[1].split('枚')
                        if len(tmp_array) > 0:
                            tmp_ticket_count = tmp_array[0].strip()
                            if tmp_ticket_count.isdigit():
                                ticket_count = int(tmp_ticket_count)
                                if show_debug_message:
                                    print("found ticket 残り:", tmp_ticket_count)
                    # for en.
                    if ' danger' in row_html and ' Left ' in row_html:
                        tmp_array = row_html.split(' Left ')
                        tmp_array = tmp_array[0].split('>')
                        if len(tmp_array) > 0:
                            tmp_ticket_count = tmp_array[len(tmp_array)-1].strip()
                            if tmp_ticket_count.isdigit():
                                if show_debug_message:
                                    print("found ticket left:", tmp_ticket_count)
                                ticket_count = int(tmp_ticket_count)

                    if ticket_count < ticket_number:
                        # skip this row, due to no ticket remaining.
                        if show_debug_message:
                            print("found ticket left:", tmp_ticket_count, ",but target ticket:", ticket_number)
                        row_text = ""

            # Keyword matching for ALL preserved tickets (including "not yet open")
            # This is the key improvement: match keywords regardless of input field status
            if len(row_text) > 0:
                # Check if already assigned
                if len(current_ticket_number) > 0 and current_ticket_number != "0":
                    is_ticket_number_assigned = True
                    break

                # Perform keyword matching
                is_match_area = False
                if len(kktix_area_keyword_array) == 0:
                    # No keyword specified, match all
                    is_match_area = True
                else:
                    # Check if all keywords match (AND logic)
                    is_match_area = all(kw in row_text for kw in kktix_area_keyword_array)

                if show_debug_message:
                    original_text = util.remove_html_tags(result.get('html', '')) if result else ""
                    original_text = ' '.join(original_text.split())  # Remove extra whitespace and newlines
                    print(f"[KKTIX] Ticket index {i}: {original_text[:60]}")
                    print(f"  -> Keyword match: {is_match_area}")

                # Handle matched tickets based on input field availability
                if is_match_area:
                    if row_input is not None:
                        # Has input field (purchasable) - add to selection list
                        areas.append(row_input)
                        if show_debug_message:
                            print(f"  -> Matched and added to selection list (input index: {row_input})")

                        # From top to bottom mode: match first then break
                        if kktix_area_auto_select_mode == CONST_FROM_TOP_TO_BOTTOM:
                            if show_debug_message:
                                print(f"[KKTIX AREA] Mode is '{kktix_area_auto_select_mode}', stopping at first match")
                            break
                    else:
                        # No input field (not yet open) - track as pending
                        pending_tickets.append({
                            'index': i,
                            'text': original_text[:60] if show_debug_message else row_text[:60],
                            'keywords': kktix_area_keyword_array
                        })
                        if show_debug_message:
                            print(f"  -> Matched but waiting for ticket to open (keywords: {', '.join(kktix_area_keyword_array)})")

            # Increment input index if this row has an input field
            if row_input is not None:
                input_index += 1

            if not is_dom_ready:
                # DOM not ready, break the loop
                break
    else:
        if show_debug_message:
            print("[KKTIX] No price list found")
        pass

    # Match result summary
    if show_debug_message:
        total_checked = len(ticket_price_list) if ticket_price_list else 0
        total_matched_with_input = len(areas) if areas else 0
        total_matched_pending = len(pending_tickets) if pending_tickets else 0
        total_matched_all = total_matched_with_input + total_matched_pending

        print(f"[KKTIX AREA] ========================================")
        print(f"[KKTIX AREA] Match Summary:")
        print(f"[KKTIX AREA]   Total ticket types checked: {total_checked}")
        print(f"[KKTIX AREA]   Tickets matched (with input): {total_matched_with_input}")
        print(f"[KKTIX AREA]   Tickets matched (waiting for open): {total_matched_pending}")

        if total_matched_pending > 0:
            print(f"[KKTIX AREA]")
            print(f"[KKTIX AREA]   Waiting for these tickets to open:")
            for pending in pending_tickets[:5]:  # Show max 5 pending tickets
                keywords_str = ', '.join(pending['keywords'])
                print(f"[KKTIX AREA]     - {pending['text']} (keywords: {keywords_str})")
            if total_matched_pending > 5:
                print(f"[KKTIX AREA]     ... and {total_matched_pending - 5} more")

        if total_checked > 0 and total_matched_all > 0:
            match_rate = total_matched_all / total_checked * 100
            print(f"[KKTIX AREA]   Overall match rate: {match_rate:.1f}%")
        elif total_matched_all == 0:
            print(f"[KKTIX AREA]   No ticket types matched")

        print(f"[KKTIX AREA] ========================================")

    # Check pause after traversal
    if await check_and_handle_pause(config_dict):
        return True, False, None

    return is_dom_ready, is_ticket_number_assigned, areas


async def nodriver_kktix_assign_ticket_number(tab, config_dict, kktix_area_keyword):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return True, False, False

    show_debug_message = util.get_debug_mode(config_dict)

    ticket_number_str = str(config_dict["ticket_number"])
    auto_select_mode = config_dict["area_auto_select"]["mode"]

    # Track selection type: empty keyword means fallback selection
    is_fallback_selection = (kktix_area_keyword == "")

    is_ticket_number_assigned = False
    matched_blocks = None
    is_dom_ready = True
    is_dom_ready, is_ticket_number_assigned, matched_blocks = await nodriver_kktix_travel_price_list(tab, config_dict, auto_select_mode, kktix_area_keyword)

    target_area = None
    is_need_refresh = False
    if is_dom_ready:
        if not is_ticket_number_assigned:
            target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

        if not matched_blocks is None:
            if len(matched_blocks) == 0:
                is_need_refresh = True
                if show_debug_message:
                    print("matched_blocks is empty, is_need_refresh")

    if not target_area is None:
        # 顯示選中目標訊息
        if show_debug_message:
            try:
                print(f"[KKTIX AREA] Auto-select mode: {auto_select_mode}")
                print(f"[KKTIX AREA] Selected target: #{target_area + 1}/{len(matched_blocks)}")
            except:
                print(f"[KKTIX AREA] Auto-select mode: {auto_select_mode}")

        current_ticket_number = ""
        if show_debug_message:
            print("try to set input box value.")

        try:
            # target_area 現在是索引，直接使用
            target_index = target_area

            # 使用 JavaScript 操作，避免使用元素物件方法
            assign_result = await tab.evaluate(f'''
                (function() {{
                    // 舊版優先
                    let inputs = document.querySelectorAll('div.display-table-row input');
                    // 若舊版找不到，使用新版選擇器
                    if (inputs.length === 0) {{
                        inputs = document.querySelectorAll('div.ticket-item input.number-step-input-core');
                    }}
                    const targetInput = inputs[{target_index}];

                    if (!targetInput) {{
                        return {{ success: false, error: "Input not found", inputCount: inputs.length, targetIndex: {target_index} }};
                    }}

                    // 取得對應的票種名稱，清理多餘空白
                    // 舊版優先使用 display-table-row，新版使用 ticket-item
                    let parentRow = targetInput.closest('div.display-table-row');
                    if (!parentRow) {{
                        parentRow = targetInput.closest('div.ticket-item');
                    }}
                    let ticketName = "未知票種";
                    if (parentRow) {{
                        ticketName = parentRow.textContent
                            .replace(/\\s+/g, ' ')  // 將多個空白字符替換為單個空格
                            .replace(/\\n/g, ' ')   // 替換換行符
                            .trim();                // 移除前後空白
                    }}

                    const currentValue = targetInput.value;

                    if (currentValue === "0") {{
                        targetInput.focus();
                        targetInput.select();
                        targetInput.value = "{ticket_number_str}";

                        // 更完整的事件觸發
                        targetInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        targetInput.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        targetInput.dispatchEvent(new Event('blur', {{ bubbles: true }}));

                        // 確保 Angular 模型更新
                        if (window.angular) {{
                            const scope = window.angular.element(targetInput).scope();
                            if (scope) {{
                                scope.$apply();
                            }}
                        }}

                        return {{ success: true, assigned: true, value: "{ticket_number_str}", ticketName: ticketName }};
                    }} else {{
                        return {{ success: true, assigned: false, value: currentValue, alreadySet: true, ticketName: ticketName }};
                    }}
                }})();
            ''')

            # 使用統一解析函數處理返回值
            assign_result = util.parse_nodriver_result(assign_result)

            if assign_result and assign_result.get('success') and assign_result.get('assigned'):
                await asyncio.sleep(0.2)

            if assign_result and assign_result.get('success'):
                current_ticket_number = assign_result.get('value', '')
                ticket_name = assign_result.get('ticketName', '未知票種')

                if assign_result.get('assigned'):
                    # 清理票種名稱中的換行符號和多餘空白
                    clean_ticket_name = ' '.join(ticket_name.split())

                    # T013 equivalent: Log selected area with selection type
                    selection_type = "fallback" if is_fallback_selection else "keyword match"
                    print(f"[KKTIX AREA SELECT] Selected ticket: {clean_ticket_name} ({selection_type})")
                    print("assign ticket number:%s to [%s]" % (ticket_number_str, clean_ticket_name))
                    is_ticket_number_assigned = True
                elif assign_result.get('alreadySet'):
                    if show_debug_message:
                        print("value already assigned to [%s]" % ticket_name)
                    is_ticket_number_assigned = True

                if show_debug_message:
                    print(f"[TICKET] current_ticket_number: {current_ticket_number}")
                    print(f"[TICKET] selected_ticket_name: {ticket_name}")

                if is_ticket_number_assigned and show_debug_message:
                    print("KKTIX ticket number input completed, skipping verification")
            else:
                if show_debug_message:
                    error_msg = assign_result.get('error', 'Unknown error') if assign_result else 'No result'
                    print(f"Error in nodriver_kktix_assign_ticket_number: {error_msg}")

        except Exception as exc:
            if show_debug_message:
                print(f"Error in nodriver_kktix_assign_ticket_number: {exc}")

    # 票數分配後檢查暫停
    if await check_and_handle_pause(config_dict):
        return True, False, False

    return is_dom_ready, is_ticket_number_assigned, is_need_refresh


async def nodriver_kktix_reg_captcha(tab, config_dict, fail_list, registrationsNewApp_div):
    """增強版驗證碼處理，包含重試機制和人類化延遲"""
    show_debug_message = util.get_debug_mode(config_dict)

    answer_list = []
    success = False  # 初始化按鈕點擊狀態

    # 批次檢查頁面元素狀態
    elements_check = await tab.evaluate('''
        (function() {
            return {
                hasQuestion: !!document.querySelector('div.custom-captcha-inner p'),
                hasInput: !!document.querySelector('div.custom-captcha-inner > div > div > input'),
                hasButtons: document.querySelectorAll('div.register-new-next-button-area > button').length,
                questionText: document.querySelector('div.custom-captcha-inner p')?.innerText || ''
            };
        })();
    ''')
    elements_check = util.parse_nodriver_result(elements_check)

    is_question_popup = False
    if elements_check and elements_check.get('hasQuestion'):
        question_text = elements_check.get('questionText', '')

        if len(question_text) > 0:
            is_question_popup = True
            write_question_to_file(question_text)

            answer_list = util.get_answer_list_from_user_guess_string(config_dict, CONST_MAXBOT_ANSWER_ONLINE_FILE)
            if len(answer_list)==0:
                if config_dict["advanced"]["auto_guess_options"]:
                    answer_list = util.get_answer_list_from_question_string(None, question_text)

            inferred_answer_string = ""
            for answer_item in answer_list:
                if not answer_item in fail_list:
                    inferred_answer_string = answer_item
                    break

            if len(answer_list) > 0:
                answer_list = list(dict.fromkeys(answer_list))

            if show_debug_message:
                print("inferred_answer_string:", inferred_answer_string)
                print("question_text:", question_text)
                print("answer_list:", answer_list)
                print("fail_list:", fail_list)

            # 增強版答案填寫流程，包含重試機制
            if len(inferred_answer_string) > 0 and elements_check.get('hasInput'):
                success = False
                max_retries = 3

                for retry_count in range(max_retries):
                    if show_debug_message and retry_count > 0:
                        print(f"Captcha filling retry {retry_count}/{max_retries}")

                    try:
                        # 人類化延遲：0.3-1秒隨機延遲
                        human_delay = random.uniform(0.3, 1.0)
                        await tab.sleep(human_delay)

                        # 填寫驗證碼答案
                        fill_result = await tab.evaluate(f'''
                            (function() {{
                                const input = document.querySelector('div.custom-captcha-inner > div > div > input');
                                if (!input) {{
                                    return {{ success: false, error: "Input not found" }};
                                }}

                                // 確保輸入框可見和可用
                                if (input.disabled || input.readOnly) {{
                                    return {{ success: false, error: "Input is disabled or readonly" }};
                                }}

                                // 模擬人類打字
                                input.focus();
                                input.value = "";

                                const answer = "{inferred_answer_string}";
                                for (let i = 0; i < answer.length; i++) {{
                                    input.value += answer[i];
                                    input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                }}

                                input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                input.blur();

                                return {{
                                    success: true,
                                    value: input.value,
                                    focused: document.activeElement === input
                                }};
                            }})();
                        ''')

                        fill_result = util.parse_nodriver_result(fill_result)

                        if fill_result and fill_result.get('success'):
                            if show_debug_message:
                                print(f"Captcha answer filled successfully: {inferred_answer_string}")

                            # 短暫延遲後點擊按鈕
                            button_delay = random.uniform(0.5, 1.2)
                            await tab.sleep(button_delay)

                            # 點擊下一步按鈕
                            button_click_success = await nodriver_kktix_press_next_button(tab, config_dict)

                            if button_click_success:
                                success = True
                                # 最終延遲
                                final_delay = random.uniform(0.75, 1.5)
                                await tab.sleep(final_delay)

                                fail_list.append(inferred_answer_string)
                                break
                            else:
                                if show_debug_message:
                                    print("Button click failed, retrying...")
                        else:
                            error_msg = fill_result.get('error', 'Unknown error') if fill_result else 'No result'
                            if show_debug_message:
                                print(f"Input filling failed: {error_msg}")

                    except Exception as exc:
                        if show_debug_message:
                            print(f"Captcha retry {retry_count + 1} failed: {exc}")

                    # 重試前的等待
                    if not success and retry_count < max_retries - 1:
                        retry_delay = random.uniform(0.8, 1.5)
                        await tab.sleep(retry_delay)

                if not success and show_debug_message:
                    print("All captcha filling attempts failed")

    return fail_list, is_question_popup, success

async def debug_kktix_page_state(tab, show_debug=True):
    """收集 KKTIX 頁面狀態供除錯，參考 NoDriver API 指南"""
    try:
        state = await tab.evaluate('''
            (function() {
                // 基本頁面資訊
                const basicInfo = {
                    url: window.location.href,
                    title: document.title,
                    readyState: document.readyState,
                    documentHeight: document.documentElement.scrollHeight,
                    viewportHeight: window.innerHeight
                };

                // KKTIX 特定元素檢查
                const kktixElements = {
                    hasRegistrationDiv: !!document.querySelector('#registrationsNewApp'),
                    hasTicketAreas: document.querySelectorAll('div.display-table-row').length,
                    hasPriceList: document.querySelectorAll('.display-table-row').length
                };

                // 驗證碼相關元素
                const captchaElements = {
                    hasQuestion: !!document.querySelector('div.custom-captcha-inner p'),
                    questionText: document.querySelector('div.custom-captcha-inner p')?.innerText || '',
                    hasInput: !!document.querySelector('div.custom-captcha-inner input'),
                    inputValue: document.querySelector('div.custom-captcha-inner input')?.value || '',
                    inputDisabled: document.querySelector('div.custom-captcha-inner input')?.disabled || false
                };

                // 按鈕和表單元素
                const formElements = {
                    nextButtons: document.querySelectorAll('div.register-new-next-button-area > button').length,
                    checkboxes: document.querySelectorAll('input[type="checkbox"]').length,
                    radioButtons: document.querySelectorAll('input[type="radio"]').length,
                    textInputs: document.querySelectorAll('input[type="text"]').length,
                    submitButtons: document.querySelectorAll('input[type="submit"], button[type="submit"]').length
                };

                // 錯誤訊息檢查 - 更精確地檢查實際的錯誤訊息
                const errorMessages = {
                    hasErrorMessages: !!document.querySelector('.alert-danger, .error, .warning'),
                    errorText: document.querySelector('.alert-danger, .error, .warning')?.innerText || '',
                    soldOut: !!document.querySelector('.alert-danger, .error')?.innerText?.includes('售完') ||
                            !!document.querySelector('.alert-danger, .error')?.innerText?.includes('已售完') ||
                            !!document.querySelector('.alert-danger, .error')?.innerText?.includes('Sold Out') ||
                            !!document.querySelector('.sold-out, .unavailable'),
                    notYetOpen: !!document.querySelector('.alert-danger, .error')?.innerText?.includes('未開賣') ||
                               !!document.querySelector('.alert-danger, .error')?.innerText?.includes('尚未開賣') ||
                               !!document.querySelector('.alert-danger, .error')?.innerText?.includes('尚未開始') ||
                               !!document.querySelector('.alert-danger, .error')?.innerText?.includes('即將開賣') ||
                               !!document.querySelector('.alert-danger, .error')?.innerText?.includes('Not Started') ||
                               !!document.querySelector('.alert-danger, .error')?.innerText?.includes('まだ発売')
                };

                // 頁面載入狀態
                const loadingState = {
                    hasLoadingSpinner: !!document.querySelector('.loading, .spinner, [class*="load"]'),
                    scriptsLoaded: document.scripts.length,
                    stylesheetsLoaded: document.styleSheets.length,
                    imagesLoaded: Array.from(document.images).filter(img => img.complete).length,
                    totalImages: document.images.length
                };

                return {
                    timestamp: new Date().toISOString(),
                    basic: basicInfo,
                    kktix: kktixElements,
                    captcha: captchaElements,
                    forms: formElements,
                    errors: errorMessages,
                    loading: loadingState
                };
            })();
        ''')

        # 解析結果
        state = util.parse_nodriver_result(state)

        if show_debug and state:
            print("=== KKTIX Page Debug State ===")
            print(f"URL: {state.get('basic', {}).get('url', 'N/A')}")
            print(f"Ready State: {state.get('basic', {}).get('readyState', 'N/A')}")
            print(f"Registration Div: {state.get('kktix', {}).get('hasRegistrationDiv', False)}")
            print(f"Ticket Areas: {state.get('kktix', {}).get('hasTicketAreas', 0)}")
            print(f"Captcha Question: {state.get('captcha', {}).get('hasQuestion', False)}")
            if state.get('captcha', {}).get('questionText'):
                print(f"Question Text: {state.get('captcha', {}).get('questionText', '')[:50]}...")
            print(f"Next Buttons: {state.get('forms', {}).get('nextButtons', 0)}")
            print(f"Error Messages: {state.get('errors', {}).get('hasErrorMessages', False)}")
            if state.get('errors', {}).get('soldOut'):
                print("[SOLD OUT] Sold Out detected")
            if state.get('errors', {}).get('notYetOpen'):
                print("Not yet open detected")
            print("=" * 30)

        return state

    except Exception as exc:
        error_state = {
            'success': False,
            'error': f'Exception in debug_kktix_page_state: {exc}',
            'timestamp': datetime.now().isoformat()
        }
        if show_debug:
            print(f"Debug failed: {exc}")
        return error_state

async def nodriver_kktix_date_auto_select(tab, config_dict):
    """KKTIX multi-session date selection with keyword matching"""
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # T003: Check main switch (defensive programming)
    if not config_dict["date_auto_select"]["enable"]:
        if show_debug_message:
            print("[KKTIX DATE SELECT] Main switch is disabled, skipping date selection")
        return False

    # Read config
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get('date_auto_fallback', False)  # T017: Safe access for new field (default: strict mode)

    # Check if multi-session page exists with smart polling
    session_list = None
    max_wait = 5
    check_interval = 0.3
    max_attempts = int(max_wait / check_interval)

    for attempt in range(max_attempts):
        try:
            session_list = await tab.query_selector_all('div.event-list ul.clearfix > li')
            if session_list and len(session_list) > 0:
                if show_debug_message:
                    print(f"[KKTIX DATE] Found {len(session_list)} sessions after {attempt * check_interval:.1f}s")
                break
        except Exception as exc:
            if show_debug_message and attempt == max_attempts - 1:
                print(f"[KKTIX DATE] Error querying session list: {exc}")

        if attempt < max_attempts - 1:
            await tab.sleep(check_interval)

    if not session_list or len(session_list) == 0:
        if show_debug_message:
            print(f"[KKTIX DATE] Timeout after {max_wait}s waiting for session list")
        return False

    if show_debug_message:
        print(f"[KKTIX DATE] Found {len(session_list)} sessions on page")

    # Extract session info (text + button element)
    formated_session_list = []
    formated_session_list_text = []

    for session_item in session_list:
        try:
            # Get session date text
            date_text = None
            try:
                # Priority 1: span.timezoneSuffix
                date_elem = await session_item.query_selector('span.timezoneSuffix')
                if date_elem:
                    date_text = await date_elem.get_html()
                    date_text = util.remove_html_tags(date_text).strip()
            except:
                pass

            if not date_text:
                try:
                    # Fallback: .event-info > a > p
                    date_elem = await session_item.query_selector('.event-info > a > p')
                    if date_elem:
                        date_text = await date_elem.get_html()
                        date_text = util.remove_html_tags(date_text).strip()
                except:
                    pass

            # Check if button exists
            button_elem = await session_item.query_selector('div.content > a.btn-point')

            if date_text and button_elem:
                # Check exclude keywords
                if not util.reset_row_text_if_match_keyword_exclude(config_dict, date_text):
                    formated_session_list.append(button_elem)
                    formated_session_list_text.append(date_text)
                    if show_debug_message:
                        print(f"[KKTIX DATE] Available session: {date_text}")
        except Exception as exc:
            if show_debug_message:
                print(f"[KKTIX DATE] Error processing session: {exc}")
            continue

    if len(formated_session_list) == 0:
        if show_debug_message:
            print("[KKTIX DATE] No available sessions found after filtering")
        return False

    # T004-T008: NEW LOGIC - Early return pattern (Feature 003)
    # Keyword priority matching: first match wins and stops immediately
    matched_blocks = None

    if not date_keyword:
        matched_blocks = formated_session_list
        if show_debug_message:
            print(f"[KKTIX DATE KEYWORD] No keyword specified, using all {len(formated_session_list)} sessions")
    else:
        # NEW: Early return pattern - iterate keywords in order
        matched_blocks = []
        target_row_found = False
        keyword_matched_index = -1

        try:
            import json
            import re
            keyword_array = json.loads("[" + date_keyword + "]")

            # T005: Start checking keywords log
            if show_debug_message:
                print(f"[KKTIX DATE KEYWORD] Start checking keywords in order: {keyword_array}")
                print(f"[KKTIX DATE KEYWORD] Total keyword groups: {len(keyword_array)}")
                print(f"[KKTIX DATE KEYWORD] Checking against {len(formated_session_list_text)} available sessions...")

            # NEW: Iterate keywords in priority order (early return)
            for keyword_index, keyword_item_set in enumerate(keyword_array):
                if show_debug_message:
                    print(f"[KKTIX DATE KEYWORD] Checking keyword #{keyword_index + 1}: {keyword_item_set}")

                # Check all rows for this keyword
                for i, session_text in enumerate(formated_session_list_text):
                    normalized_session_text = re.sub(r'\s+', ' ', session_text)
                    is_match = False

                    if isinstance(keyword_item_set, str):
                        # OR logic: single keyword
                        normalized_keyword = re.sub(r'\s+', ' ', keyword_item_set)
                        is_match = normalized_keyword in normalized_session_text
                    elif isinstance(keyword_item_set, list):
                        # AND logic: all keywords must match
                        normalized_keywords = [re.sub(r'\s+', ' ', kw) for kw in keyword_item_set]
                        match_results = [kw in normalized_session_text for kw in normalized_keywords]
                        is_match = all(match_results)

                    if is_match:
                        # T006: Keyword matched log - IMMEDIATELY select and stop
                        matched_blocks = [formated_session_list[i]]
                        target_row_found = True
                        keyword_matched_index = keyword_index
                        if show_debug_message:
                            print(f"[KKTIX DATE KEYWORD] Keyword #{keyword_index + 1} matched: '{keyword_item_set}'")
                            print(f"[KKTIX DATE SELECT] Selected session: {session_text[:80]} (keyword match)")
                        break

                if target_row_found:
                    # EARLY RETURN: Stop checking further keywords
                    break

            # T007: All keywords failed log
            if not target_row_found:
                if show_debug_message:
                    print(f"[KKTIX DATE KEYWORD] All keywords failed to match")

        except Exception as e:
            if show_debug_message:
                print(f"[KKTIX DATE KEYWORD] Parsing error: {e}")
            # On error, use mode selection
            matched_blocks = []

    # Match result summary
    if show_debug_message:
        print(f"[KKTIX DATE KEYWORD] ========================================")
        print(f"[KKTIX DATE KEYWORD] Match Summary:")
        print(f"[KKTIX DATE KEYWORD]   Total sessions available: {len(formated_session_list)}")
        print(f"[KKTIX DATE KEYWORD]   Total sessions matched: {len(matched_blocks)}")
        if matched_blocks and len(matched_blocks) > 0:
            print(f"[KKTIX DATE KEYWORD]   Match rate: {len(matched_blocks)/len(formated_session_list)*100:.1f}%")
            print(f"[KKTIX DATE KEYWORD] ========================================")
        elif not matched_blocks or len(matched_blocks) == 0:
            print(f"[KKTIX DATE KEYWORD]   No sessions matched any keywords")
            print(f"[KKTIX DATE KEYWORD] ========================================")

    # T018-T020: NEW - Conditional fallback based on date_auto_fallback switch
    if matched_blocks is not None and len(matched_blocks) == 0 and date_keyword and len(formated_session_list) > 0:
        if date_auto_fallback:
            # T018: Fallback enabled - use auto_select_mode
            if show_debug_message:
                print(f"[KKTIX DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                print(f"[KKTIX DATE FALLBACK] Selecting available session based on date_select_order='{auto_select_mode}'")
            matched_blocks = formated_session_list
        else:
            # T019: Fallback disabled - strict mode (no selection, but continue to check for reload)
            if show_debug_message:
                print(f"[KKTIX DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                print(f"[KKTIX DATE SELECT] No date selected, will check if reload needed")
            # Don't return - let the function continue to check if selection succeeded
            # matched_blocks remains empty (no selection will be made)

    # Select target using auto_select_mode
    target_button = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

    if show_debug_message:
        if target_button and matched_blocks:
            try:
                target_index = matched_blocks.index(target_button) if target_button in matched_blocks else -1
                print(f"[KKTIX DATE SELECT] Auto-select mode: {auto_select_mode}")
                print(f"[KKTIX DATE SELECT] Selected target: #{target_index + 1}/{len(matched_blocks)}")
            except:
                print(f"[KKTIX DATE SELECT] Auto-select mode: {auto_select_mode}")
                print(f"[KKTIX DATE SELECT] Target selected from {len(matched_blocks)} matched sessions")
        elif not matched_blocks or len(matched_blocks) == 0:
            print(f"[KKTIX DATE SELECT] No target selected (matched_blocks is empty)")

    # Click selected button
    is_date_clicked = False
    if target_button:
        try:
            if show_debug_message:
                print("[KKTIX DATE SELECT] Clicking selected session button...")
            await target_button.click()
            is_date_clicked = True
            if show_debug_message:
                print(f"[KKTIX DATE SELECT] ========================================")
                print(f"[KKTIX DATE SELECT] Session selection completed successfully")
                print(f"[KKTIX DATE SELECT] ========================================")
        except Exception as exc:
            if show_debug_message:
                print(f"[KKTIX DATE SELECT] Click error: {exc}")
                print(f"[KKTIX DATE SELECT] ========================================")

    return is_date_clicked

#   : This is for case-2 next button.
async def nodriver_kktix_events_press_next_button(tab, config_dict=None):
    """點擊活動頁面的「立即購票」按鈕"""
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = util.get_debug_mode(config_dict) if config_dict else False
    try:
        result = await tab.evaluate('''
            (function() {
                const button = document.querySelector('.tickets > a.btn-point');
                if (button) {
                    button.scrollIntoView({ behavior: 'instant', block: 'center' });
                    button.click();
                    return { success: true, message: '成功點擊立即購票按鈕' };
                } else {
                    return { success: false, message: '找不到立即購票按鈕' };
                }
            })()
        ''')

        result = util.parse_nodriver_result(result)

        if result and result.get('success'):
            return True
        else:
            return False

    except Exception as exc:
        print(f"Error clicking events next button: {exc}")
        return False

async def nodriver_kktix_check_guest_modal(tab, config_dict):
    """
    Check and handle KKTIX guest modal (立刻成為 KKTIX 會員)
    Reference: .temp/kktix/kktix-qa-code.html Line 157-172
    Modal appears when user is not logged in on /registrations/new page
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_modal_handled = False

    # Track if we've already checked for guest modal (skip wait on subsequent checks)
    global kktix_dict
    is_first_check = not kktix_dict.get("guest_modal_checked", False) if 'kktix_dict' in globals() else True

    try:
        # Only wait on first check (modal typically appears on initial page load)
        if is_first_check:
            await asyncio.sleep(random.uniform(0.3, 0.5))
            if 'kktix_dict' in globals():
                kktix_dict["guest_modal_checked"] = True

        # Check if guest modal exists and is visible
        modal_visible = await tab.evaluate('''
            (function() {
                const modal = document.querySelector('#guestModal');
                if (modal) {
                    // Check if modal is actually visible
                    const style = window.getComputedStyle(modal);
                    const isVisible = style.display !== 'none' &&
                                    style.visibility !== 'hidden' &&
                                    parseFloat(style.opacity) > 0;
                    return isVisible;
                }
                return false;
            })()
        ''')

        if modal_visible:
            if show_debug_message:
                print("[KKTIX GUEST MODAL] Guest modal detected, clicking dismiss button...")

            # Click the dismiss button (暫時不要)
            click_result = await tab.evaluate('''
                (function() {
                    const dismissBtn = document.querySelector('#guestModal button[data-dismiss="modal"]');
                    if (dismissBtn) {
                        dismissBtn.click();
                        return { success: true, clicked: true };
                    }
                    return { success: false, error: 'Dismiss button not found' };
                })()
            ''')

            # Parse result using utility function
            click_result = util.parse_nodriver_result(click_result)

            if click_result and click_result.get('clicked'):
                if show_debug_message:
                    print("[KKTIX GUEST MODAL] Successfully dismissed guest modal")
                # Wait for modal to close
                await asyncio.sleep(random.uniform(0.3, 0.5))
                is_modal_handled = True
        else:
            if show_debug_message:
                print("[KKTIX GUEST MODAL] No guest modal detected")

    except Exception as exc:
        if show_debug_message:
            print(f"[ERROR] Guest modal check failed: {exc}")

    return is_modal_handled

async def nodriver_kktix_press_next_button(tab, config_dict=None):
    """使用 JavaScript 點擊下一步按鈕，包含重試和等待機制"""
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = util.get_debug_mode(config_dict) if config_dict else False

    # 重試機制：最多嘗試 3 次
    for retry_count in range(3):
        try:
            # 如果不是第一次嘗試，等待一下
            if retry_count > 0:
                await asyncio.sleep(0.5)
                if show_debug_message:
                    print(f"KKTIX 按鈕點擊重試 {retry_count + 1}/3")

            result = await tab.evaluate('''
                (function() {
                    const buttons = document.querySelectorAll('div.register-new-next-button-area > button');
                    if (buttons.length === 0) {
                        return { success: false, error: 'No buttons found', buttonCount: 0 };
                    }

                    // 點擊最後一個按鈕
                    const targetButton = buttons[buttons.length - 1];

                    // 詳細檢查按鈕狀態
                    const buttonText = targetButton.innerText || targetButton.textContent || '';
                    const isDisabled = targetButton.disabled ||
                                      targetButton.classList.contains('disabled') ||
                                      targetButton.getAttribute('disabled') !== null;

                    // 檢查是否正在處理中
                    const isProcessing = buttonText.includes('查詢空位中') ||
                                        buttonText.includes('處理中') ||
                                        buttonText.includes('請稍候') ||
                                        buttonText.includes('請勿重新整理');

                    if (isDisabled) {
                        if (isProcessing) {
                            return {
                                success: true,
                                processing: true,
                                error: 'Processing seats',
                                buttonCount: buttons.length,
                                buttonText: buttonText
                            };
                        } else {
                            return {
                                success: false,
                                error: 'Button is disabled',
                                buttonCount: buttons.length,
                                buttonText: buttonText
                            };
                        }
                    }

                    // 模擬真實點擊事件
                    const event = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });

                    targetButton.scrollIntoView({ behavior: 'instant', block: 'center' });
                    targetButton.focus();
                    targetButton.dispatchEvent(event);

                    return {
                        success: true,
                        clicked: true,
                        buttonText: targetButton.innerText || targetButton.textContent || '',
                        buttonCount: buttons.length
                    };
                })();
            ''')

            # 使用統一解析函數處理返回值
            result = util.parse_nodriver_result(result)

            if result and result.get('success'):
                button_text = result.get('buttonText', '').strip()

                # 檢查是否是處理中狀態
                if result.get('processing'):
                    if show_debug_message:
                        print(f"KKTIX processing: [{button_text}]")

                    # 等待較長時間給 KKTIX 處理
                    await asyncio.sleep(1.5)

                    # 主動檢查並關閉 alert（備援機制）
                    try:
                        await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                        if show_debug_message:
                            print("[KKTIX] Alert dismissed after processing")
                    except:
                        pass  # 沒有 alert 就忽略

                    try:
                        # 檢查是否已跳轉到訂單頁面
                        current_url = await tab.evaluate('window.location.href')
                        if '/registrations/' in current_url and '-' in current_url and '/new' not in current_url:
                            if show_debug_message:
                                print(f"Processing completed, redirected to order page")
                            return True
                    except Exception:
                        pass

                    # 如果還沒跳轉，可能還在處理，返回成功
                    return True
                else:
                    # 正常的按鈕點擊成功
                    if show_debug_message:
                        print(f"KKTIX button click successful: [{button_text}]")

                    # 等待頁面處理並檢查是否跳轉
                    await asyncio.sleep(0.3)  # 給 KKTIX 伺服器時間處理

                    # 主動檢查並關閉 alert（備援機制，避免 CDP event handler 未觸發）
                    try:
                        await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                        if show_debug_message:
                            print("[KKTIX] Alert dismissed after button click")
                    except:
                        pass  # 沒有 alert 就忽略

                    try:
                        # 檢查是否已跳轉到訂單頁面
                        current_url = await tab.evaluate('window.location.href')
                        if '/registrations/' in current_url and '-' in current_url and '/new' not in current_url:
                            if show_debug_message:
                                print(f"Button click completed, redirected to order page")
                            return True
                    except Exception:
                        pass

                    # 如果沒有跳轉，等待原有時間並返回成功
                    await asyncio.sleep(0.2)
                    return True
            else:
                error_msg = result.get('error', 'Unknown error') if result else 'No result'
                button_text = result.get('buttonText', '') if result else ''
                if show_debug_message:
                    print(f"KKTIX button click failed: {error_msg} [{button_text}]")

                # 如果是按鈕被禁用或處理中，檢查是否已跳轉
                if 'disabled' in error_msg.lower() or 'processing' in error_msg.lower():
                    try:
                        current_url = await tab.evaluate('window.location.href')
                        if '/registrations/' in current_url and '-' in current_url and '/new' not in current_url:
                            if show_debug_message:
                                print(f"System processing but already redirected to order page, considered successful")
                            return True
                    except Exception:
                        pass

                    # 如果是處理中狀態，等待較長時間再重試
                    if 'processing' in error_msg.lower():
                        await asyncio.sleep(1.0)

                    # 繼續重試
                    continue

        except Exception as exc:
            if show_debug_message:
                print(f"KKTIX 按鈕點擊例外 (重試 {retry_count + 1}/3): {exc}")

    # 所有重試都失敗
    if show_debug_message:
        print("KKTIX button click finally failed after 3 retries")
    return False


async def nodriver_kktix_check_ticket_page_status(tab, show_debug_message=False):
    """
    Check KKTIX ticket page status
    Improved: Distinguish "all not yet open" vs "partially not yet open", with multi-language support

    Improvements:
    - Check each ticket unit status instead of entire page HTML
    - Only reload if "all tickets sold out" or "all tickets not yet open"
    - Multi-language support: Traditional Chinese, English, Japanese

    Returns:
        bool: True means need to reload page (all tickets sold out or not yet open)
    """
    is_need_refresh = False

    try:
        page_state_raw = await tab.evaluate('''
            () => {
                const ticketArea = document.querySelector('#registrationsNewApp') || document.body;

                // Get all ticket units
                const ticketUnits = Array.from(ticketArea.querySelectorAll('.ticket-unit'));

                if (ticketUnits.length === 0) {
                    return { soldOut: false, notYetOpen: false, allNotYetOpen: false, allSoldOut: false };
                }

                // Multi-language "not yet open" keywords
                const notYetOpenKeywords = [
                    '尚未開賣', '未開賣', '尚未開始', '即將開賣',
                    'Not Started', 'not started', 'coming soon', 'Coming Soon',
                    'まだ発売'
                ];

                // Multi-language "sold out" keywords
                const soldOutKeywords = [
                    '售完', '已售完', 'Sold Out', 'sold out', '完売',
                    '暫無票'
                ];

                // Check each ticket status
                let notYetOpenCount = 0;
                let soldOutCount = 0;
                let availableCount = 0;

                ticketUnits.forEach(unit => {
                    const quantitySpan = unit.querySelector('.ticket-quantity');
                    if (quantitySpan) {
                        const text = quantitySpan.textContent.trim();

                        // Check if "not yet open"
                        if (notYetOpenKeywords.some(kw => text.includes(kw))) {
                            notYetOpenCount++;
                        }
                        // Check if "sold out"
                        else if (soldOutKeywords.some(kw => text.includes(kw))) {
                            soldOutCount++;
                        }
                        // Other status treated as available
                        else {
                            availableCount++;
                        }
                    } else {
                        // No quantity span, check if has input (might be purchasable ticket)
                        const hasInput = unit.querySelector('input[type="text"], input[type="number"]');
                        if (hasInput) {
                            availableCount++;
                        }
                    }
                });

                // Determine if need to reload
                const totalTickets = ticketUnits.length;
                const allNotYetOpen = notYetOpenCount === totalTickets && totalTickets > 0;
                const allSoldOut = soldOutCount === totalTickets && totalTickets > 0;
                const hasNotYetOpen = notYetOpenCount > 0;
                const hasSoldOut = soldOutCount > 0;

                return {
                    soldOut: hasSoldOut,
                    allSoldOut: allSoldOut,
                    notYetOpen: hasNotYetOpen,
                    allNotYetOpen: allNotYetOpen,
                    availableCount: availableCount,
                    stats: {
                        total: totalTickets,
                        notYetOpen: notYetOpenCount,
                        soldOut: soldOutCount,
                        available: availableCount
                    }
                };
            }
        ''')

        # Use unified result parsing function
        page_state = util.parse_nodriver_result(page_state_raw)

        # Only reload if "all tickets not yet open" or "all tickets sold out"
        if page_state:
            if page_state.get('allNotYetOpen') or page_state.get('allSoldOut'):
                is_need_refresh = True
                if show_debug_message:
                    status = "All Sold Out" if page_state.get('allSoldOut') else "All Not Yet Open"
                    stats = page_state.get('stats', {})
                    print(f"[KKTIX STATUS] {status}, will reload page")
                    print(f"  Ticket stats: total={stats.get('total')}, notYetOpen={stats.get('notYetOpen')}, soldOut={stats.get('soldOut')}, available={stats.get('available')}")
            elif show_debug_message and (page_state.get('notYetOpen') or page_state.get('soldOut')):
                stats = page_state.get('stats', {})
                print(f"[KKTIX STATUS] Partial tickets not yet open/sold out, continue matching")
                print(f"  Ticket stats: total={stats.get('total')}, notYetOpen={stats.get('notYetOpen')}, soldOut={stats.get('soldOut')}, available={stats.get('available')}")

    except Exception as exc:
        if show_debug_message:
            print(f"Check page status failed: {exc}")

    return is_need_refresh

async def nodriver_kktix_reg_new_main(tab, config_dict, fail_list, played_sound_ticket):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return fail_list, played_sound_ticket

    show_debug_message = util.get_debug_mode(config_dict)

    # 增加執行計數器，防止無限迴圈
    global kktix_dict
    if 'kktix_dict' in globals():
        kktix_dict["reg_execution_count"] = kktix_dict.get("reg_execution_count", 0) + 1
        if show_debug_message:
            print(f"[KKTIX REG] Execution count: {kktix_dict['reg_execution_count']}")

    # T010: Check main switch (defensive programming)
    if not config_dict["area_auto_select"]["enable"]:
        if show_debug_message:
            print("[KKTIX AREA SELECT] Main switch is disabled, skipping area selection")
        return fail_list, played_sound_ticket

    # read config.
    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get('area_auto_fallback', False)  # T021: Safe access for new field (default: strict mode)

    # part 1: check div.
    registrationsNewApp_div = None
    try:
        registrationsNewApp_div = await tab.query_selector('#registrationsNewApp')
    except Exception as exc:
        pass
        #print("find input fail:", exc)

    # part 2: assign ticket number
    is_ticket_number_assigned = False
    if not registrationsNewApp_div is None:
        is_dom_ready = True

        # 檢查頁面狀態，如果偵測到售罄或未開賣，設定重新載入標記
        is_need_refresh = await nodriver_kktix_check_ticket_page_status(tab, show_debug_message)

        if len(area_keyword) > 0:
            area_keyword_array = []
            try:
                area_keyword_array = json.loads("["+ area_keyword +"]")
            except Exception as exc:
                area_keyword_array = []

            # default refresh
            is_need_refresh_final = True

            for area_keyword_item in area_keyword_array:
                is_need_refresh_tmp = False
                is_dom_ready, is_ticket_number_assigned, is_need_refresh_tmp = await nodriver_kktix_assign_ticket_number(tab, config_dict, area_keyword_item)

                if not is_dom_ready:
                    # page redirecting.
                    break

                # one of keywords not need to refresh, final is not refresh.
                if not is_need_refresh_tmp:
                    is_need_refresh_final = False

                if is_ticket_number_assigned:
                    break
                else:
                    if show_debug_message:
                        print("is_need_refresh for keyword:", area_keyword_item)

            # T022-T024: NEW - Conditional fallback based on area_auto_fallback switch
            if not is_ticket_number_assigned:
                # All keyword groups failed
                if is_need_refresh_final:
                    if area_auto_fallback:
                        # T022: Fallback enabled - use auto_select_mode without keyword
                        if show_debug_message:
                            print(f"[KKTIX AREA FALLBACK] area_auto_fallback=true, triggering auto fallback")
                            print(f"[KKTIX AREA FALLBACK] Selecting available ticket based on area_select_order='{auto_select_mode}'")
                        is_dom_ready, is_ticket_number_assigned, is_need_refresh = await nodriver_kktix_assign_ticket_number(tab, config_dict, "")
                    else:
                        # T023: Fallback disabled - strict mode (no selection, but still reload)
                        if show_debug_message:
                            print(f"[KKTIX AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
                            print(f"[KKTIX AREA SELECT] No area selected, will reload page and retry")
                        # Don't return - let reload logic execute below
                        # is_ticket_number_assigned remains False (no selection made)
                        # Continue to line 2261 where is_need_refresh check happens
                else:
                    # T024: is_need_refresh_final=False but no ticket assigned (all options sold out or excluded)
                    if show_debug_message:
                        print(f"[KKTIX AREA FALLBACK] No available options after exclusion")
                        print(f"[KKTIX AREA SELECT] Will reload page and retry")

                # If fallback still failed (or was attempted), then refresh
                if not is_ticket_number_assigned:
                    is_need_refresh = True  # Always reload when no ticket assigned
        else:
            # empty keyword, match all.
            is_dom_ready, is_ticket_number_assigned, is_need_refresh = await nodriver_kktix_assign_ticket_number(tab, config_dict, "")

        if is_dom_ready:
            # part 3: captcha
            if is_ticket_number_assigned:
                # 票數分配後檢查暫停
                if await check_and_handle_pause(config_dict):
                    return fail_list, played_sound_ticket

                # 填寫會員序號（如果有設定）
                await nodriver_kktix_order_member_code(tab, config_dict)

                # 會員序號填寫後檢查暫停
                if await check_and_handle_pause(config_dict):
                    return fail_list, played_sound_ticket

                if not played_sound_ticket:
                    if config_dict["advanced"]["play_sound"]["ticket"]:
                        play_sound_while_ordering(config_dict)
                played_sound_ticket = True

                # 收集除錯資訊（僅在 debug 模式下）
                if show_debug_message:
                    debug_state = await debug_kktix_page_state(tab, show_debug_message)

                # whole event question.
                fail_list, is_question_popup, button_clicked_in_captcha = await nodriver_kktix_reg_captcha(tab, config_dict, fail_list, registrationsNewApp_div)

                # 驗證碼處理後檢查暫停
                if await check_and_handle_pause(config_dict):
                    return fail_list, played_sound_ticket

                # single option question
                if not is_question_popup:
                    # Check and dismiss guest modal again (in case it appears after captcha)
                    # This ensures modal doesn't block the next button
                    await nodriver_kktix_check_guest_modal(tab, config_dict)

                    # no captcha text popup, goto next page.
                    control_text = await nodriver_get_text_by_selector(tab, 'div > div.code-input > div.control-group > label.control-label', 'innerText')
                    if show_debug_message:
                        print("control_text:", control_text)

                    # 防止無限迴圈：當執行超過 2 次且欄位已填寫時，強制清空 control_text
                    if 'kktix_dict' in globals() and kktix_dict.get("reg_execution_count", 0) > 2:
                        if len(control_text) > 0:
                            # 檢查票券數量和序號是否已填寫
                            try:
                                all_fields_filled = await tab.evaluate('''
                                    () => {
                                        // 檢查票券數量
                                        const ticketInputs = document.querySelectorAll('input[name^="tickets"]');
                                        let hasTicket = false;
                                        for (let input of ticketInputs) {
                                            const val = parseInt(input.value);
                                            if (!isNaN(val) && val > 0) {
                                                hasTicket = true;
                                                break;
                                            }
                                        }
                                        if (!hasTicket) return false;

                                        // 檢查優惠序號（如果有的話）
                                        const memberCodeInputs = document.querySelectorAll('input.member-code');
                                        if (memberCodeInputs.length > 0) {
                                            for (let input of memberCodeInputs) {
                                                if (!input.value || input.value.trim() === '') {
                                                    return false;
                                                }
                                            }
                                        }

                                        return true;
                                    }
                                ''')
                                if all_fields_filled:
                                    if show_debug_message:
                                        print(f"[KKTIX FORCE CLEAR] Execution count {kktix_dict['reg_execution_count']}, all fields filled, clearing control_text to break loop")
                                    control_text = ""
                            except Exception as exc:
                                if show_debug_message:
                                    print(f"[KKTIX FORCE CLEAR] Check failed: {exc}")

                    if len(control_text) > 0:
                        input_text_css = 'div > div.code-input > div.control-group > div.controls > label[ng-if] > input[type="text"]'
                        input_text_element = None
                        try:
                            input_text_element = await tab.query_selector(input_text_css)
                        except Exception as exc:
                            #print(exc)
                            pass
                        if input_text_element is None:
                            # 嘗試多種選擇器來找到資格 radio
                            radio_selectors = [
                                'input[type="radio"][ng-model="ticketModel.use_qualification_id"]',  # 最精確
                                'div.code-input input[type="radio"]',  # 次要選擇
                                'div > div.code-input > div.control-group > div.controls > label[ng-if] > input[type="radio"]'  # 原始選擇器
                            ]
                            radio_element = None
                            for radio_css in radio_selectors:
                                try:
                                    radio_element = await tab.query_selector(radio_css)
                                    if radio_element:
                                        if show_debug_message:
                                            print(f"[KKTIX RADIO] Found radio with selector: {radio_css}")
                                        break
                                except Exception:
                                    pass

                            try:
                                pass  # 保持原有的 try block 結構
                                if radio_element:
                                    print("found radio")
                                    joined_button_css = 'div > div.code-input > div.control-group > div.controls > label[ng-if] > span[ng-if] > a[ng-href="#"]'
                                    joined_element = await tab.query_selector(joined_button_css)
                                    if joined_element:
                                        control_text = ""
                                        print("member joined")
                                    else:
                                        # 沒有 "已加入" 標記，需要勾選 radio
                                        try:
                                            # 檢查 radio 是否被禁用
                                            is_disabled = await radio_element.get_attribute('disabled')
                                            if not is_disabled:
                                                if show_debug_message:
                                                    print("[KKTIX RADIO] Clicking radio qualification option")
                                                await radio_element.click()
                                                await tab.sleep(0.3)  # 短暫等待 AngularJS 更新
                                        except Exception as click_exc:
                                            if show_debug_message:
                                                print(f"[KKTIX RADIO ERROR] {click_exc}")
                            except Exception as exc:
                                print(exc)
                                pass

                            # 如果既沒有輸入框也沒有 radio，清空 control_text 以便點擊按鈕
                            # 這種情況下 label 可能只是購票資格說明而非實際輸入欄位
                            if radio_element is None:
                                if show_debug_message:
                                    print(f"[KKTIX] Found label '{control_text}' but no input/radio, proceeding to click button")
                                control_text = ""
                            else:
                                # 有 radio 元素：檢查所有必填欄位是否已填寫
                                try:
                                    all_inputs_filled_result = await tab.evaluate('''
                                        () => {
                                            // 策略 1: 使用 ng-model 檢查票券數量（KKTIX 使用 AngularJS）
                                            const ngModelInputs = document.querySelectorAll('input[ng-model="ticketModel.quantity"]');
                                            let hasTicketSelected = false;
                                            for (let input of ngModelInputs) {
                                                if (parseInt(input.value) > 0) {
                                                    hasTicketSelected = true;
                                                    break;
                                                }
                                            }

                                            // 策略 2: 檢查 name 屬性開頭為 tickets 的輸入框
                                            if (!hasTicketSelected) {
                                                const ticketInputs = document.querySelectorAll('input[name^="tickets"]');
                                                for (let input of ticketInputs) {
                                                    const value = input.value.trim();
                                                    if (!input.disabled && value !== '' && value !== '0') {
                                                        hasTicketSelected = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            // 如果沒有選擇票券，返回 false
                                            if (!hasTicketSelected) return false;

                                            // 檢查會員序號欄位
                                            const memberCodeInputs = document.querySelectorAll('input.member-code');
                                            if (memberCodeInputs.length === 0) return true;  // 沒有會員序號欄位 = 已完成

                                            for (let input of memberCodeInputs) {
                                                if (!input.disabled && (!input.value || input.value.trim() === '')) {
                                                    return false;  // 有未填寫的會員序號欄位
                                                }
                                            }

                                            // 不檢查 Radio 勾選狀態
                                            // 因為「本票券需要符合以下任一資格才可以購買」只是說明文字
                                            // 不是必填欄位，票券和序號完成後就應該點擊下一步

                                            return true;  // 所有欄位都已填寫
                                        }
                                    ''')
                                    all_inputs_filled = util.parse_nodriver_result(all_inputs_filled_result)

                                    if all_inputs_filled:
                                        if show_debug_message:
                                            print(f"[KKTIX] All required fields filled (tickets + member code), clearing control_text to proceed")
                                        control_text = ""
                                    else:
                                        if show_debug_message:
                                            print(f"[KKTIX] Some required fields not filled yet, keeping control_text")
                                except Exception as exc:
                                    if show_debug_message:
                                        print(f"[KKTIX] Input fields check failed: {exc}")

                    if len(control_text) == 0:
                        # 檢查是否在驗證碼處理時已經點擊過按鈕
                        if button_clicked_in_captcha:
                            if show_debug_message:
                                print("Button already clicked during captcha processing, skipping duplicate click")
                        else:
                            # 檢查是否已經跳轉到成功頁面，避免重複點擊
                            try:
                                current_url = await tab.evaluate('window.location.href')
                                if '/registrations/' in current_url and '-' in current_url and '/new' not in current_url:
                                    if show_debug_message:
                                        print("Already redirected to order page, skipping button click")
                                else:
                                    click_ret = await nodriver_kktix_press_next_button(tab, config_dict)
                            except Exception as exc:
                                # 如果檢查失敗，還是嘗試點擊
                                click_ret = await nodriver_kktix_press_next_button(tab, config_dict)
                    else:
                        # input by maxbox plus extension.
                        is_fill_at_webdriver = False

                        if not config_dict["browser"] in CONST_CHROME_FAMILY:
                            is_fill_at_webdriver = True
                        else:
                            if not config_dict["advanced"]["chrome_extension"]:
                                is_fill_at_webdriver = True

                        # TODO: not implement in extension, so force to fill in webdriver.
                        is_fill_at_webdriver = True
                        if is_fill_at_webdriver:
                            #TODO:
                            #set_kktix_control_label_text(driver, config_dict)
                            pass
            else:
                # is_ticket_number_assigned is False
                # 檢查票券是否已經在上一次填寫完成
                if not is_need_refresh:
                    # 沒有需要重新載入，可能是票券已選擇但 matched_blocks 為空
                    # 檢查是否所有必填欄位都已填寫
                    try:
                        all_fields_filled_result = await tab.evaluate('''
                            () => {
                                // 檢查票券數量輸入框
                                const ticketInputs = document.querySelectorAll('input[name^="tickets"]');
                                let hasTicketSelected = false;
                                for (let input of ticketInputs) {
                                    const value = input.value.trim();
                                    if (!input.disabled && value !== '' && value !== '0') {
                                        hasTicketSelected = true;
                                        break;
                                    }
                                }

                                if (!hasTicketSelected) return false;

                                // 檢查會員序號欄位（如果有的話）
                                const memberCodeInputs = document.querySelectorAll('input.member-code');
                                for (let input of memberCodeInputs) {
                                    if (!input.disabled && (!input.value || input.value.trim() === '')) {
                                        return false;
                                    }
                                }

                                return true;
                            }
                        ''')
                        all_fields_filled = util.parse_nodriver_result(all_fields_filled_result)

                        if all_fields_filled:
                            if show_debug_message:
                                print("[KKTIX] Tickets already filled but not assigned this round, attempting to click next button")

                            # 檢查是否已經跳轉到成功頁面
                            try:
                                current_url = await tab.evaluate('window.location.href')
                                if '/registrations/' in current_url and '-' in current_url and '/new' not in current_url:
                                    if show_debug_message:
                                        print("[KKTIX] Already on order page, skipping button click")
                                else:
                                    # 嘗試點擊下一步按鈕
                                    if config_dict["kktix"]["auto_press_next_step_button"]:
                                        await nodriver_kktix_press_next_button(tab, config_dict)
                            except Exception as exc:
                                if show_debug_message:
                                    print(f"[KKTIX] Button click attempt failed: {exc}")
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[KKTIX] Filled fields check failed: {exc}")

                if is_need_refresh:
                    # reset to play sound when ticket avaiable.
                    played_sound_ticket = False

                    try:
                        print("no match any price, start to refresh page...")
                        await tab.reload()
                    except Exception as exc:
                        #print("refresh fail")
                        pass

                    if config_dict["advanced"]["auto_reload_page_interval"] > 0:
                        await asyncio.sleep(config_dict["advanced"]["auto_reload_page_interval"])

    return fail_list, played_sound_ticket

def check_kktix_got_ticket(url, config_dict, show_debug_message=False):
    """檢查是否已成功取得 KKTIX 票券

    Args:
        url: 當前頁面 URL
        config_dict: 設定字典
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: True 表示已成功取得票券
    """
    is_kktix_got_ticket = False

    if '/events/' in url and '/registrations/' in url and "-" in url:
        if not '/registrations/new' in url:
            if not 'https://kktix.com/users/sign_in?' in url:
                is_kktix_got_ticket = True
                if show_debug_message:
                    print(f"[KKTIX] Success page detected: {url}")

    if is_kktix_got_ticket:
        if '/events/' in config_dict["homepage"] and '/registrations/' in config_dict["homepage"] and "-" in config_dict["homepage"]:
            if len(url.split('/')) >= 7:
                if len(config_dict["homepage"].split('/')) >= 7:
                    if url.split('/')[4] == config_dict["homepage"].split('/')[4]:
                        # 保留訊息輸出，但不改變返回值
                        # 重複動作保護已由 success_actions_done 標記處理
                        if show_debug_message:
                            print("重複進入相同活動的訂單頁面，跳過處理")

    return is_kktix_got_ticket

async def nodriver_kktix_main(tab, url, config_dict):
    global kktix_dict
    show_debug_message = util.get_debug_mode(config_dict)

    if not 'kktix_dict' in globals():
        kktix_dict = {}
        kktix_dict["fail_list"]=[]
        kktix_dict["start_time"]=None
        kktix_dict["done_time"]=None
        kktix_dict["elapsed_time"]=None
        kktix_dict["is_popup_checkout"] = False
        kktix_dict["played_sound_ticket"] = False
        kktix_dict["played_sound_order"] = False
        kktix_dict["got_ticket_detected"] = False
        kktix_dict["success_actions_done"] = False
        kktix_dict["reg_execution_count"] = 0
        kktix_dict["alert_handler_registered"] = False
        kktix_dict["guest_modal_checked"] = False

    # Global alert handler - auto-dismiss KKTIX sold-out alerts
    async def handle_kktix_alert(event):
        if show_debug_message:
            print(f"[KKTIX ALERT] Alert detected: '{event.message}'")

        # Dismiss the alert - try multiple times with small delays
        for attempt in range(3):
            try:
                await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                if show_debug_message:
                    print(f"[KKTIX ALERT] Alert dismissed (attempt {attempt + 1})")
                break
            except Exception as dismiss_exc:
                error_msg = str(dismiss_exc)
                # CDP -32602 means no dialog is showing (already dismissed by another handler or user)
                if "No dialog is showing" in error_msg or "-32602" in error_msg:
                    if show_debug_message:
                        print("[KKTIX ALERT] Dialog already dismissed")
                    break  # No need to retry
                if attempt < 2:
                    await asyncio.sleep(0.1)
                else:
                    if show_debug_message:
                        print(f"[KKTIX ALERT] Failed to dismiss alert: {dismiss_exc}")

    # Register global alert handler (only once per session)
    if not kktix_dict.get("alert_handler_registered", False):
        try:
            tab.add_handler(cdp.page.JavascriptDialogOpening, handle_kktix_alert)
            kktix_dict["alert_handler_registered"] = True
            if show_debug_message:
                print("[KKTIX ALERT] Global alert handler registered")
        except Exception as handler_exc:
            if show_debug_message:
                print(f"[KKTIX ALERT] Failed to register alert handler: {handler_exc}")

    is_url_contain_sign_in = False
    if '/users/sign_in?' in url:
        # nodriver_kktix_signin already handles smart polling and redirect
        await nodriver_kktix_signin(tab, url, config_dict)

        # Update URL after signin completes
        try:
            url = await tab.evaluate('window.location.href')
            is_url_contain_sign_in = False
        except Exception as exc:
            if show_debug_message:
                print(f"取得跳轉後 URL 失敗: {exc}")

    if not is_url_contain_sign_in:
        if '/registrations/new' in url:
            # Check and dismiss guest modal (立刻成為 KKTIX 會員) before processing
            # This modal appears when user is not logged in
            await nodriver_kktix_check_guest_modal(tab, config_dict)

            kktix_dict["start_time"] = time.time()

            is_dom_ready = False
            try:
                html_body = await tab.get_content()
                #print("html_body:",len(html_body))
                if html_body:
                    if len(html_body) > 10240:
                        if "registrationsNewApp" in html_body:
                            if not "{{'new.i_read_and_agree_to'" in html_body:
                                is_dom_ready = True
            except Exception as exc:
                #print(exc)
                pass

            if not is_dom_ready:
                kktix_dict["fail_list"] = []
                kktix_dict["played_sound_ticket"] = False
            else:
                # 勾選同意條款 - 使用精確的 ID 選擇器
                is_finish_checkbox_click = await nodriver_check_checkbox(tab, '#person_agree_terms:not(:checked)')

                # Check if tickets are already selected (prevent repeated execution)
                is_ticket_already_selected = False
                try:
                    # 改進的檢查：返回簡單布林值，更可靠
                    result = await tab.evaluate('''
                        () => {
                            // 1. 檢查票券數量
                            const ticketInputs = document.querySelectorAll('input[name^="tickets"]');
                            let hasTicket = false;
                            for (let input of ticketInputs) {
                                const val = parseInt(input.value);
                                if (!isNaN(val) && val > 0) {
                                    hasTicket = true;
                                    break;
                                }
                            }

                            // 2. 檢查會員序號（如果設定檔有配置的話）
                            const memberCodeInputs = document.querySelectorAll('input.member-code');
                            let hasMemberCode = memberCodeInputs.length === 0;  // 如果沒有序號欄位，視為已完成
                            for (let input of memberCodeInputs) {
                                if (input.value && input.value.trim() !== '') {
                                    hasMemberCode = true;
                                    break;
                                }
                            }

                            // 3. 檢查同意條款
                            const agreeCheckbox = document.querySelector('#person_agree_terms');
                            const isAgreed = agreeCheckbox ? agreeCheckbox.checked : true;

                            // 只有當票券已填且序號已填（或無需序號）且已同意時，才認為已選取
                            const result = hasTicket && hasMemberCode && isAgreed;

                            // 返回布林值，確保相容性
                            return result;
                        }
                    ''')

                    # 直接使用結果，不依賴 parse_nodriver_result
                    if isinstance(result, bool):
                        is_ticket_already_selected = result
                    else:
                        # 嘗試解析，但更寬容
                        parsed_result = util.parse_nodriver_result(result) if result is not None else None
                        if isinstance(parsed_result, bool):
                            is_ticket_already_selected = parsed_result
                        elif isinstance(parsed_result, dict):
                            is_ticket_already_selected = parsed_result.get('hasTicket', False)
                        else:
                            if show_debug_message:
                                print(f"[KKTIX CHECK WARNING] parse_nodriver_result returned {type(parsed_result).__name__}: {parsed_result}, raw result: {result}")
                            is_ticket_already_selected = False

                except Exception as exc:
                    if show_debug_message:
                        print(f"[KKTIX CHECK ERROR] {exc}")
                    is_ticket_already_selected = False

                # Debug: show ticket selection status
                if show_debug_message:
                    print(f"[KKTIX CHECK] is_ticket_already_selected: {is_ticket_already_selected}")

                # check is able to buy (only if tickets not already selected)
                if config_dict["kktix"]["auto_fill_ticket_number"] and not is_ticket_already_selected:
                    if show_debug_message:
                        print("[KKTIX] Executing ticket selection logic...")
                    kktix_dict["fail_list"], kktix_dict["played_sound_ticket"] = await nodriver_kktix_reg_new_main(tab, config_dict, kktix_dict["fail_list"], kktix_dict["played_sound_ticket"])
                    kktix_dict["done_time"] = time.time()
        else:
            is_event_page = False
            if '/events/' in url:
                # ex: https://xxx.kktix.cc/events/xxx-copy-1
                if len(url.split('/'))<=5:
                    is_event_page = True

            if is_event_page:
                # 檢查是否需要自動重載（Chrome 擴充功能未啟用時）
                # DISABLED: API check causes access log and may be detected as bot behavior
                # if not config_dict["advanced"]["chrome_extension"]:
                #     await nodriver_kktix_reg_auto_reload(tab, config_dict)

                # Try date selection first (multi-session pages)
                is_date_selected = False
                if config_dict["date_auto_select"]["enable"]:
                    is_date_selected = await nodriver_kktix_date_auto_select(tab, config_dict)

                # If date selection didn't happen (single session or failed), use next button
                if not is_date_selected:
                    if config_dict["kktix"]["auto_press_next_step_button"]:
                        # 自動點擊「立即購票」按鈕
                        await nodriver_kktix_events_press_next_button(tab, config_dict)

            # reset answer fail list.
            kktix_dict["fail_list"] = []
            kktix_dict["played_sound_ticket"] = False

    # 檢查是否已經偵測過成功頁面，避免重複偵測
    is_kktix_got_ticket = False
    if not kktix_dict["got_ticket_detected"]:
        is_kktix_got_ticket = check_kktix_got_ticket(url, config_dict, show_debug_message)
        if is_kktix_got_ticket:
            kktix_dict["got_ticket_detected"] = True
    elif kktix_dict["got_ticket_detected"]:
        # 已經偵測過成功頁面，直接設定為 True 但不重複輸出
        is_kktix_got_ticket = True

    is_quit_bot = False
    if is_kktix_got_ticket:
        # 搶票成功，設定結束標記
        is_quit_bot = True

        # 只在第一次偵測成功時執行動作
        if not kktix_dict["success_actions_done"]:
            if not kktix_dict["start_time"] is None:
                if not kktix_dict["done_time"] is None:
                    bot_elapsed_time = kktix_dict["done_time"] - kktix_dict["start_time"]
                    if kktix_dict["elapsed_time"] != bot_elapsed_time:
                        print("[KKTIX] Ticket purchase completed, elapsed time: {:.3f} seconds".format(bot_elapsed_time))
                    kktix_dict["elapsed_time"] = bot_elapsed_time

            if not kktix_dict["played_sound_order"]:
                if config_dict["advanced"]["play_sound"]["order"]:
                    play_sound_while_ordering(config_dict)
                send_discord_notification(config_dict, "order", "KKTIX")

            kktix_dict["played_sound_order"] = True

            if config_dict["advanced"]["headless"]:
                if not kktix_dict["is_popup_checkout"]:
                    kktix_account = config_dict["accounts"]["kktix_account"]
                    kktix_password = config_dict["accounts"]["kktix_password"].strip()

                    print("基本資料(或實名制)網址:", url)
                    if len(kktix_account) > 0:
                        # Mask account information to protect privacy
                        if len(kktix_account) > 5:
                            masked_account = kktix_account[:3] + "***" + kktix_account[-2:]
                        else:
                            masked_account = "***"
                        print("搶票成功, 帳號:", masked_account)

                        script_name = "chrome_tixcraft"
                        if config_dict["webdriver_type"] == CONST_WEBDRIVER_TYPE_NODRIVER:
                            script_name = "nodriver_tixcraft"

                        threading.Thread(target=util.launch_maxbot, args=(script_name,"", url, kktix_account, kktix_password,"","false",)).start()
                        #driver.quit()
                        #sys.exit()

                    is_event_page = False
                    if len(url.split('/'))>=7:
                        is_event_page = True
                    if is_event_page:
                        # 使用改良的訂單確認按鈕功能
                        confirm_clicked = await nodriver_kktix_confirm_order_button(tab, config_dict)

                        if confirm_clicked:
                            domain_name = url.split('/')[2]
                            checkout_url = "https://%s/account/orders" % (domain_name)
                            print("搶票成功, 請前往該帳號訂單查看: %s" % (checkout_url))
                            webbrowser.open_new(checkout_url)

                    kktix_dict["is_popup_checkout"] = True

            # 標記動作已完成，避免重複執行
            kktix_dict["success_actions_done"] = True
    else:
        kktix_dict["is_popup_checkout"] = False
        kktix_dict["played_sound_order"] = False

    return is_quit_bot

async def nodriver_kktix_confirm_order_button(tab, config_dict):
    """
    KKTIX 訂單確認按鈕自動點擊功能
    對應 Chrome 版本的 kktix_confirm_order_button()
    """
    show_debug_message = util.get_debug_mode(config_dict)
    ret = False

    try:
        # 尋找訂單確認按鈕: div.form-actions a.btn-primary
        confirm_button = await tab.query_selector('div.form-actions a.btn-primary')
        if confirm_button:
            # 檢查按鈕是否可點擊
            is_enabled = await tab.evaluate('''
                (button) => {
                    return button && !button.disabled && button.offsetParent !== null;
                }
            ''', confirm_button)

            if is_enabled:
                await confirm_button.click()
                ret = True
                if show_debug_message:
                    print("KKTIX 訂單確認按鈕已點擊")
            elif show_debug_message:
                print("KKTIX 訂單確認按鈕存在但不可點擊")
        elif show_debug_message:
            print("未找到 KKTIX 訂單確認按鈕")

    except Exception as exc:
        if show_debug_message:
            print(f"KKTIX 訂單確認按鈕點擊失敗: {exc}")

    return ret


async def nodriver_tixcraft_home_close_window(tab):
    accept_all_cookies_btn = None
    try:
        accept_all_cookies_btn = await tab.query_selector('#onetrust-accept-btn-handler')
        if accept_all_cookies_btn:
            accept_all_cookies_btn.click()
    except Exception as exc:
        #print(exc)
        pass

async def nodriver_get_text_by_selector(tab, my_css_selector, attribute='innerHTML'):
    div_text = ""
    try:
        div_element = await tab.query_selector(my_css_selector)
        if div_element:
            #js_attr = await div_element.get_js_attributes()
            div_text = await div_element.get_html()
            
            # only this case to remove tags
            if attribute=="innerText":
                div_text = util.remove_html_tags(div_text)
    except Exception as exc:
        print("find verify textbox fail")
        pass

    return div_text

async def nodriver_tixcraft_redirect(tab, url):
    ret = False
    game_name = ""
    url_split = url.split("/")
    if len(url_split) >= 6:
        game_name = url_split[5]
    if len(game_name) > 0:
        if "/activity/detail/%s" % (game_name,) in url:
            entry_url = url.replace("/activity/detail/","/activity/game/")
            print("redirec to new url:", entry_url)
            try:
                await tab.get(entry_url)
                # 等待日期列表出現，確保頁面載入完成
                try:
                    await tab.wait_for('#gameList > table > tbody > tr', timeout=5)
                except:
                    pass  # timeout 沒關係，讓後續邏輯處理
                ret = True
            except Exception as exec1:
                pass
    return ret

async def nodriver_kktix_order_member_code(tab, config_dict):
    """
    KKTIX 會員序號自動填寫功能
    對應 TicketPlus 的 nodriver_ticketplus_order_exclusive_code()

    使用場景：
    - KKTIX 部分活動需要輸入會員序號才能購票
    - 會員序號欄位在選擇票券數量後動態展開
    - 使用 AngularJS 框架（需要特殊事件觸發處理）

    插入位置：nodriver_kktix_reg_new_main() Line 2188 (播放音效之前)

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典

    Returns:
        bool: 是否成功填寫會員序號
    """
    show_debug_message = util.get_debug_mode(config_dict)

    # 檢查暫停狀態
    if await check_and_handle_pause(config_dict):
        return False

    # 讀取會員序號設定（複用 discount_code）
    member_code = config_dict["advanced"].get("discount_code", "").strip()

    # 如果沒有設定會員序號，直接跳過
    if not member_code:
        if show_debug_message:
            print("[KKTIX MEMBER CODE] No member code configured, skipping")
        return False

    if show_debug_message:
        print(f"[KKTIX MEMBER CODE] Attempting to fill member code: {member_code}")

    try:
        # 轉義 JavaScript 字串，避免注入攻擊
        escaped_member_code = member_code.replace("\\", "\\\\").replace("'", "\\'").replace("\n", "\\n").replace("\r", "\\r")

        # 人類化延遲（隨機 100-300ms）
        await tab.sleep(random.uniform(0.1, 0.3))

        # 使用 JavaScript 注入填入會員序號
        result = await tab.evaluate(f'''
            (function() {{
                const memberCode = '{escaped_member_code}';
                let filledCount = 0;

                // 策略 1: 使用 class 選擇器（最直接）
                const memberCodeInputs = document.querySelectorAll('input.member-code');

                for (let input of memberCodeInputs) {{
                    // 檢查輸入框是否為空且未禁用
                    if (!input.value && !input.disabled) {{
                        input.value = memberCode;

                        // 觸發完整事件序列（AngularJS 需要）
                        input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        input.dispatchEvent(new Event('blur', {{ bubbles: true }}));

                        // 確保 Angular 模型更新
                        if (window.angular) {{
                            const scope = window.angular.element(input).scope();
                            if (scope) {{
                                scope.$apply();
                            }}
                        }}

                        filledCount++;
                    }}
                }}

                // 策略 2: 如果策略 1 失敗，使用 ng-model 選擇器
                if (filledCount === 0) {{
                    const ngModelInputs = document.querySelectorAll('input[ng-model*="member_codes"]');
                    for (let input of ngModelInputs) {{
                        if (!input.value && !input.disabled) {{
                            input.value = memberCode;
                            input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                            input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                            input.dispatchEvent(new Event('blur', {{ bubbles: true }}));

                            if (window.angular) {{
                                const scope = window.angular.element(input).scope();
                                if (scope) {{
                                    scope.$apply();
                                }}
                            }}

                            filledCount++;
                        }}
                    }}
                }}

                return {{
                    success: filledCount > 0,
                    filledCount: filledCount
                }};
            }})()
        ''')

        # 使用統一解析函數處理返回值
        result = util.parse_nodriver_result(result)

        if result and result.get('success'):
            filled_count = result.get('filledCount', 0)
            if show_debug_message:
                print(f"[KKTIX MEMBER CODE] Successfully filled {filled_count} member code field(s)")

            # 填寫完成後短暫延遲，確保 Angular 更新完成
            await tab.sleep(0.2)

            # 檢查是否需要點擊下一步按鈕
            # 當會員序號填寫完成後，直接點擊下一步按鈕，避免 control_text 檢查邏輯干擾
            auto_press = config_dict["kktix"].get("auto_press_next_step_button", False)
            if show_debug_message:
                print(f"[KKTIX MEMBER CODE] auto_press_next_step_button: {auto_press}")

            if auto_press:
                # 簡化邏輯：會員序號成功填寫後，假設票券數量和同意條款都已完成
                # 直接嘗試點擊下一步按鈕
                try:
                    if show_debug_message:
                        print("[KKTIX MEMBER CODE] Member code filled successfully, attempting to click next button...")

                    # 點擊下一步按鈕
                    click_ret = await nodriver_kktix_press_next_button(tab, config_dict)
                    if show_debug_message:
                        print(f"[KKTIX MEMBER CODE] Click button result: {click_ret}")
                    if click_ret:
                        if show_debug_message:
                            print("[KKTIX MEMBER CODE] Successfully clicked next button after filling member code")
                    else:
                        if show_debug_message:
                            print("[KKTIX MEMBER CODE] Button click returned False (button may not be enabled yet)")
                except Exception as exc:
                    if show_debug_message:
                        print(f"[KKTIX MEMBER CODE] Failed to click next button: {exc}")

            return True
        else:
            if show_debug_message:
                print("[KKTIX MEMBER CODE] No member code fields found on page")
            return False

    except Exception as e:
        if show_debug_message:
            print(f"[KKTIX MEMBER CODE] Error filling member code: {str(e)}")
        return False

# ============================================
# Ticketmaster.com NoDriver Platform Migration
# ============================================
# Foundation Functions (T004-T007)
#

# Helper: Convert NoDriver RemoteObject to standard Python dict/list
def convert_remote_object(obj, depth=0):
    """
    Convert NoDriver CDP RemoteObject format to standard Python types.

    RemoteObject format:
    {
      "type": "object",
      "value": [["key1", {"type": "string", "value": "val1"}], ...]
    }

    Standard format:
    {"key1": "val1", "key2": 123, ...}
    """
    if not isinstance(obj, dict):
        return obj

    # Check if this is a RemoteObject
    if "type" in obj and "value" in obj:
        obj_type = obj.get("type")
        obj_value = obj.get("value")

        if obj_type == "object" and isinstance(obj_value, list):
            # Convert [[key, {type, value}], ...] to {key: value, ...}
            result = {}
            for item in obj_value:
                if isinstance(item, (list, tuple)) and len(item) >= 2:
                    key = item[0]
                    val_obj = item[1]
                    # Recursively convert the value
                    result[key] = convert_remote_object(val_obj, depth + 1)
            return result

        elif obj_type == "number":
            return obj_value
        elif obj_type == "string":
            return obj_value
        elif obj_type == "boolean":
            return obj_value
        elif obj_type == "array" and isinstance(obj_value, list):
            return [convert_remote_object(item, depth + 1) for item in obj_value]
        else:
            return obj_value

    # Not a RemoteObject, but might contain nested RemoteObjects
    if isinstance(obj, dict):
        return {k: convert_remote_object(v, depth + 1) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_remote_object(item, depth + 1) for item in obj]
    else:
        return obj


# T004: Parse zone_info JSON from #mapSelectArea
async def nodriver_ticketmaster_parse_zone_info(tab, config_dict):
    """
    Parse zone_info JavaScript variable from #mapSelectArea element.
    Returns: zone_info dict or None if parsing fails
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    zone_info = None

    # Try method 1: String extraction from HTML (preferred - avoids RemoteObject issues)
    try:
        mapSelectArea = await tab.query_selector('#mapSelectArea')
        if mapSelectArea:
            mapSelectArea_html = await mapSelectArea.get_attribute('innerHTML')

            tag_start = "var zone ="
            tag_end = "fieldImageType"
            if tag_start in mapSelectArea_html and tag_end in mapSelectArea_html:
                zone_string = mapSelectArea_html.split(tag_start)[1]
                zone_string = zone_string.split(tag_end)[0]
                zone_string = zone_string.strip().rstrip('\n,')

                import json
                zone_info = json.loads(zone_string)
                if show_debug_message:
                    print(f"[TICKETMASTER ZONE] Parsed zone_info via string extraction ({len(zone_info)} zones)")
                    if len(zone_info) > 0:
                        sample_id = list(zone_info.keys())[0]
                        sample = zone_info[sample_id]
                        if isinstance(sample, dict) and "groupName" in sample:
                            print(f"[TICKETMASTER ZONE] Sample zone '{sample_id}' groupName: {sample['groupName']}")
                return zone_info

    except Exception as exc:
        if show_debug_message:
            print(f"[TICKETMASTER ZONE] String extraction failed: {exc}")

    # Try method 2: Direct JavaScript evaluation (fallback)
    try:
        result = await tab.evaluate('''
            (function() {
                // Check if zone variable exists in global scope
                if (typeof zone !== 'undefined') {
                    // IMPORTANT: Use JSON.parse(JSON.stringify()) to serialize RemoteObject to plain JSON
                    // Without this, NoDriver returns CDP RemoteObject format:
                    // {"type": "object", "value": [["key", {"type": "string", "value": "..."}]]}
                    // Instead of standard JSON: {"key": "value"}
                    try {
                        return JSON.parse(JSON.stringify(zone));
                    } catch(e) {
                        console.error('Zone serialization failed:', e);
                        return zone;  // Fallback to RemoteObject if serialization fails
                    }
                }

                // Fallback: Extract from #mapSelectArea innerHTML
                const el = document.querySelector('#mapSelectArea');
                if (!el) return null;

                const html = el.innerHTML;
                const match = html.match(/var zone = ({[\\s\\S]*?});/);
                if (!match) return null;

                try {
                    return JSON.parse(match[1]);
                } catch(e) {
                    console.error('JSON parse failed:', e);
                    return null;
                }
            })();
        ''')

        if result:
            # Convert RemoteObject to standard Python types
            zone_info = convert_remote_object(result)

            if show_debug_message:
                zone_type = "dict" if isinstance(zone_info, dict) else "list"
                print(f"[TICKETMASTER ZONE] Successfully parsed zone_info ({len(zone_info)} zones, type: {zone_type})")
                print(f"[TICKETMASTER ZONE] RemoteObject converted to standard format")

                # Print detailed structure for debugging
                if len(zone_info) > 0:
                    try:
                        # Print sample zone keys (BEFORE json.dumps to avoid serialization issues)
                        if isinstance(zone_info, list):
                            sample = zone_info[0]
                            sample_id = "index_0"

                            # Diagnostic for List format
                            print(f"[TICKETMASTER ZONE] List first item type: {type(sample)}")

                            if isinstance(sample, dict):
                                sample_keys = list(sample.keys())[:10]  # First 10 keys
                                print(f"[TICKETMASTER ZONE] List item keys (first 10): {sample_keys}")

                                # Check for zone_id fields
                                zone_id_field = None
                                for field in ["sectionCode", "id", "zoneId", "areaNo"]:
                                    if field in sample:
                                        zone_id_field = field
                                        print(f"[TICKETMASTER ZONE] Found zone_id field: '{field}' = '{sample.get(field)}'")
                                        break

                                if not zone_id_field:
                                    print(f"[TICKETMASTER ZONE] WARNING: No zone_id field found (sectionCode, id, zoneId, areaNo)")

                            elif isinstance(sample, (list, tuple)):
                                print(f"[TICKETMASTER ZONE] List item is tuple/list with {len(sample)} elements")
                                if len(sample) > 0:
                                    print(f"[TICKETMASTER ZONE] First element type: {type(sample[0])}")
                                    if isinstance(sample[0], str):
                                        print(f"[TICKETMASTER ZONE] First element (zone_id): {sample[0]}")
                                if len(sample) > 1:
                                    print(f"[TICKETMASTER ZONE] Second element type: {type(sample[1])}")
                                    zone_data = sample[1]
                                    if isinstance(zone_data, dict):
                                        # Check if conversion successful
                                        if "groupName" in zone_data:
                                            print(f"[TICKETMASTER ZONE] ✓ groupName found: {zone_data.get('groupName')}")
                                        elif "type" in zone_data and "value" in zone_data:
                                            print(f"[TICKETMASTER ZONE] ✗ Still RemoteObject format (has 'type' and 'value' keys)")
                                            # Try to convert again
                                            zone_data = convert_remote_object(zone_data)
                                            # Update in the list
                                            sample[1] = zone_data
                                            zone_info[0] = sample
                                            if "groupName" in zone_data:
                                                print(f"[TICKETMASTER ZONE] ✓ After re-conversion, groupName found: {zone_data.get('groupName')}")
                                        else:
                                            print(f"[TICKETMASTER ZONE] zone_data keys: {list(zone_data.keys())[:10]}")
                            else:
                                print(f"[TICKETMASTER ZONE] WARNING: Unknown list item format")
                        else:
                            # Dict format
                            sample_id = list(zone_info.keys())[0]
                            sample = zone_info[sample_id]
                            print(f"[TICKETMASTER ZONE] Sample zone_id: {sample_id}")

                        sample_keys = list(sample.keys()) if isinstance(sample, dict) else []
                        if sample_keys:
                            print(f"[TICKETMASTER ZONE] Sample structure keys: {sample_keys[:10]}")  # First 10 keys
                    except Exception as diag_exc:
                        print(f"[TICKETMASTER ZONE] Diagnostic logging failed: {diag_exc}")

    except Exception as exc:
        if show_debug_message:
            print(f"[TICKETMASTER ZONE] JavaScript evaluation failed: {exc}")

    return zone_info


# T005: Get target area from zone_info (Pure function - no DOM access)
def get_ticketmaster_target_area(config_dict, area_keyword_item, zone_info):
    """
    Match areas from zone_info based on keyword.
    Returns: (is_need_refresh, matched_blocks)
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    area_auto_select_mode = config_dict.get("area_auto_select", {}).get("mode", "from top to bottom")

    is_need_refresh = False
    matched_blocks = []

    if not zone_info or len(zone_info) == 0:
        return True, None

    # Normalize zone_info to uniform iteration format
    # Dict format: {"zone_id": {...}} → [("zone_id", {...}), ...]
    # List format (3 types):
    #   Type A: [{"sectionCode": "field_C1_B", ...}, {...}] → extract sectionCode as zone_id
    #   Type B: [["field_C1_B", {...}], ...] → unpack tuple/list
    #   Type C: [(zone_id, {...}), ...] → already in correct format

    if isinstance(zone_info, dict):
        # Dict format: standard case
        zone_items = list(zone_info.items())
    elif isinstance(zone_info, list):
        # List format: need to detect which type
        if len(zone_info) == 0:
            zone_items = []
        else:
            first_item = zone_info[0]

            if isinstance(first_item, dict):
                # Type A: List of dicts - extract zone_id from dict
                zone_items = []
                for z in zone_info:
                    if not isinstance(z, dict):
                        continue
                    zone_id = z.get("sectionCode") or z.get("id") or z.get("zoneId") or z.get("areaNo")
                    zone_items.append((zone_id, z))

            elif isinstance(first_item, (list, tuple)) and len(first_item) >= 2:
                # Type B: List of [id, data] pairs
                zone_items = []
                for item in zone_info:
                    if isinstance(item, (list, tuple)) and len(item) >= 2:
                        zone_id = item[0]
                        zone_data = item[1]
                        # Convert RemoteObject if needed
                        if isinstance(zone_data, dict) and "type" in zone_data and "value" in zone_data:
                            zone_data = convert_remote_object(zone_data)
                        zone_items.append((zone_id, zone_data))

            else:
                # Unknown format - fallback to old logic
                if show_debug_message:
                    print(f"[TICKETMASTER AREA] Unknown zone_info list format, first item type: {type(first_item)}")
                zone_items = [(None, z) for z in zone_info]
    else:
        # Unexpected type
        if show_debug_message:
            print(f"[TICKETMASTER AREA] Unexpected zone_info type: {type(zone_info)}")
        zone_items = []

    for zone_id, zone_data in zone_items:
        # Validate zone_data is dict-like (has .get() method)
        if not hasattr(zone_data, 'get'):
            if show_debug_message:
                print(f"[TICKETMASTER AREA] zone_data is not dict-like: {type(zone_data)}, skipping")
            continue

        # Fallback: extract zone_id if still None
        if zone_id is None:
            zone_id = zone_data.get("sectionCode") or zone_data.get("id") or zone_data.get("zoneId") or zone_data.get("areaNo")

        row_is_enabled = zone_data.get("areaStatus") != "UNAVAILABLE"

        if not row_is_enabled:
            continue

        # Build row text from zone info
        row_text = ""
        group_name = ""
        description = ""
        try:
            group_name = zone_data.get("groupName", "")
            description = zone_data.get("description", "")
            row_text = group_name + " " + description
            if "price" in zone_data and len(zone_data["price"]) > 0:
                row_text += " " + zone_data["price"][0].get("ticketPrice", "")
        except:
            pass

        if show_debug_message:
            # Show human-readable zone info instead of just zone_id
            display_name = f"{group_name} {description}".strip() if group_name or description else zone_id
            print(f"[TICKETMASTER AREA] Processing zone: {zone_id} ({display_name})")

        if not row_text.strip():
            continue

        # Check exclude keywords
        if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
            continue

        # Format and match keywords
        row_text = util.format_keyword_string(row_text)

        is_append_this_row = False
        if area_keyword_item:
            # Must match all keywords (AND logic)
            area_keyword_array = area_keyword_item.split(' ')

            # Word boundary matching function
            import re
            def word_boundary_match(keyword, text):
                """
                Match keyword with word boundary awareness.
                - Single char keywords (like 'I') require word boundaries
                - Multi-char keywords use substring match for flexibility
                """
                formatted_kw = util.format_keyword_string(keyword)
                if len(formatted_kw) <= 2:
                    # Short keywords need word boundary to avoid false positives
                    # e.g., 'I' should not match 'CIRCLE'
                    pattern = r'\b' + re.escape(formatted_kw) + r'\b'
                    return bool(re.search(pattern, text, re.IGNORECASE))
                else:
                    # Longer keywords use substring match
                    return formatted_kw in text

            # Detailed AND logic matching with PASS/FAIL logs
            if show_debug_message:
                keyword_results = []
                for kw in area_keyword_array:
                    match_result = word_boundary_match(kw, row_text)
                    status = "PASS" if match_result else "FAIL"
                    keyword_results.append(f"'{kw}':{status}")

                all_matched = all(
                    word_boundary_match(kw, row_text)
                    for kw in area_keyword_array
                )
                overall_status = "MATCHED" if all_matched else "REJECTED"
                print(f"[TICKETMASTER AREA] AND Match: {zone_id} [{', '.join(keyword_results)}] -> {overall_status}")

            is_append_this_row = all(
                word_boundary_match(kw, row_text)
                for kw in area_keyword_array
            )
        else:
            # No keyword = match all
            is_append_this_row = True

        if is_append_this_row:
            matched_blocks.append(zone_id)

            if area_auto_select_mode == "from top to bottom":
                # Only need first match
                break

    if len(matched_blocks) == 0:
        matched_blocks = None
        is_need_refresh = True

    if show_debug_message and matched_blocks:
        print(f"[TICKETMASTER AREA] Matched {len(matched_blocks)} areas: {matched_blocks}")

    return is_need_refresh, matched_blocks


# T006: Get ticket price list (wait for page load)
async def nodriver_ticketmaster_get_ticketPriceList(tab, config_dict):
    """
    Wait for ticketPriceList to load and return the table element.
    Uses official NoDriver API (stable, recommended approach).
    Returns: table element or None

    References:
    - Fixed based on famiticket_nodriver_fixes.md (Phase 4: NoDriver Official API Migration)
    - Issue: tab.evaluate() returns None due to JavaScript Context failure
    - Solution: Use tab.wait_for() and tab.query_selector() instead
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    try:
        # Phase 1: Wait for mapContainer (basic page load)
        await tab.wait_for(selector='#mapContainer', timeout=5)

        # Ensure DOM references are synchronized (official recommendation)
        await tab

        if show_debug_message:
            print("[TICKETMASTER TICKET] mapContainer found")

        # Phase 2: Wait for loading to finish (check if loadingmap disappears)
        max_wait = 10  # 10 seconds max
        for i in range(max_wait):
            loading = await tab.query_selector('#loadingmap')
            if not loading:
                if show_debug_message and i > 0:
                    print(f"[TICKETMASTER TICKET] Loading finished after {i}s")
                break
            await tab.sleep(1)
        else:
            # Timeout after 10 seconds
            if show_debug_message:
                print("[TICKETMASTER TICKET] Loading timeout after 10s")

        # Phase 3: Try to find ticketPriceList
        table_element = await tab.query_selector('#ticketPriceList')

        if table_element:
            if show_debug_message:
                print("[TICKETMASTER TICKET] Found ticketPriceList table")
            return table_element
        else:
            if show_debug_message:
                print("[TICKETMASTER TICKET] ticketPriceList not found, will use zone_info")
            return None

    except asyncio.TimeoutError:
        if show_debug_message:
            print("[TICKETMASTER TICKET] Timeout waiting for mapContainer")
        return None
    except Exception as e:
        if show_debug_message:
            print(f"[TICKETMASTER TICKET] Error: {e}")
        return None


# T007: Check checkbox with retry (reusable helper)
async def nodriver_check_checkbox(tab, selector, max_retries=2):
    """
    Check a checkbox element with retry mechanism.
    Returns: True if successfully checked, False otherwise
    """
    for attempt in range(max_retries):
        try:
            # Use pure JavaScript to avoid Element serialization issues
            is_checked = await tab.evaluate(f'''
                (function() {{
                    const checkbox = document.querySelector('{selector}');
                    if (!checkbox) return false;

                    // If already checked, return true
                    if (checkbox.checked) return true;

                    // Try to click
                    try {{
                        checkbox.click();
                        return checkbox.checked;
                    }} catch(e) {{
                        // Fallback: directly set checked property
                        checkbox.checked = true;
                        return checkbox.checked;
                    }}
                }})();
            ''')

            if is_checked:
                return True

            await tab.sleep(0.1)

        except Exception as exc:
            if attempt == max_retries - 1:
                print(f"[CHECKBOX] Failed to check {selector}: {exc}")

    return False


# ============================================
# User Story 1: Date Auto Select (T009)
# ============================================

async def nodriver_ticketmaster_date_auto_select(tab, config_dict):
    """
    Automatically select event date on Ticketmaster artist page.
    Returns: True if date was clicked, False otherwise
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    # Read config
    auto_select_mode = config_dict.get("date_auto_select", {}).get("mode", "from top to bottom")
    date_keyword = config_dict.get("date_auto_select", {}).get("date_keyword", "").strip()
    pass_date_is_sold_out_enable = config_dict.get("tixcraft", {}).get("pass_date_is_sold_out", False)
    auto_reload_coming_soon_page_enable = config_dict.get("kktix", {}).get("auto_reload_coming_soon_page", False)

    sold_out_text_list = ["Sold out", "No tickets available"]
    find_ticket_text_list = ['Find tickets', 'See Tickets']

    # Query date list
    # Ticketmaster.sg uses a table structure: #gameList tbody tr
    # Wait for dynamic content to load (max 5 seconds)
    area_list = None
    max_attempts = 10
    for attempt in range(max_attempts):
        try:
            area_list = await tab.query_selector_all('#gameList tbody tr')
            if area_list and len(area_list) > 0:
                if show_debug_message:
                    print(f"[TICKETMASTER DATE] Found date list after {attempt * 0.5}s")
                break
            await asyncio.sleep(0.5)
        except Exception as exc:
            if show_debug_message and attempt == 0:
                print(f"[TICKETMASTER DATE] Waiting for date list to load... ({exc})")
            await asyncio.sleep(0.5)

    if not area_list:
        if show_debug_message:
            print(f"[TICKETMASTER DATE] Failed to find date list after {max_attempts * 0.5}s")
        return False

    matched_blocks = None
    formated_area_list = []

    if not area_list or len(area_list) == 0:
        if show_debug_message:
            print("[TICKETMASTER DATE] No dates found on page")
        return False

    if show_debug_message:
        print(f"[TICKETMASTER DATE] Found {len(area_list)} date blocks")

    # Filter date blocks
    for row in area_list:
        try:
            row_html = await row.get_html()
            row_text = util.remove_html_tags(row_html)
        except:
            break

        if not row_text:
            continue

        row_is_enabled = False

        # Must contain "See Tickets"
        for text_item in find_ticket_text_list:
            if text_item in row_text:
                row_is_enabled = True
                break

        # Check sold out
        if row_is_enabled and pass_date_is_sold_out_enable:
            for sold_out_item in sold_out_text_list:
                if sold_out_item in row_text:
                    row_is_enabled = False
                    if show_debug_message:
                        print(f"[TICKETMASTER DATE] Skipping sold out event: {row_text[:60]}...")
                    break

        if row_is_enabled:
            formated_area_list.append(row)

    if show_debug_message:
        print(f"[TICKETMASTER DATE] {len(formated_area_list)} available dates after filtering")

    # Get date_auto_fallback setting (default: False = strict mode)
    date_auto_fallback = config_dict.get('date_auto_fallback', False)

    # Build text list for keyword matching
    formated_area_list_text = []
    for row in formated_area_list:
        try:
            row_html = await row.get_html()
            row_text = util.remove_html_tags(row_html)
            formated_area_list_text.append(row_text)
        except:
            formated_area_list_text.append("")

    # T004-T008: Early return pattern (Feature 003)
    if not date_keyword:
        matched_blocks = formated_area_list
        if show_debug_message:
            print(f"[TICKETMASTER DATE KEYWORD] No keyword specified, using all {len(formated_area_list)} dates")
    else:
        # Early return pattern - iterate keywords in priority order
        matched_blocks = []
        target_row_found = False
        keyword_matched_index = -1

        try:
            import json
            import re
            keyword_array = json.loads("[" + date_keyword + "]")

            # T005: Start checking keywords log
            if show_debug_message:
                print(f"[TICKETMASTER DATE KEYWORD] Start checking keywords in order: {keyword_array}")
                print(f"[TICKETMASTER DATE KEYWORD] Total keyword groups: {len(keyword_array)}")
                print(f"[TICKETMASTER DATE KEYWORD] Checking against {len(formated_area_list_text)} available dates...")

            # Iterate keywords in priority order (early return)
            for keyword_index, keyword_item_set in enumerate(keyword_array):
                if show_debug_message:
                    print(f"[TICKETMASTER DATE KEYWORD] Checking keyword #{keyword_index + 1}: {keyword_item_set}")

                # Check all rows for this keyword
                for i, row_text in enumerate(formated_area_list_text):
                    normalized_row_text = re.sub(r'\s+', ' ', row_text)
                    is_match = False

                    if isinstance(keyword_item_set, str):
                        # OR logic: single keyword
                        normalized_keyword = re.sub(r'\s+', ' ', keyword_item_set)
                        is_match = normalized_keyword in normalized_row_text
                    elif isinstance(keyword_item_set, list):
                        # AND logic: all keywords must match
                        normalized_keywords = [re.sub(r'\s+', ' ', kw) for kw in keyword_item_set]
                        match_results = [kw in normalized_row_text for kw in normalized_keywords]
                        is_match = all(match_results)

                        # Detailed AND logic log
                        if show_debug_message:
                            result_strs = [f"'{kw}':{('PASS' if r else 'FAIL')}" for kw, r in zip(keyword_item_set, match_results)]
                            overall = "MATCHED" if is_match else "REJECTED"
                            print(f"[TICKETMASTER DATE KEYWORD] AND Match: [{', '.join(result_strs)}] -> {overall}")

                    if is_match:
                        # T006: Keyword matched - IMMEDIATELY select and stop
                        matched_blocks = [formated_area_list[i]]
                        target_row_found = True
                        keyword_matched_index = keyword_index
                        if show_debug_message:
                            print(f"[TICKETMASTER DATE KEYWORD] Keyword #{keyword_index + 1} matched: '{keyword_item_set}'")
                            print(f"[TICKETMASTER DATE SELECT] Selected date: {row_text[:80]} (keyword match)")
                        break  # Early Return - stop checking other rows

                if target_row_found:
                    # EARLY RETURN: Stop checking further keywords
                    break

            # T007: All keywords failed log
            if not target_row_found:
                if show_debug_message:
                    print(f"[TICKETMASTER DATE KEYWORD] All keywords failed to match")

        except Exception as e:
            if show_debug_message:
                print(f"[TICKETMASTER DATE KEYWORD] Parsing error: {e}")
            matched_blocks = []

    # Match result summary
    if show_debug_message:
        print(f"[TICKETMASTER DATE KEYWORD] ========================================")
        print(f"[TICKETMASTER DATE KEYWORD] Match Summary:")
        print(f"[TICKETMASTER DATE KEYWORD]   Total dates available: {len(formated_area_list) if formated_area_list else 0}")
        print(f"[TICKETMASTER DATE KEYWORD]   Total dates matched: {len(matched_blocks) if matched_blocks else 0}")
        print(f"[TICKETMASTER DATE KEYWORD] ========================================")

    # T018-T020: Conditional fallback based on date_auto_fallback switch
    if matched_blocks is not None and len(matched_blocks) == 0 and date_keyword and formated_area_list is not None and len(formated_area_list) > 0:
        if date_auto_fallback:
            # T018: Fallback enabled - use auto_select_mode
            if show_debug_message:
                print(f"[TICKETMASTER DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                print(f"[TICKETMASTER DATE FALLBACK] Selecting available date based on date_select_order='{auto_select_mode}'")
            matched_blocks = formated_area_list
        else:
            # T019: Fallback disabled - strict mode
            if show_debug_message:
                print(f"[TICKETMASTER DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                print(f"[TICKETMASTER DATE SELECT] No date selected, will reload page and retry")

    # Select target
    if formated_area_list is None or len(formated_area_list) == 0:
        target_area = None
    elif matched_blocks is None or len(matched_blocks) == 0:
        target_area = None
    else:
        target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

    is_date_clicked = False
    if target_area:
        try:
            # Click "See Tickets" link
            link_element = await target_area.query_selector('a')
            if link_element:
                await link_element.click()
                is_date_clicked = True
                if show_debug_message:
                    print("[TICKETMASTER DATE] Clicked 'See Tickets' link")

                # Handle new tab (close if opened)
                await tab.sleep(0.3)
                if len(tab.browser.tabs) > 1:
                    # Close extra tabs
                    for extra_tab in tab.browser.tabs[1:]:
                        await extra_tab.close()
                    await tab.sleep(0.2)

        except Exception as exc:
            if show_debug_message:
                print(f"[TICKETMASTER DATE] Failed to click link: {exc}")

    # Auto reload if no match
    if auto_reload_coming_soon_page_enable and not is_date_clicked and len(formated_area_list) == 0:
        if show_debug_message:
            print("[TICKETMASTER DATE] No dates available, reloading page...")
        try:
            await tab.reload()
            await tab.sleep(0.3)
        except:
            pass

    return is_date_clicked


# ============================================
# User Story 2: Area Auto Select (T012)
# ============================================

async def nodriver_ticketmaster_area_auto_select(tab, config_dict, zone_info):
    """
    Automatically select seat area on Ticketmaster ticket page.
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    area_keyword = config_dict.get("area_auto_select", {}).get("area_keyword", "").strip()

    if show_debug_message:
        print(f"[TICKETMASTER AREA] area_keyword: {area_keyword}")

    is_need_refresh = False
    matched_blocks = None

    # Get area_auto_fallback setting (default: False = strict mode)
    area_auto_fallback = config_dict.get("area_auto_fallback", False)

    if area_keyword:
        area_keyword_array = util.parse_keyword_string_to_array(area_keyword)

        if show_debug_message:
            print(f"[TICKETMASTER AREA] Parsed keyword groups: {area_keyword_array}")

        # Early Return Pattern: Try each keyword group with priority
        for idx, area_keyword_item in enumerate(area_keyword_array):
            if show_debug_message:
                print(f"[TICKETMASTER AREA] Trying keyword group {idx + 1}/{len(area_keyword_array)}: '{area_keyword_item}'")

            is_need_refresh, matched_blocks = get_ticketmaster_target_area(config_dict, area_keyword_item, zone_info)

            if not is_need_refresh and matched_blocks:
                # Found match - Early Return
                if show_debug_message:
                    print(f"[TICKETMASTER AREA] Early Return: keyword group {idx + 1} matched {len(matched_blocks)} area(s)")
                break
            elif show_debug_message:
                print(f"[TICKETMASTER AREA] Keyword group {idx + 1} had no matches, trying next...")

        # Conditional fallback: only match all if area_auto_fallback is enabled
        if is_need_refresh:
            if area_auto_fallback:
                if show_debug_message:
                    print("[TICKETMASTER AREA] Fallback enabled: selecting from all available areas")
                is_need_refresh, matched_blocks = get_ticketmaster_target_area(config_dict, "", zone_info)
            else:
                if show_debug_message:
                    print("[TICKETMASTER AREA] Strict mode: no keyword match, will refresh page")
                # Keep is_need_refresh = True, matched_blocks = None
    else:
        # Empty keyword = match all
        is_need_refresh, matched_blocks = get_ticketmaster_target_area(config_dict, "", zone_info)

    # Select target
    auto_select_mode = config_dict.get("area_auto_select", {}).get("mode", "from top to bottom")
    target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

    if target_area:
        try:
            # Execute JavaScript to select area
            click_area_javascript = f'areaTicket("{target_area}", "map");'
            if show_debug_message:
                print(f"[TICKETMASTER AREA] Executing: {click_area_javascript}")

            await tab.evaluate(click_area_javascript)

            # Wait for AJAX to load ticketPriceList (areaTicket executes AJAX request)
            max_wait = 5  # 5 seconds max
            for i in range(max_wait):
                await tab.sleep(1)

                # Check if ticketPriceList has loaded
                price_list = await tab.query_selector('#ticketPriceList')
                if price_list:
                    if show_debug_message:
                        print(f"[TICKETMASTER AREA] ticketPriceList loaded after {i+1}s")
                    break
            else:
                if show_debug_message:
                    print("[TICKETMASTER AREA] Timeout waiting for ticketPriceList (5s)")

            if show_debug_message:
                print(f"[TICKETMASTER AREA] Selected zone: {target_area}")

        except Exception as exc:
            if show_debug_message:
                print(f"[TICKETMASTER AREA] Failed to execute JavaScript: {exc}")

    # Auto refresh if needed (only when keyword is specified but no match)
    if is_need_refresh:
        # Check if area_keyword is empty (empty = should match all areas)
        area_keyword = config_dict.get("area_auto_select", {}).get("area_keyword", "").strip()

        if area_keyword:
            # Keyword specified but no match → might need to wait for availability
            if show_debug_message:
                print("[TICKETMASTER AREA] No areas matched keyword, reloading page...")
            try:
                await tab.reload()
                if config_dict.get("advanced", {}).get("auto_reload_page_interval", 0) > 0:
                    await tab.sleep(config_dict["advanced"]["auto_reload_page_interval"])
            except:
                pass
        else:
            # No keyword but no areas → likely a data parsing issue, don't reload
            if show_debug_message:
                print("[TICKETMASTER AREA] No areas available (possible zone_info parsing issue)")
            # Let next function (assign_ticket_number) handle it


# ============================================
# User Story 3: Ticket Number Assignment (T015-T016)
# ============================================

async def nodriver_ticketmaster_assign_ticket_number(tab, config_dict):
    """
    Automatically set ticket number on Ticketmaster ticket page.
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    # Get ticket price list
    table_select = await nodriver_ticketmaster_get_ticketPriceList(tab, config_dict)

    if not table_select:
        # Fallback to zone_info parsing
        zone_info = await nodriver_ticketmaster_parse_zone_info(tab, config_dict)
        if zone_info:
            await nodriver_ticketmaster_area_auto_select(tab, config_dict, zone_info)
        return

    # Find select element
    select_element = None
    try:
        select_element = await table_select.query_selector('select')
    except Exception as exc:
        if show_debug_message:
            print(f"[TICKETMASTER TICKET] Failed to find select: {exc}")
        return

    if not select_element:
        if show_debug_message:
            print("[TICKETMASTER TICKET] No select element found")
        return

    # Update element to sync attributes
    try:
        await select_element.update()
    except:
        pass

    # Check if element is enabled (NoDriver uses .attrs dict)
    try:
        select_attrs = select_element.attrs or {}
        is_disabled = 'disabled' in select_attrs
        if is_disabled:
            if show_debug_message:
                print("[TICKETMASTER TICKET] Select element is disabled")
            return
    except Exception as exc:
        if show_debug_message:
            print(f"[TICKETMASTER TICKET] Failed to check disabled status: {exc}")
        # Assume enabled if check fails
        pass

    # Check current value (using .attrs dict)
    select_attrs = select_element.attrs or {}
    selector_id = select_attrs.get('id')
    current_value = None
    if selector_id:
        try:
            current_value = await tab.evaluate(f'''
                (function() {{
                    const selectEl = document.getElementById('{selector_id}');
                    if (selectEl && selectEl.selectedIndex >= 0) {{
                        return selectEl.options[selectEl.selectedIndex].text;
                    }}
                    return null;
                }})();
            ''')
            # Parse NoDriver RemoteObject format if needed
            if isinstance(current_value, list):
                current_value = util.parse_nodriver_result(current_value)
        except:
            pass

    if current_value and current_value != "0" and current_value.isnumeric():
        if show_debug_message:
            print(f"[TICKETMASTER TICKET] Ticket number already set to: {current_value}")
        # Already set, click autoMode button
        try:
            auto_mode_button = await tab.query_selector('#autoMode')
            if auto_mode_button:
                await auto_mode_button.click()
                if show_debug_message:
                    print("[TICKETMASTER TICKET] Clicked #autoMode button")
        except:
            pass
        return

    # Set ticket number
    ticket_number = str(config_dict.get("ticket_number", 1))

    try:
        # Get select element ID for JavaScript manipulation
        select_attrs = select_element.attrs or {}
        selector_id = select_attrs.get('id')
        if not selector_id:
            if show_debug_message:
                print("[TICKETMASTER TICKET] Select element has no id attribute")
            return

        # Use JavaScript to set select value (using element ID instead of passing Element object)
        result = await tab.evaluate(f'''
            (function(elementId, targetText) {{
                const selectEl = document.getElementById(elementId);
                if (!selectEl) {{
                    return {{ success: false, error: "Element not found" }};
                }}
                const options = selectEl.options;
                for (let i = 0; i < options.length; i++) {{
                    if (options[i].text === targetText) {{
                        selectEl.selectedIndex = i;
                        selectEl.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        return {{ success: true, value: options[i].value }};
                    }}
                }}
                return {{ success: false, error: "Option not found" }};
            }})('{selector_id}', '{ticket_number}');
        ''')

        # Parse NoDriver RemoteObject format
        result = util.parse_nodriver_result(result)

        if result and result.get('success'):
            if show_debug_message:
                print(f"[TICKETMASTER TICKET] Set ticket number to: {ticket_number}")

            # Click autoMode button
            await tab.sleep(0.1)
            try:
                auto_mode_button = await tab.query_selector('#autoMode')
                if auto_mode_button:
                    await auto_mode_button.click()
                    if show_debug_message:
                        print("[TICKETMASTER TICKET] Clicked #autoMode button")
            except:
                pass
        else:
            if show_debug_message:
                print(f"[TICKETMASTER TICKET] Failed to set ticket number: {result.get('error')}")

    except Exception as exc:
        if show_debug_message:
            print(f"[TICKETMASTER TICKET] Exception setting ticket number: {exc}")


# ============================================
# User Story 4: Captcha Handling (T019)
# ============================================

async def nodriver_ticketmaster_captcha(tab, config_dict, ocr, captcha_browser):
    """
    Handle captcha on Ticketmaster check-captcha page.
    Returns: True if captcha was handled, False otherwise
    """
    show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    # Check for custom OCR model path
    ocr_path = config_dict.get("ocr_captcha", {}).get("path", "")
    if ocr_path:
        # Support relative paths (relative to app root)
        if not os.path.isabs(ocr_path):
            app_root = util.get_app_root()
            ocr_path = os.path.join(app_root, ocr_path)

        custom_onnx = os.path.join(ocr_path, "custom.onnx")
        custom_charsets = os.path.join(ocr_path, "charsets.json")

        if os.path.exists(custom_onnx) and os.path.exists(custom_charsets):
            # Load custom OCR model
            try:
                ocr = ddddocr.DdddOcr(
                    det=False,
                    ocr=False,
                    import_onnx_path=custom_onnx,
                    charsets_path=custom_charsets,
                    show_ad=False
                )
                print(f"[TICKETMASTER CAPTCHA] Using custom OCR model from: {ocr_path}")
            except Exception as e:
                print(f"[TICKETMASTER CAPTCHA] Failed to load custom model: {e}, using default")
        else:
            # Always warn if custom model path is set but files not found
            print(f"[TICKETMASTER CAPTCHA] Warning: Custom model files not found in: {ocr_path}")
            print(f"[TICKETMASTER CAPTCHA] Expected: {custom_onnx} and {custom_charsets}")

    # Check agree checkbox
    for _ in range(2):
        is_checked = await nodriver_check_checkbox(tab, '#TicketForm_agree')
        if is_checked:
            if show_debug_message:
                print("[TICKETMASTER CAPTCHA] Checked TicketForm_agree")
            break

    # Alert state tracked by event handler
    alert_state = {"detected": False, "message": ""}

    async def on_captcha_alert(event: cdp.page.JavascriptDialogOpening):
        alert_state["detected"] = True
        alert_state["message"] = event.message
        if show_debug_message:
            print(f"[TICKETMASTER CAPTCHA] Alert event: '{event.message[:60]}'")
        # Dismiss the alert immediately to prevent blocking
        try:
            await tab.send(cdp.page.handle_java_script_dialog(accept=True))
            if show_debug_message:
                print("[TICKETMASTER CAPTCHA] Alert auto-dismissed by handler")
        except:
            pass

    # Register handler for this captcha session
    tab.add_handler(cdp.page.JavascriptDialogOpening, on_captcha_alert)

    # Handle captcha
    if not config_dict.get("ocr_captcha", {}).get("enable", False):
        # OCR disabled - manual input
        await nodriver_tixcraft_keyin_captcha_code(tab, answer="", auto_submit=False, config_dict=config_dict)
        return False
    else:
        # OCR enabled - auto recognition
        previous_answer = None
        current_url = tab.target.url
        fail_count = 0
        total_fail_count = 0

        await asyncio.sleep(random.uniform(0.5, 1.0))

        for redo_ocr in range(99):
            try:
                alert_state["detected"] = False  # Reset before each attempt

                away_from_keyboard_enable = config_dict.get("ocr_captcha", {}).get("force_submit", False)
                ocr_captcha_image_source = config_dict.get("ocr_captcha", {}).get("image_source", "canvas")
                domain_name = tab.target.url.split('/')[2]

                # Call tixcraft_auto_ocr for captcha recognition
                is_need_redo_ocr, previous_answer, is_form_submitted = await nodriver_tixcraft_auto_ocr(
                    tab, config_dict, ocr, away_from_keyboard_enable, previous_answer,
                    captcha_browser, ocr_captcha_image_source, domain_name
                )

                if is_form_submitted:
                    if show_debug_message:
                        print("[TICKETMASTER CAPTCHA] Form submitted")

                    # Poll for alert event (max 2 seconds)
                    global tixcraft_dict
                    for wait_i in range(10):
                        await asyncio.sleep(0.2)
                        if alert_state["detected"]:
                            break

                    if show_debug_message:
                        print(f"[TICKETMASTER CAPTCHA] alert_state={alert_state}")

                    error_detected = alert_state["detected"]

                    # If alert was detected (already dismissed by handler), retry OCR
                    if error_detected:
                        if show_debug_message:
                            print("[TICKETMASTER CAPTCHA] Captcha error detected, retrying...")

                        await asyncio.sleep(0.3)
                        await nodriver_tixcraft_reload_captcha(tab, domain_name)
                        previous_answer = None
                        fail_count = 0
                        total_fail_count += 1

                        if total_fail_count >= 15:
                            print("[TICKETMASTER CAPTCHA] Failed 15 times. Manual input required.")
                            await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
                            break

                        await asyncio.sleep(random.uniform(0.5, 1.0))
                        continue

                    # Check for Ticketmaster custom error modal (not native alert)
                    # The modal shows "The verification code that you entered is incorrect"
                    try:
                        # Check for modal overlay or dialog
                        modal_result = await tab.evaluate('''
                            (function() {
                                // Check for visible modal or alert dialog
                                const modals = document.querySelectorAll('.modal, .alert, [role="dialog"], [role="alertdialog"]');
                                for (const modal of modals) {
                                    if (modal.offsetParent !== null || getComputedStyle(modal).display !== 'none') {
                                        return {
                                            found: true,
                                            text: modal.innerText || modal.textContent
                                        };
                                    }
                                }
                                // Also check for any visible buttons that might be confirm/OK
                                const buttons = document.querySelectorAll('button');
                                for (const btn of buttons) {
                                    const text = btn.innerText || btn.textContent;
                                    if ((text.includes('確定') || text.includes('OK') || text.includes('Try again')) &&
                                        btn.offsetParent !== null) {
                                        return {
                                            found: true,
                                            buttonSelector: 'button'
                                        };
                                    }
                                }
                                return { found: false };
                            })();
                        ''')

                        # Handle CDP RemoteObject format (may return as list or dict)
                        modal_content = None
                        if modal_result:
                            if isinstance(modal_result, dict):
                                modal_content = modal_result
                            elif isinstance(modal_result, list) and len(modal_result) > 0:
                                # CDP sometimes returns [{'type': 'object', 'value': {...}}]
                                first_item = modal_result[0]
                                if isinstance(first_item, dict):
                                    if 'value' in first_item:
                                        modal_content = first_item.get('value', {})
                                    else:
                                        modal_content = first_item

                        if modal_content and isinstance(modal_content, dict) and modal_content.get('found'):
                            error_detected = True
                            if show_debug_message:
                                print(f"[TICKETMASTER CAPTCHA] Error modal detected")

                            # Try to click confirm/OK button to dismiss modal
                            dismiss_result = await tab.evaluate('''
                                (function() {
                                    // Find and click confirm button
                                    const buttons = document.querySelectorAll('button');
                                    for (const btn of buttons) {
                                        const text = btn.innerText || btn.textContent;
                                        if (text.includes('確定') || text.includes('OK') || text.includes('Try again')) {
                                            btn.click();
                                            return true;
                                        }
                                    }
                                    // Try to find any primary button
                                    const primaryBtn = document.querySelector('.btn-primary, [type="button"]');
                                    if (primaryBtn) {
                                        primaryBtn.click();
                                        return true;
                                    }
                                    return false;
                                })();
                            ''')

                            # Handle CDP RemoteObject format
                            dismiss_success = False
                            if dismiss_result is True:
                                dismiss_success = True
                            elif isinstance(dismiss_result, list) and len(dismiss_result) > 0:
                                dismiss_success = dismiss_result[0] is True or dismiss_result[0] == True

                            if show_debug_message:
                                if dismiss_success:
                                    print("[TICKETMASTER CAPTCHA] Error modal dismissed, will retry OCR")
                                else:
                                    print("[TICKETMASTER CAPTCHA] Could not dismiss modal")

                            # Reset state for retry
                            await asyncio.sleep(0.3)

                            # Reload captcha for new image
                            await nodriver_tixcraft_reload_captcha(tab, domain_name)
                            previous_answer = None
                            fail_count = 0
                            total_fail_count += 1

                            # Check retry limit
                            if total_fail_count >= 15:
                                print("[TICKETMASTER CAPTCHA] OCR failed 15 times after error modal. Please enter captcha manually.")
                                await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
                                break

                            await asyncio.sleep(random.uniform(0.5, 1.0))
                            continue  # Retry OCR

                    except Exception as modal_exc:
                        if show_debug_message:
                            print(f"[TICKETMASTER CAPTCHA] Error checking modal: {modal_exc}")

                    # No error modal detected, form submitted successfully
                    if not error_detected:
                        break

                if not away_from_keyboard_enable:
                    break

                if not is_need_redo_ocr:
                    break

                # Track failures and handle retry limits
                fail_count += 1
                total_fail_count += 1

                if show_debug_message:
                    print(f"[TICKETMASTER CAPTCHA] Fail count: {fail_count}, Total fails: {total_fail_count}")

                # Check if total failures reached 15, switch to manual input mode
                if total_fail_count >= 15:
                    print("[TICKETMASTER CAPTCHA] OCR failed 15 times. Please enter captcha manually.")
                    await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
                    break

                # Refresh captcha after 3 consecutive failures with same answer
                if fail_count >= 3:
                    if show_debug_message:
                        print("[TICKETMASTER CAPTCHA] 3 consecutive failures, reloading captcha...")
                    await nodriver_tixcraft_reload_captcha(tab, domain_name)
                    fail_count = 0
                    previous_answer = None  # Reset to allow fresh OCR
                    await asyncio.sleep(random.uniform(0.8, 1.2))  # Wait for new captcha to load
                else:
                    # Wait between retries to allow canvas to fully load
                    await asyncio.sleep(random.uniform(0.3, 0.5))

                # Check if URL changed
                new_url = tab.target.url
                if new_url != current_url:
                    if show_debug_message:
                        print("[TICKETMASTER CAPTCHA] URL changed, stopping OCR loop")
                    break

            except Exception as exc:
                if show_debug_message:
                    print(f"[TICKETMASTER CAPTCHA] OCR error: {exc}")
                break

        return True


async def nodriver_ticketmaster_promo(tab, config_dict, fail_list):
    question_selector = '#promoBox'
    return await nodriver_tixcraft_input_check_code(tab, config_dict, fail_list, question_selector)

async def nodriver_tixcraft_verify(tab, config_dict, fail_list):
    question_selector = '.zone-verify'
    return await nodriver_tixcraft_input_check_code(tab, config_dict, fail_list, question_selector)


async def nodriver_fill_verify_form(tab, config_dict, inferred_answer_string, fail_list, input_text_css, next_step_button_css, submit_by_enter, check_input_interval):
    """
    NoDriver version of fill_common_verify_form for TixCraft verification.

    Fills verification form input and submits the answer.

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary
        inferred_answer_string: Answer to fill in
        fail_list: List of failed answers
        input_text_css: CSS selector for input field
        next_step_button_css: CSS selector for submit button (optional)
        submit_by_enter: Whether to submit by pressing Enter
        check_input_interval: Interval to wait when no answer

    Returns:
        tuple[bool, list]: (is_answer_sent, updated fail_list)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_answer_sent = False

    try:
        # Check if input field exists and get current value
        input_info = await tab.evaluate(f'''
            (function() {{
                var input = document.querySelector("{input_text_css}");
                if (input) {{
                    return {{
                        exists: true,
                        value: input.value || ""
                    }};
                }}
                return {{ exists: false, value: "" }};
            }})()
        ''')
        input_info = util.parse_nodriver_result(input_info)

        if not input_info or not input_info.get('exists', False):
            if show_debug_message:
                print("[VERIFY FORM] Input field not found:", input_text_css)
            return is_answer_sent, fail_list

        inputed_value = input_info.get('value', '')

        if show_debug_message:
            print(f"[VERIFY FORM] Current input value: '{inputed_value}'")
            print(f"[VERIFY FORM] Answer to fill: '{inferred_answer_string}'")

        if len(inferred_answer_string) > 0:
            # Fill the answer if different from current value
            if inputed_value != inferred_answer_string:
                # Clear and fill using JavaScript
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector("{input_text_css}");
                        if (input) {{
                            input.value = "";
                            input.value = "{inferred_answer_string}";
                            input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                            input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        }}
                    }})()
                ''')

                if show_debug_message:
                    print(f"[VERIFY FORM] Filled answer: {inferred_answer_string}")

            # Submit the form
            is_button_clicked = False

            if submit_by_enter:
                # Submit by pressing Enter
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector("{input_text_css}");
                        if (input) {{
                            var event = new KeyboardEvent('keydown', {{
                                key: 'Enter',
                                code: 'Enter',
                                keyCode: 13,
                                which: 13,
                                bubbles: true
                            }});
                            input.dispatchEvent(event);

                            // Also try form submit
                            var form = input.closest('form');
                            if (form) {{
                                form.submit();
                            }}
                        }}
                    }})()
                ''')
                is_button_clicked = True
                if show_debug_message:
                    print("[VERIFY FORM] Submitted by Enter key")
            elif len(next_step_button_css) > 0:
                # Click the submit button
                try:
                    btn = await tab.query_selector(next_step_button_css)
                    if btn:
                        await btn.click()
                        is_button_clicked = True
                        if show_debug_message:
                            print(f"[VERIFY FORM] Clicked submit button: {next_step_button_css}")
                except Exception as btn_exc:
                    if show_debug_message:
                        print(f"[VERIFY FORM] Failed to click button: {btn_exc}")

            if is_button_clicked:
                is_answer_sent = True
                fail_list.append(inferred_answer_string)
                if show_debug_message:
                    print(f"[VERIFY FORM] Answer sent, attempt #{len(fail_list)}")

                # Wait and check for alert
                await asyncio.sleep(0.3)
        else:
            # No answer to fill, just focus the input
            if len(inputed_value) == 0:
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector("{input_text_css}");
                        if (input && document.activeElement !== input) {{
                            input.focus();
                        }}
                    }})()
                ''')
                await asyncio.sleep(check_input_interval)
                if show_debug_message:
                    print("[VERIFY FORM] No answer, focused input field")

    except Exception as exc:
        if show_debug_message:
            print(f"[VERIFY FORM] Error: {exc}")

    return is_answer_sent, fail_list


async def nodriver_tixcraft_input_check_code(tab, config_dict, fail_list, question_selector):
    show_debug_message = util.get_debug_mode(config_dict)

    answer_list = []

    question_text = await nodriver_get_text_by_selector(tab, question_selector, 'innerText')
    if len(question_text) > 0:
        write_question_to_file(question_text)

        answer_list = util.get_answer_list_from_user_guess_string(config_dict, CONST_MAXBOT_ANSWER_ONLINE_FILE)
        if len(answer_list)==0:
            if config_dict["advanced"]["auto_guess_options"]:
                # Note: guess_tixcraft_question() doesn't use the driver parameter
                answer_list = util.guess_tixcraft_question(None, question_text)

        inferred_answer_string = ""
        for answer_item in answer_list:
            if not answer_item in fail_list:
                inferred_answer_string = answer_item
                break

        if show_debug_message:
            print("inferred_answer_string:", inferred_answer_string)
            print("answer_list:", answer_list)

        # PS: auto-focus() when empty inferred_answer_string with empty inputed text value.
        input_text_css = "input[name='checkCode']"
        next_step_button_css = "button.btn.btn-primary"
        submit_by_enter = False
        check_input_interval = 0.2
        is_answer_sent, fail_list = await nodriver_fill_verify_form(tab, config_dict, inferred_answer_string, fail_list, input_text_css, next_step_button_css, submit_by_enter, check_input_interval)

    return fail_list

async def nodriver_tixcraft_date_auto_select(tab, url, config_dict, domain_name):
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Issue #188: Check sold out cooldown before proceeding
    global tixcraft_dict
    if 'tixcraft_dict' in globals() and tixcraft_dict.get("sold_out_cooldown_until", 0) > time.time():
        remaining = tixcraft_dict["sold_out_cooldown_until"] - time.time()
        if show_debug_message:
            print(f"[DATE SELECT] Sold out cooldown active, waiting {remaining:.1f}s...")
        await asyncio.sleep(remaining)
        tixcraft_dict["sold_out_cooldown_until"] = 0  # Reset after waiting

    # T003: Check main switch (defensive programming)
    if not config_dict["date_auto_select"]["enable"]:
        if show_debug_message:
            print("[DATE SELECT] Main switch is disabled, skipping date selection")
        return False

    # read config
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get('date_auto_fallback', False)  # T017: Safe access for new field (default: strict mode)
    pass_date_is_sold_out_enable = config_dict["tixcraft"]["pass_date_is_sold_out"]
    auto_reload_coming_soon_page_enable = config_dict["tixcraft"]["auto_reload_coming_soon_page"]

    sold_out_text_list = ["選購一空","已售完","No tickets available","Sold out","空席なし","完売した"]
    find_ticket_text_list = ['立即訂購','Find tickets', 'Start ordering','お申込みへ進む']

    game_name = ""
    if "/activity/game/" in url:
        url_split = url.split("/")
        if len(url_split) >= 6:
            game_name = url_split[5]

    check_game_detail = "/activity/game/%s" % (game_name,) in url

    area_list = None
    if check_game_detail:
        # 智慧等待：等待日期列表出現
        # 注意：從 /activity/detail/ redirect 過來時，redirect 函數已經等待過了
        # 這裡再等待一次是為了處理直接進入 /activity/game/ 頁面的情況
        try:
            await tab.wait_for('#gameList > table > tbody > tr', timeout=3)
        except:
            pass  # timeout 沒關係，繼續嘗試讀取

        try:
            area_list = await tab.query_selector_all('#gameList > table > tbody > tr')
        except:
            pass

    # Language detection for coming soon
    is_coming_soon = False
    coming_soon_conditions = {
        'en-US': [' day(s)', ' hrs.',' min',' sec',' till sale starts!','0',':','/'],
        'zh-TW': ['開賣','剩餘',' 天',' 小時',' 分鐘',' 秒','0',':','/','20'],
        'ja': ['発売開始', ' 日', ' 時間',' 分',' 秒','0',':','/','20']
    }

    html_lang = "en-US"
    try:
        html_body = await tab.evaluate('document.documentElement.outerHTML')
        if html_body and '<head' in html_body:
            html_lang = html_body.split('<head')[0].split('"')[1]
    except:
        pass

    coming_soon_condictions_list = coming_soon_conditions.get(html_lang, coming_soon_conditions['en-US'])

    matched_blocks = None
    formated_area_list = None

    if area_list and len(area_list) > 0:
        # 移除：過度詳細的除錯訊息
        formated_area_list = []
        formated_area_list_text = []
        for row in area_list:
            try:
                row_html = await row.get_html()
                row_text = util.remove_html_tags(row_html)
            except:
                break

            if row_text and not util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                # Check coming soon
                if all(cond in row_text for cond in coming_soon_condictions_list):
                    is_coming_soon = True
                    if show_debug_message:
                        print(f"[DATE SELECT] Detected coming soon countdown")
                    if auto_reload_coming_soon_page_enable:
                        if show_debug_message:
                            print(f"[DATE SELECT] auto_reload_coming_soon_page=true, will reload and retry")
                        break
                    else:
                        # Skip this row (don't add to formated_area_list)
                        continue

                # Check if row has ticket text
                row_is_enabled = any(text in row_text for text in find_ticket_text_list)

                # Check sold out
                if row_is_enabled and pass_date_is_sold_out_enable:
                    for sold_out_item in sold_out_text_list:
                        if sold_out_item in row_text[-(len(sold_out_item)+5):]:
                            row_is_enabled = False
                            # 移除：售完訊息過度詳細
                            break

                if row_is_enabled:
                    formated_area_list.append(row)
                    formated_area_list_text.append(row_text)
                    # 移除：可用場次訊息過度詳細

        # T004-T008: NEW LOGIC - Early return pattern (Feature 003)
        # Keyword priority matching: first match wins and stops immediately
        if not date_keyword:
            matched_blocks = formated_area_list
            if show_debug_message:
                print(f"[DATE KEYWORD] No keyword specified, using all {len(formated_area_list)} dates")
        else:
            # NEW: Early return pattern - iterate keywords in order
            matched_blocks = []
            target_row_found = False
            keyword_matched_index = -1

            try:
                import json
                import re
                keyword_array = json.loads("[" + date_keyword + "]")

                # T005: Start checking keywords log
                if show_debug_message:
                    print(f"[DATE KEYWORD] Start checking keywords in order: {keyword_array}")
                    print(f"[DATE KEYWORD] Total keyword groups: {len(keyword_array)}")
                    print(f"[DATE KEYWORD] Checking against {len(formated_area_list_text)} available dates...")

                # NEW: Iterate keywords in priority order (early return)
                for keyword_index, keyword_item_set in enumerate(keyword_array):
                    if show_debug_message:
                        print(f"[DATE KEYWORD] Checking keyword #{keyword_index + 1}: {keyword_item_set}")

                    # Check all rows for this keyword
                    for i, row_text in enumerate(formated_area_list_text):
                        normalized_row_text = re.sub(r'\s+', ' ', row_text)
                        is_match = False

                        if isinstance(keyword_item_set, str):
                            # OR logic: single keyword
                            normalized_keyword = re.sub(r'\s+', ' ', keyword_item_set)
                            is_match = normalized_keyword in normalized_row_text
                        elif isinstance(keyword_item_set, list):
                            # AND logic: all keywords must match
                            normalized_keywords = [re.sub(r'\s+', ' ', kw) for kw in keyword_item_set]
                            match_results = [kw in normalized_row_text for kw in normalized_keywords]
                            is_match = all(match_results)

                        if is_match:
                            # T006: Keyword matched log - IMMEDIATELY select and stop
                            matched_blocks = [formated_area_list[i]]
                            target_row_found = True
                            keyword_matched_index = keyword_index
                            if show_debug_message:
                                print(f"[DATE KEYWORD] Keyword #{keyword_index + 1} matched: '{keyword_item_set}'")
                                print(f"[DATE SELECT] Selected date: {row_text[:80]} (keyword match)")
                            break

                    if target_row_found:
                        # EARLY RETURN: Stop checking further keywords
                        break

                # T007: All keywords failed log
                if not target_row_found:
                    if show_debug_message:
                        print(f"[DATE KEYWORD] All keywords failed to match")

            except Exception as e:
                if show_debug_message:
                    print(f"[DATE KEYWORD] Parsing error: {e}")
                # On error, use mode selection
                matched_blocks = []

    # T018-T020: NEW - Conditional fallback based on date_auto_fallback switch
    if matched_blocks is not None and len(matched_blocks) == 0 and date_keyword and formated_area_list is not None and len(formated_area_list) > 0:
        if date_auto_fallback:
            # T018: Fallback enabled - use auto_select_mode
            if show_debug_message:
                print(f"[DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                print(f"[DATE FALLBACK] Selecting available date based on date_select_order='{auto_select_mode}'")
            matched_blocks = formated_area_list
        else:
            # T019: Fallback disabled - strict mode (no selection, but still reload)
            if show_debug_message:
                print(f"[DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                print(f"[DATE SELECT] No date selected, will reload page and retry")
            # Don't return - let reload logic execute below
            # matched_blocks remains None (no selection will be made)

    # T020: Handle case when formated_area_list is empty or None (all options excluded or sold out)
    if formated_area_list is None or len(formated_area_list) == 0:
        if show_debug_message:
            print(f"[DATE FALLBACK] No available options after exclusion")
            print(f"[DATE SELECT] Will reload page and retry")
        # Don't return - let reload logic execute at function end
        is_date_clicked = False
        target_area = None  # Skip selection when no options available
    elif matched_blocks is None or len(matched_blocks) == 0:
        # matched_blocks is None when fallback=false and keyword didn't match
        target_area = None
        is_date_clicked = False
    else:
        target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

    if show_debug_message:
        if target_area and matched_blocks:
            # Find which index was selected
            try:
                target_index = matched_blocks.index(target_area) if target_area in matched_blocks else -1
                print(f"[DATE SELECT] Auto-select mode: {auto_select_mode}")
                print(f"[DATE SELECT] Selected target: #{target_index + 1}/{len(matched_blocks)}")
            except:
                print(f"[DATE SELECT] Auto-select mode: {auto_select_mode}")
                print(f"[DATE SELECT] Target selected from {len(matched_blocks)} matched dates")
        elif not matched_blocks or len(matched_blocks) == 0:
            print(f"[DATE SELECT] No target selected (matched_blocks is empty)")

    is_date_clicked = False

    # 移除：內部選擇細節過度詳細

    if target_area:
        # Priority: button with data-href (tixcraft/indievox) > regular link > regular button
        # IMPORTANT: Search within target_area, not the whole page
        click_method_used = None
        try:
            if show_debug_message:
                print("[DATE SELECT] Trying button[data-href] method within target_area...")

            # Method 1: button[data-href] within target_area (tixcraft/indievox specific)
            # 使用 NoDriver Element API 取得 data-href
            button_with_href = await target_area.query_selector('button[data-href]')
            data_href = None
            if button_with_href:
                # 更新元素以確保屬性載入
                await button_with_href.update()
                button_attrs = button_with_href.attrs or {}
                data_href = button_attrs.get('data-href')

                if show_debug_message:
                    if data_href:
                        print(f"[DATE SELECT] button[data-href] found in target_area: {data_href}")
                    else:
                        print("[DATE SELECT] button[data-href] found but no href value")

                if data_href:
                    if show_debug_message:
                        print("[DATE SELECT] Navigating via button[data-href]...")
                    await tab.get(data_href)
                    is_date_clicked = True
                    click_method_used = "button[data-href]"
                    if show_debug_message:
                        print("[DATE SELECT] Successfully navigated via button[data-href]")
            else:
                if show_debug_message:
                    print("[DATE SELECT] No button[data-href] in target_area, will try fallback methods")
        except Exception as e:
            if show_debug_message:
                print(f"[DATE SELECT] button[data-href] method failed: {e}")

        # Method 2: regular link or button click
        if not is_date_clicked:
            try:
                if show_debug_message:
                    print("[DATE SELECT] Trying link <a[href]> method within target_area...")

                # Try link first (ticketmaster, etc)
                link = await target_area.query_selector('a[href]')
                if link:
                    if show_debug_message:
                        print("[DATE SELECT] Link found in target_area, clicking...")
                    await link.click()
                    is_date_clicked = True
                    click_method_used = "link <a[href]>"
                    if show_debug_message:
                        print("[DATE SELECT] Successfully clicked via link")
                else:
                    if show_debug_message:
                        print("[DATE SELECT] No link found, trying regular button within target_area...")

                    # Try regular button
                    button = await target_area.query_selector('button')
                    if button:
                        if show_debug_message:
                            print("[DATE SELECT] Regular button found in target_area, clicking...")
                        await button.click()
                        is_date_clicked = True
                        click_method_used = "regular button"
                        if show_debug_message:
                            print("[DATE SELECT] Successfully clicked via regular button")
                    else:
                        if show_debug_message:
                            print("[DATE SELECT] No clickable element found in target_area")
            except Exception as e:
                if show_debug_message:
                    print(f"[DATE SELECT] Click error: {e}")

        # Final summary
        if show_debug_message:
            if is_date_clicked and click_method_used:
                print(f"[DATE SELECT] ========================================")
                print(f"[DATE SELECT] Date selection completed successfully")
                print(f"[DATE SELECT] Method used: {click_method_used}")
                print(f"[DATE SELECT] ========================================")
            elif not is_date_clicked:
                print(f"[DATE SELECT] ========================================")
                print("[DATE SELECT] All click methods failed")
                print(f"[DATE SELECT] ========================================")

    # Auto refresh if no date was selected (for strict mode or sold out scenarios)
    if not is_date_clicked:
        # Simple wait mode (consistent with TicketPlus/iBon/FamiTicket)
        interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
        if interval > 0:
            if show_debug_message:
                print(f"[DATE SELECT] Waiting {interval}s before reload...")
            await asyncio.sleep(interval)

        if show_debug_message:
            print(f"[DATE SELECT] No date selected, reloading page...")
        try:
            await tab.reload()
        except Exception:
            pass

    return is_date_clicked


async def nodriver_tixcraft_area_auto_select(tab, url, config_dict):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # T010: Check main switch (defensive programming)
    if not config_dict["area_auto_select"]["enable"]:
        if show_debug_message:
            print("[AREA SELECT] Main switch is disabled, skipping area selection")
        return False

    import json

    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get('area_auto_fallback', False)  # T021: Safe access for new field

    try:
        el = await tab.query_selector('.zone')
    except:
        return

    if not el:
        return

    is_need_refresh = False
    matched_blocks = None

    if area_keyword:
        # Parse keywords using JSON to avoid splitting keywords containing commas (e.g., "5,600")
        # Format: "\"keyword1\",\"keyword2\"" → ['keyword1', 'keyword2']
        # Supports OR logic - iterates through keywords until match found
        area_keyword_array = util.parse_keyword_string_to_array(area_keyword)

        # T012: Start checking keywords log
        if show_debug_message:
            print(f"[AREA KEYWORD] Start checking keywords in order: {area_keyword_array}")
            print(f"[AREA KEYWORD] Total keyword groups: {len(area_keyword_array)}")

        # T011: Early return pattern - iterate keywords in priority order
        keyword_matched = False
        for keyword_index, area_keyword_item in enumerate(area_keyword_array):
            if show_debug_message:
                print(f"[AREA KEYWORD] Checking keyword #{keyword_index + 1}: {area_keyword_item}")

            is_need_refresh, matched_blocks = await nodriver_get_tixcraft_target_area(el, config_dict, area_keyword_item)

            if not is_need_refresh:
                # T013: Keyword matched log
                keyword_matched = True
                if show_debug_message:
                    print(f"[AREA KEYWORD] Keyword #{keyword_index + 1} matched: '{area_keyword_item}'")
                break

        # T014: All keywords failed log
        if not keyword_matched and show_debug_message:
            print(f"[AREA KEYWORD] All keywords failed to match")

        # T022-T024: NEW - Conditional fallback based on area_auto_fallback switch
        is_fallback_selection = False  # Track selection type for logging
        if is_need_refresh and matched_blocks is None:
            if area_auto_fallback:
                # T022: Fallback enabled - use auto_select_mode without keyword
                if show_debug_message:
                    print(f"[AREA FALLBACK] area_auto_fallback=true, triggering auto fallback")
                    print(f"[AREA FALLBACK] Selecting available area based on area_select_order='{auto_select_mode}'")
                is_need_refresh, matched_blocks = await nodriver_get_tixcraft_target_area(el, config_dict, "")
                is_fallback_selection = True  # Mark as fallback selection
            else:
                # T023: Fallback disabled - strict mode (no selection, but still reload)
                if show_debug_message:
                    print(f"[AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
                    print(f"[AREA SELECT] No area selected, will reload page and retry")
                # Don't return - let reload logic execute below
                # matched_blocks remains None (no selection will be made)
                # is_need_refresh remains True (will trigger reload)
    else:
        is_need_refresh, matched_blocks = await nodriver_get_tixcraft_target_area(el, config_dict, "")
        # No keyword specified, treat as mode-based selection (similar to fallback)
        if not area_keyword:
            is_fallback_selection = True

    # T024: Handle case when matched_blocks is empty or None (all options excluded or sold out)
    if matched_blocks is None or len(matched_blocks) == 0:
        if show_debug_message:
            print(f"[AREA FALLBACK] No available options after exclusion")
            print(f"[AREA SELECT] Will reload page and retry")
        # Don't return - let reload logic execute below
        is_need_refresh = True  # Ensure reload will happen
        target_area = None  # Skip selection when no options available
    else:
        target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)
    if target_area:
        # T013: Log selected area with selection type
        if show_debug_message:
            try:
                area_text = await target_area.text
                if not area_text:
                    area_text = await target_area.inner_text
                area_text = area_text.strip()[:80] if area_text else "Unknown"
                selection_type = "fallback" if is_fallback_selection else "keyword match"
                print(f"[AREA SELECT] Selected area: {area_text} ({selection_type})")
            except:
                pass  # If text extraction fails, skip logging

        try:
            await target_area.click()
        except:
            try:
                await target_area.evaluate('el => el.click()')
            except:
                pass

    # Auto refresh if needed (simple wait mode, consistent with TicketPlus/iBon/FamiTicket)
    if is_need_refresh:
        interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
        if interval > 0:
            if show_debug_message:
                print(f"[AREA SELECT] Waiting {interval}s before reload...")
            await asyncio.sleep(interval)

        if show_debug_message:
            print(f"[AREA SELECT] Page reloading...")
        try:
            await tab.reload()
        except Exception:
            pass

async def nodriver_get_tixcraft_target_area(el, config_dict, area_keyword_item):
    area_auto_select_mode = config_dict["area_auto_select"]["mode"]
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_need_refresh = False
    matched_blocks = None

    # Display keyword information
    if show_debug_message:
        print(f"[AREA KEYWORD] ========================================")
        if area_keyword_item:
            keyword_parts = area_keyword_item.split(' ')
            print(f"[AREA KEYWORD] Raw input: '{area_keyword_item}'")
            print(f"[AREA KEYWORD] Parsed (AND logic): {keyword_parts}")
            print(f"[AREA KEYWORD] Total sub-keywords: {len(keyword_parts)}")
            print(f"[AREA KEYWORD] Auto-select mode: {area_auto_select_mode}")
        else:
            print(f"[AREA KEYWORD] No keyword specified, matching all areas")
            print(f"[AREA KEYWORD] Auto-select mode: {area_auto_select_mode}")

    if not el:
        if show_debug_message:
            print(f"[AREA KEYWORD] Element is None, cannot select area")
        return True, None

    try:
        area_list = await el.query_selector_all('a')
    except:
        if show_debug_message:
            print(f"[AREA KEYWORD] Failed to query area list")
        return True, None

    if not area_list or len(area_list) == 0:
        if show_debug_message:
            print(f"[AREA KEYWORD] No areas found")
        return True, None

    if show_debug_message:
        print(f"[AREA KEYWORD] Found {len(area_list)} area(s) to check")
        print(f"[AREA KEYWORD] ========================================")

    matched_blocks = []
    area_index = 0
    for row in area_list:
        area_index += 1

        try:
            row_html = await row.get_html()
            row_text = util.remove_html_tags(row_html)
        except:
            if show_debug_message:
                print(f"[AREA KEYWORD] [{area_index}] Failed to get row content")
            break

        if not row_text or util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
            if show_debug_message:
                print(f"[AREA KEYWORD] [{area_index}] Excluded by keyword_exclude")
            continue

        if show_debug_message:
            print(f"[AREA KEYWORD] [{area_index}/{len(area_list)}] Checking: {row_text[:80]}...")

        row_text = util.format_keyword_string(row_text)

        # Check keyword match
        if area_keyword_item:
            keyword_parts = area_keyword_item.split(' ')

            if show_debug_message:
                print(f"[AREA KEYWORD]   Matching AND keywords: {keyword_parts}")

            # Check each keyword individually for detailed feedback
            match_results = {}
            for kw in keyword_parts:
                formatted_kw = util.format_keyword_string(kw)
                kw_match = formatted_kw in row_text
                match_results[kw] = kw_match

                if show_debug_message:
                    status = "PASS" if kw_match else "FAIL"
                    print(f"[AREA KEYWORD]     {status} '{kw}': {kw_match}")

            is_match = all(match_results.values())

            if show_debug_message:
                if is_match:
                    print(f"[AREA KEYWORD]   All AND keywords matched")
                else:
                    print(f"[AREA KEYWORD]   AND logic failed")

            if not is_match:
                continue
        else:
            if show_debug_message:
                print(f"[AREA KEYWORD]   No keyword filter, accepting this area")

        # Check seat availability for multiple tickets
        if config_dict["ticket_number"] > 1:
            try:
                font_el = await row.query_selector('font')
                if font_el:
                    font_text = await font_el.evaluate('el => el.textContent')
                    if font_text:
                        font_text = "@%s@" % font_text

                        if show_debug_message:
                            print(f"[AREA KEYWORD]   Checking seats: {font_text.strip('@')}")

                        # Skip if only 1-9 seats remaining
                        SEATS_1_9 = ["@%d@" % i for i in range(1, 10)]
                        if any(seat in font_text for seat in SEATS_1_9):
                            if show_debug_message:
                                print(f"[AREA KEYWORD]   Insufficient seats (need {config_dict['ticket_number']}, only {font_text.strip('@')} available)")
                            continue
                        else:
                            if show_debug_message:
                                print(f"[AREA KEYWORD]   Sufficient seats available")
            except:
                pass

        matched_blocks.append(row)

        if show_debug_message:
            print(f"[AREA KEYWORD]   → Area added to matched list (total: {len(matched_blocks)})")

        if area_auto_select_mode == util.CONST_FROM_TOP_TO_BOTTOM:
            if show_debug_message:
                print(f"[AREA KEYWORD]   Mode is '{area_auto_select_mode}', stopping at first match")
            break

    if not matched_blocks:
        is_need_refresh = True
        matched_blocks = None

    return is_need_refresh, matched_blocks

async def nodriver_ticket_number_select_fill(tab, select_obj, ticket_number, select_id=None):
    """簡化版本：參考 Chrome 邏輯設定票券數量，並檢查 option 是否可用

    Args:
        tab: NoDriver tab object
        select_obj: The select element (for compatibility)
        ticket_number: Target ticket count to select
        select_id: The specific select element ID to use (fixes Issue #200/#201)
    """
    is_ticket_number_assigned = False

    if select_obj is None and select_id is None:
        return is_ticket_number_assigned

    # Build JavaScript selector - prefer specific ID over querySelector
    if select_id:
        js_selector = f"document.getElementById('{select_id}')"
    else:
        js_selector = "document.querySelector('.mobile-select') || document.querySelector('select[id*=\"TicketForm_ticketPrice_\"]')"

    try:
        # 嘗試透過 JavaScript 設定選擇器的值，並檢查 option 是否 disabled
        result = await tab.evaluate(f'''
            (function() {{
                const select = {js_selector};
                if (!select) return {{success: false, error: "Select not found"}};

                // 售完關鍵字列表
                const soldOutKeywords = ["選購一空", "已售完", "Sold out", "No tickets available", "空席なし", "完売した"];

                // 先嘗試設定目標數量（檢查是否 disabled 或售完）
                const targetOption = Array.from(select.options).find(opt =>
                    opt.value === "{ticket_number}" &&
                    !opt.disabled &&
                    !soldOutKeywords.includes(opt.value)
                );

                if (targetOption) {{
                    select.value = "{ticket_number}";
                    select.selectedIndex = targetOption.index;
                    select.dispatchEvent(new Event('change', {{bubbles: true}}));
                    return {{success: true, selected: "{ticket_number}"}};
                }}

                // 備用方案：設定為 "1"（同樣檢查是否可用）
                const fallbackOption = Array.from(select.options).find(opt =>
                    opt.value === "1" &&
                    !opt.disabled &&
                    !soldOutKeywords.includes(opt.value)
                );

                if (fallbackOption) {{
                    select.value = "1";
                    select.selectedIndex = fallbackOption.index;
                    select.dispatchEvent(new Event('change', {{bubbles: true}}));
                    return {{success: true, selected: "1"}};
                }}

                return {{success: false, error: "No valid options (all disabled or sold out)"}};
            }})();
        ''')

        # 解析結果
        result = util.parse_nodriver_result(result)
        if isinstance(result, dict):
            is_ticket_number_assigned = result.get('success', False)

    except Exception as exc:
        print(f"Failed to set ticket number: {exc}")

    return is_ticket_number_assigned

async def nodriver_tixcraft_assign_ticket_number(tab, config_dict):
    """
    Enhanced ticket type selection with keyword matching support
    支援票種關鍵字選擇（indievox 類型 B 頁面：直接跳到 /ticket/ticket/）
    """
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = util.get_debug_mode(config_dict)
    is_ticket_number_assigned = False

    # 等待票券選擇器出現（智慧等待，取代固定 0.5 秒延遲）
    try:
        await tab.wait_for('.mobile-select, select[id*="TicketForm_ticketPrice_"]', timeout=2)
    except:
        pass  # Continue even if timeout, will try to find selectors below

    # 查找票券選擇器
    form_select_list = []
    try:
        form_select_list = await tab.query_selector_all('.mobile-select')
    except Exception as exc:
        if show_debug_message:
            print("Failed to find .mobile-select")

    # 如果沒找到 .mobile-select，嘗試其他選擇器
    if len(form_select_list) == 0:
        try:
            form_select_list = await tab.query_selector_all('select[id*="TicketForm_ticketPrice_"]')
        except Exception as exc:
            if show_debug_message:
                print("Failed to find ticket selector")

    form_select_count = len(form_select_list)

    if show_debug_message and form_select_count > 0:
        print(f"[TICKET SELECT] Found {form_select_count} select element(s)")

    # Get area keyword configuration
    import json
    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
    area_auto_fallback = config_dict.get('area_auto_fallback', False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]

    # Parse keywords using JSON
    area_keyword_array = util.parse_keyword_string_to_array(area_keyword)
    if show_debug_message and area_keyword_array:
        print(f"[TICKET SELECT] Area keywords: {area_keyword_array}")

    # 過濾並收集票種資訊（包含票種名稱）
    valid_ticket_types = []
    sold_out_keywords = ["選購一空", "已售完", "Sold out", "No tickets available", "空席なし", "完売した"]

    # 使用 NoDriver Element API 檢查每個 select 元素
    for idx, select_element in enumerate(form_select_list):
        try:
            # 更新元素以確保屬性載入
            await select_element.update()

            # 檢查 select 是否 disabled
            select_attrs = select_element.attrs or {}
            select_id = select_attrs.get('id', f'select_{idx}')
            is_select_disabled = 'disabled' in select_attrs

            if is_select_disabled:
                if show_debug_message:
                    print(f"[TICKET SELECT] Skipping disabled select: {select_id}")
                continue

            # 檢查 option 元素
            option_elements = await select_element.query_selector_all('option')
            has_valid_option = False
            option_values = []

            for option_element in option_elements:
                try:
                    await option_element.update()
                    option_attrs = option_element.attrs or {}
                    option_value = option_attrs.get('value', '')
                    option_text = option_element.text or ''
                    option_disabled = 'disabled' in option_attrs

                    option_values.append(option_value)

                    # 檢查是否為有效選項
                    if (option_value != "0" and
                        not option_disabled and
                        option_value not in sold_out_keywords and
                        option_text not in sold_out_keywords):
                        has_valid_option = True

                except Exception as opt_exc:
                    if show_debug_message:
                        print(f"[TICKET SELECT] Error checking option: {opt_exc}")
                    continue

            if not has_valid_option:
                if show_debug_message:
                    print(f"[TICKET SELECT] Skipping select (all options sold out or disabled): {select_id}")
                continue

            # 嘗試獲取票種名稱（從父元素 <tr> 中的 <h4> 或 <td> 提取）
            ticket_type_name = ""
            try:
                # 查找父元素 <tr>
                parent_row = select_element
                for _ in range(5):  # 最多向上查找 5 層
                    parent_row = parent_row.parent
                    if parent_row and parent_row.tag.lower() == 'tr':
                        break

                if parent_row and parent_row.tag.lower() == 'tr':
                    # 嘗試找 <h4> 標籤
                    h4_element = await parent_row.query_selector('h4')
                    if h4_element:
                        ticket_type_name = h4_element.text or ""
                    else:
                        # 嘗試找 <td class="fcBlue">
                        td_element = await parent_row.query_selector('td.fcBlue')
                        if td_element:
                            ticket_type_name = td_element.text or ""

                    ticket_type_name = ticket_type_name.strip()

            except Exception as name_exc:
                if show_debug_message:
                    print(f"[TICKET SELECT] Failed to extract ticket type name: {name_exc}")

            # 加入 valid_ticket_types
            valid_ticket_types.append({
                'select': select_element,
                'id': select_id,
                'name': ticket_type_name,
                'index': idx
            })

            if show_debug_message:
                print(f"[TICKET SELECT] Valid ticket type: {select_id} - '{ticket_type_name}'")

        except Exception as exc:
            if show_debug_message:
                print(f"[TICKET SELECT] Error checking select element: {exc}")

    if show_debug_message:
        print(f"[TICKET SELECT] Valid ticket types: {len(valid_ticket_types)}/{form_select_count}")

    if len(valid_ticket_types) == 0:
        if show_debug_message:
            print("[TICKET SELECT] Warning: All ticket types are sold out or disabled")
        return False, None

    # Keyword matching logic (similar to area selection)
    matched_ticket = None
    is_keyword_matched = False

    if area_keyword_array:
        if show_debug_message:
            print(f"[TICKET SELECT] Starting keyword matching with {len(area_keyword_array)} keyword(s)")

        for keyword_index, keyword_item in enumerate(area_keyword_array):
            if show_debug_message:
                print(f"[TICKET SELECT] Checking keyword #{keyword_index + 1}: '{keyword_item}'")

            # Check each valid ticket type
            for ticket_info in valid_ticket_types:
                ticket_name = ticket_info['name']

                # Apply exclude keyword filter
                if util.reset_row_text_if_match_keyword_exclude(config_dict, ticket_name):
                    if show_debug_message:
                        print(f"[TICKET SELECT]   Excluded by keyword_exclude: {ticket_name}")
                    continue

                # Keyword matching (support space-separated AND logic)
                keyword_parts = keyword_item.split(' ')
                row_text = util.format_keyword_string(ticket_name)
                is_match = True

                for kw in keyword_parts:
                    formatted_kw = util.format_keyword_string(kw)
                    if formatted_kw not in row_text:
                        is_match = False
                        break

                if is_match:
                    matched_ticket = ticket_info
                    is_keyword_matched = True
                    if show_debug_message:
                        print(f"[TICKET SELECT]   ✓ Keyword matched: '{ticket_name}'")
                    break

            if matched_ticket:
                break  # Early return: first match wins

        if not matched_ticket and show_debug_message:
            print(f"[TICKET SELECT] All keywords failed to match")

    # Single option auto-select: when only one valid ticket type exists, select it directly
    # (unless excluded by keyword_exclude)
    if not matched_ticket and len(valid_ticket_types) == 1:
        single_ticket = valid_ticket_types[0]
        ticket_name = single_ticket['name']

        # Check if excluded by keyword_exclude
        if not util.reset_row_text_if_match_keyword_exclude(config_dict, ticket_name):
            matched_ticket = single_ticket
            if show_debug_message:
                print(f"[TICKET SELECT] Single option auto-select: '{ticket_name}'")
        else:
            if show_debug_message:
                print(f"[TICKET SELECT] Single option excluded by keyword_exclude: '{ticket_name}'")

    # Fallback logic (similar to area selection)
    if not matched_ticket:
        if area_keyword_array and not area_auto_fallback:
            # Strict mode: no keyword match and fallback disabled
            if show_debug_message:
                print(f"[TICKET SELECT] area_auto_fallback=false, fallback is disabled")
                print(f"[TICKET SELECT] No ticket type selected")
            return False, None, None
        else:
            # Fallback enabled or no keyword specified
            if area_keyword_array and show_debug_message:
                print(f"[TICKET SELECT] area_auto_fallback=true, using fallback selection")

            # Select based on auto_select_mode
            matched_ticket = util.get_target_item_from_matched_list(
                [t['select'] for t in valid_ticket_types],
                auto_select_mode
            )
            # Find the ticket_info for the matched select
            for ticket_info in valid_ticket_types:
                if ticket_info['select'] == matched_ticket:
                    matched_ticket = ticket_info
                    break

            if show_debug_message and matched_ticket:
                selection_type = "fallback" if area_keyword_array else "mode-based"
                print(f"[TICKET SELECT] Selected ticket type ({selection_type}): '{matched_ticket['name']}'")

    # Use the matched ticket select
    select_obj = matched_ticket['select'] if matched_ticket else None
    form_select_count = len(valid_ticket_types)

    # Get select ID for JavaScript operations
    select_id = matched_ticket['id'] if matched_ticket else None

    # 檢查是否已經選擇了票券數量（非 "0"）
    if select_id:
        try:
            # 使用 JavaScript 取得當前選中的值（使用正確的 select ID）
            current_value = await tab.evaluate(f'''
                (function() {{
                    const select = document.getElementById('{select_id}');
                    return select ? select.value : "0";
                }})();
            ''')

            # 解析結果
            current_value = util.parse_nodriver_result(current_value)

            if current_value and current_value != "0" and str(current_value).isnumeric():
                is_ticket_number_assigned = True
                if show_debug_message:
                    print(f"Ticket number already set to: {current_value}")
        except Exception as exc:
            if show_debug_message:
                print(f"Failed to check current selected value: {exc}")

    # 回傳結果：select_obj 和 select_id 用於後續操作
    return is_ticket_number_assigned, select_obj, select_id

async def nodriver_tixcraft_ticket_main_agree(tab, config_dict):
    show_debug_message = util.get_debug_mode(config_dict)

    if show_debug_message:
        print("Starting to check agreement checkbox")

    for i in range(3):
        is_finish_checkbox_click = await nodriver_check_checkbox_enhanced(tab, '#TicketForm_agree', show_debug_message)
        if is_finish_checkbox_click:
            if show_debug_message:
                print("Agreement checkbox checked successfully")
            break
        elif show_debug_message:
            print(f"Failed to check agreement, retry {i+1}/3")

    if not is_finish_checkbox_click and show_debug_message:
        print("Warning: Failed to check agreement checkbox")

async def nodriver_tixcraft_ticket_main(tab, config_dict, ocr, Captcha_Browser, domain_name):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    global tixcraft_dict
    show_debug_message = util.get_debug_mode(config_dict)

    # 檢查是否已經設定過票券數量（方案 B：狀態標記）
    current_url, _ = await nodriver_current_url(tab)
    ticket_number = str(config_dict["ticket_number"])
    ticket_state_key = f"ticket_assigned_{current_url}_{ticket_number}"

    if ticket_state_key in tixcraft_dict and tixcraft_dict[ticket_state_key]:
        if show_debug_message:
            print(f"Ticket number already set ({ticket_number}), skipping")

        # Ensure agreement checkbox is checked (even if ticket number already set)
        await nodriver_tixcraft_ticket_main_agree(tab, config_dict)

        # Reset OCR state if captcha alert detected (wrong answer submitted)
        if tixcraft_dict.get("captcha_alert_detected", False):
            tixcraft_dict["ocr_completed_url"] = ""
            tixcraft_dict["captcha_alert_detected"] = False

        # Skip OCR if already completed on this URL (non-force_submit mode only)
        is_force_submit = config_dict["ocr_captcha"]["force_submit"]
        if is_force_submit or tixcraft_dict.get("ocr_completed_url", "") != current_url:
            await nodriver_tixcraft_ticket_main_ocr(tab, config_dict, ocr, Captcha_Browser, domain_name)
        return

    # Always check agreement checkbox in NoDriver mode
    await nodriver_tixcraft_ticket_main_agree(tab, config_dict)

    is_ticket_number_assigned = False

    # PS: some events on tixcraft have multi <select>.
    # Fix Issue #200/#201: Now returns select_id for correct element targeting
    is_ticket_number_assigned, select_obj, select_id = await nodriver_tixcraft_assign_ticket_number(tab, config_dict)

    if not is_ticket_number_assigned:
        if show_debug_message:
            print(f"Setting ticket number: {ticket_number}")
        is_ticket_number_assigned = await nodriver_ticket_number_select_fill(tab, select_obj, ticket_number, select_id)

    # Record state after successful setting
    if is_ticket_number_assigned:
        tixcraft_dict[ticket_state_key] = True
        if show_debug_message:
            print("Ticket number set successfully, starting OCR captcha processing")
        await nodriver_tixcraft_ticket_main_ocr(tab, config_dict, ocr, Captcha_Browser, domain_name)
    else:
        # T026: Fix Issue #174 - reload page when ticket number cannot be set
        # This prevents infinite loop when desired ticket count is unavailable
        print("[TICKET SELECT] Ticket count unavailable, reloading page to retry...")
        try:
            await tab.reload()
            # Wait based on auto_reload_page_interval setting
            interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
            if interval > 0:
                await asyncio.sleep(interval)
        except Exception as reload_exc:
            if show_debug_message:
                print(f"[TICKET SELECT] Reload failed: {reload_exc}")

async def nodriver_tixcraft_keyin_captcha_code(tab, answer="", auto_submit=False, config_dict=None):
    """輸入驗證碼到表單"""
    is_verifyCode_editing = False
    is_form_submitted = False

    # 找到驗證碼輸入框
    form_verifyCode = await tab.query_selector('#TicketForm_verifyCode')

    if form_verifyCode:
        is_visible = False
        try:
            # 檢查元素是否可見和可用
            is_visible = await tab.evaluate('''
                (function() {
                    const element = document.querySelector('#TicketForm_verifyCode');
                    return element && !element.disabled && element.offsetParent !== null;
                })();
            ''')
        except Exception as exc:
            pass

        if is_visible:
            # 取得當前輸入值
            inputed_value = ""
            try:
                inputed_value = await form_verifyCode.apply('function (element) { return element.value; }') or ""
            except Exception as exc:
                pass

            is_text_clicked = False

            if not inputed_value and not answer:
                # 聚焦到輸入框等待手動輸入
                try:
                    await form_verifyCode.click()
                    is_text_clicked = True
                    is_verifyCode_editing = True
                except Exception as exc:
                    print("Failed to click captcha input, trying JavaScript")
                    try:
                        await tab.evaluate('''
                            document.getElementById("TicketForm_verifyCode").focus();
                        ''')
                        is_verifyCode_editing = True
                    except Exception as exc:
                        pass

            if answer:
                print("Starting to fill in captcha...")
                try:
                    if not is_text_clicked:
                        await form_verifyCode.click()

                    # 清空並輸入答案
                    await form_verifyCode.apply('function (element) { element.value = ""; }')
                    await form_verifyCode.send_keys(answer)

                    if auto_submit:
                        # 提交前確認票券數量是否已設定
                        ticket_number_ok = await tab.evaluate('''
                            (function() {
                                const select = document.querySelector('.mobile-select') ||
                                              document.querySelector('select[id*="TicketForm_ticketPrice_"]');
                                return select && select.value !== "0" && select.value !== "";
                            })();
                        ''')
                        ticket_number_ok = util.parse_nodriver_result(ticket_number_ok)

                        if not ticket_number_ok and config_dict:
                            print("Warning: Ticket number not set, resetting...")
                            # Reset ticket number
                            ticket_number = str(config_dict.get("ticket_number", 2))
                            await tab.evaluate(f'''
                                (function() {{
                                    const select = document.querySelector('.mobile-select') ||
                                                  document.querySelector('select[id*="TicketForm_ticketPrice_"]');
                                    if (select) {{
                                        select.value = "{ticket_number}";
                                        select.dispatchEvent(new Event('change', {{bubbles: true}}));
                                    }}
                                }})();
                            ''')

                        # 勾選同意條款
                        await nodriver_check_checkbox_enhanced(tab, '#TicketForm_agree')

                        # 最終確認所有欄位都已填寫
                        form_ready = await tab.evaluate('''
                            (function() {
                                const select = document.querySelector('.mobile-select') ||
                                              document.querySelector('select[id*="TicketForm_ticketPrice_"]');
                                const verify = document.querySelector('#TicketForm_verifyCode');
                                const agree = document.querySelector('#TicketForm_agree');

                                // Ticketmaster check-captcha page has no ticket selector
                                // Ticket number is already set on previous page
                                const isTicketmaster = window.location.href.includes('ticketmaster');
                                const ticketOk = isTicketmaster ? true : (select && select.value !== "0" && select.value !== "");

                                return {
                                    ticket: ticketOk,
                                    verify: verify && verify.value.length === 4,
                                    agree: agree && agree.checked,
                                    ready: ticketOk &&
                                           (verify && verify.value.length === 4) &&
                                           (agree && agree.checked)
                                };
                            })();
                        ''')
                        form_ready = util.parse_nodriver_result(form_ready)

                        if form_ready.get('ready', False):
                            # 提交表單 (按 Enter) - 使用完整的鍵盤事件
                            await tab.send(cdp.input_.dispatch_key_event("keyDown", code="Enter", key="Enter", text="\r", windows_virtual_key_code=13))
                            await tab.send(cdp.input_.dispatch_key_event("keyUp", code="Enter", key="Enter", text="\r", windows_virtual_key_code=13))
                            is_verifyCode_editing = False
                            is_form_submitted = True
                        else:
                            print(f"Form not ready - Ticket:{form_ready.get('ticket')} Captcha:{form_ready.get('verify')} Agreement:{form_ready.get('agree')}")
                    else:
                        # 選取輸入框內容並顯示提示
                        await tab.evaluate('''
                            document.getElementById("TicketForm_verifyCode").select();
                        ''')
                        # 顯示提示訊息
                        await nodriver_tixcraft_toast(tab, f"※ 按 Enter 如果答案是: {answer}")

                except Exception as exc:
                    print("Failed to input captcha:", exc)

    return is_verifyCode_editing, is_form_submitted

async def nodriver_tixcraft_toast(tab, message):
    """顯示提示訊息"""
    try:
        await tab.evaluate(f'''
            (function() {{
                const toast = document.querySelector('p.remark-word');
                if (toast) {{
                    toast.innerHTML = '{message}';
                }}
            }})();
        ''')
    except Exception as exc:
        pass

async def nodriver_tixcraft_reload_captcha(tab, domain_name):
    """點擊重新載入驗證碼"""
    ret = False
    image_id = 'TicketForm_verifyCode-image'

    if 'indievox.com' in domain_name:
        image_id = 'TicketForm_verifyCode-image'

    try:
        form_captcha = await tab.query_selector(f"#{image_id}")
        if form_captcha:
            await form_captcha.click()
            ret = True
    except Exception as exc:
        print(f"Failed to reload captcha: {exc}")

    return ret

async def nodriver_tixcraft_get_ocr_answer(tab, ocr, ocr_captcha_image_source, Captcha_Browser, domain_name):
    """取得驗證碼圖片並進行 OCR 識別"""
    show_debug_message = False

    ocr_answer = None
    if not ocr is None:
        img_base64 = None

        if ocr_captcha_image_source == CONST_OCR_CAPTCH_IMAGE_SOURCE_NON_BROWSER:
            if not Captcha_Browser is None:
                img_base64 = base64.b64decode(Captcha_Browser.request_captcha())

        if ocr_captcha_image_source == CONST_OCR_CAPTCH_IMAGE_SOURCE_CANVAS:
            image_id = 'TicketForm_verifyCode-image'
            if 'indievox.com' in domain_name:
                image_id = 'TicketForm_verifyCode-image'

            try:
                # 使用 JavaScript 從 canvas 取得圖片
                form_verifyCode_base64 = await tab.evaluate(f'''
                    (function() {{
                        var canvas = document.createElement('canvas');
                        var context = canvas.getContext('2d');
                        var img = document.getElementById('{image_id}');
                        if(img) {{
                            canvas.height = img.naturalHeight;
                            canvas.width = img.naturalWidth;
                            context.drawImage(img, 0, 0);
                            return canvas.toDataURL();
                        }}
                        return null;
                    }})();
                ''')

                if form_verifyCode_base64:
                    img_base64 = base64.b64decode(form_verifyCode_base64.split(',')[1])

                if img_base64 is None:
                    if not Captcha_Browser is None:
                        print("Failed to get image from canvas, using fallback: NonBrowser")
                        img_base64 = base64.b64decode(Captcha_Browser.request_captcha())

            except Exception as exc:
                if show_debug_message:
                    print("Canvas processing error:", str(exc))

        # OCR 識別
        if not img_base64 is None:
            try:
                ocr_answer = ocr.classification(img_base64)
            except Exception as exc:
                if show_debug_message:
                    print("OCR recognition failed:", exc)

    return ocr_answer

async def nodriver_tixcraft_auto_ocr(tab, config_dict, ocr, away_from_keyboard_enable,
                                     previous_answer, Captcha_Browser,
                                     ocr_captcha_image_source, domain_name):
    """OCR 自動識別主邏輯"""
    show_debug_message = util.get_debug_mode(config_dict)

    is_need_redo_ocr = False
    is_form_submitted = False

    is_input_box_exist = False
    if not ocr is None:
        form_verifyCode = None
        try:
            form_verifyCode = await tab.query_selector('#TicketForm_verifyCode')
            is_input_box_exist = True
        except Exception as exc:
            pass
    else:
        print("[TIXCRAFT OCR] ddddocr component unavailable, you may be running on ARM")

    if is_input_box_exist:
        if show_debug_message:
            print("[TIXCRAFT OCR] away_from_keyboard_enable:", away_from_keyboard_enable)
            print("[TIXCRAFT OCR] previous_answer:", previous_answer)
            print("[TIXCRAFT OCR] ocr_captcha_image_source:", ocr_captcha_image_source)

        ocr_start_time = time.time()
        ocr_answer = await nodriver_tixcraft_get_ocr_answer(tab, ocr, ocr_captcha_image_source, Captcha_Browser, domain_name)
        ocr_done_time = time.time()
        ocr_elapsed_time = ocr_done_time - ocr_start_time
        if show_debug_message:
            print("[TIXCRAFT OCR] Processing time:", "{:.3f}".format(ocr_elapsed_time))

        if ocr_answer is None:
            if away_from_keyboard_enable:
                # 頁面尚未準備好，重試
                # PS: 通常發生在非同步腳本取得驗證碼圖片時
                is_need_redo_ocr = True
                await asyncio.sleep(0.1)
            else:
                await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
        else:
            ocr_answer = ocr_answer.strip()
            if show_debug_message:
                print("[TIXCRAFT OCR] Result:", ocr_answer)
            if len(ocr_answer) == 4:
                who_care_var, is_form_submitted = await nodriver_tixcraft_keyin_captcha_code(tab, answer=ocr_answer, auto_submit=away_from_keyboard_enable, config_dict=config_dict)
            else:
                if not away_from_keyboard_enable:
                    await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
                else:
                    is_need_redo_ocr = True
                    if previous_answer != ocr_answer:
                        previous_answer = ocr_answer
                        if show_debug_message:
                            print("[TIXCRAFT OCR] Reloading captcha")

                        # selenium 解決方案
                        await nodriver_tixcraft_reload_captcha(tab, domain_name)

                        if ocr_captcha_image_source == CONST_OCR_CAPTCH_IMAGE_SOURCE_CANVAS:
                            await asyncio.sleep(0.1)
    else:
        print("[TIXCRAFT OCR] Input box not found, exiting OCR...")

    return is_need_redo_ocr, previous_answer, is_form_submitted

async def nodriver_tixcraft_ticket_main_ocr(tab, config_dict, ocr, Captcha_Browser, domain_name):
    """票券頁面 OCR 處理主函數"""
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False, "", False

    show_debug_message = util.get_debug_mode(config_dict)

    away_from_keyboard_enable = config_dict["ocr_captcha"]["force_submit"]
    if not config_dict["ocr_captcha"]["enable"]:
        away_from_keyboard_enable = False
    ocr_captcha_image_source = config_dict["ocr_captcha"]["image_source"]

    if not config_dict["ocr_captcha"]["enable"]:
        # 手動模式
        await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
    else:
        # 自動 OCR 模式
        previous_answer = None
        current_url, _ = await nodriver_current_url(tab)
        fail_count = 0  # Track consecutive failures
        total_fail_count = 0  # Track total failures
        is_form_submitted = False

        for redo_ocr in range(5):
            is_need_redo_ocr, previous_answer, is_form_submitted = await nodriver_tixcraft_auto_ocr(
                tab, config_dict, ocr, away_from_keyboard_enable,
                previous_answer, Captcha_Browser, ocr_captcha_image_source, domain_name
            )

            if is_form_submitted:
                if show_debug_message:
                    print("[TIXCRAFT OCR] Form submitted")
                break

            if not away_from_keyboard_enable:
                break

            if not is_need_redo_ocr:
                break

            # Track failures and refresh captcha after 3 consecutive failures
            if is_need_redo_ocr:
                fail_count += 1
                total_fail_count += 1
                if show_debug_message:
                    print(f"[TIXCRAFT OCR] Fail count: {fail_count}, Total fails: {total_fail_count}")

                # Check if total failures reached 5, switch to manual input mode
                if total_fail_count >= 5:
                    print("[TIXCRAFT OCR] OCR failed 5 times. Please enter captcha manually.")
                    away_from_keyboard_enable = False
                    await nodriver_tixcraft_keyin_captcha_code(tab, config_dict=config_dict)
                    break

                if fail_count >= 3:
                    if show_debug_message:
                        print("[TIXCRAFT OCR] 3 consecutive failures reached")

                    # Try to dismiss any existing alert before continuing
                    try:
                        await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                        if show_debug_message:
                            print("[TIXCRAFT OCR] Dismissed existing alert")
                    except:
                        pass

                    # Wait for potential auto-refresh
                    await asyncio.sleep(2.5)
                    fail_count = 0  # Reset consecutive counter after handling

            # 檢查是否還在同一頁面
            new_url, _ = await nodriver_current_url(tab)
            if new_url != current_url:
                break

            if show_debug_message:
                print(f"[TIXCRAFT OCR] Retry {redo_ocr + 1}/5")

        # Mark OCR completed for this URL only when form was actually submitted
        if is_form_submitted:
            tixcraft_dict["ocr_completed_url"] = current_url


async def nodriver_tixcraft_main(tab, url, config_dict, ocr, Captcha_Browser):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Global alert handler - auto-dismiss all alerts (sold out, errors, etc.)
    # Handles alerts that appear after page navigation (e.g., area selection redirects)
    # Reference: KHAM platform implementation (Line 10681-10697)
    async def handle_global_alert(event):
        global tixcraft_dict
        # IMPORTANT: Use tab.target.url (cached) instead of nodriver_current_url (js_dumps)
        # When alert dialog is open, JavaScript execution is blocked, causing js_dumps to hang
        current_url = tab.target.url if hasattr(tab, 'target') and tab.target else ""

        if '/ticket/checkout' in current_url:
            if show_debug_message:
                print(f"[GLOBAL ALERT] Alert on checkout page, NOT auto-dismissing: '{event.message}'")
            return

        if show_debug_message:
            print(f"[GLOBAL ALERT] Alert detected: '{event.message}'")

        # Track captcha error alerts for retry logic
        is_captcha_error = False
        captcha_error_keywords = [
            'verification code',
            'incorrect',
            'try again',
            'captcha',
            'wrong code'
        ]
        alert_message_lower = event.message.lower()
        for keyword in captcha_error_keywords:
            if keyword in alert_message_lower:
                is_captcha_error = True
                break

        if is_captcha_error:
            tixcraft_dict["captcha_alert_detected"] = True
            if show_debug_message:
                print(f"[GLOBAL ALERT] Captcha error detected, flagging for retry")

        # Issue #188: Detect sold out alerts to add cooldown delay
        sold_out_keywords = ['售完', '已售完', '選購一空', 'sold out', 'no tickets']
        is_sold_out_alert = any(kw in alert_message_lower for kw in sold_out_keywords)

        # Dismiss the alert - try multiple times with small delays
        dismiss_success = False
        for attempt in range(3):
            try:
                await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                dismiss_success = True
                if show_debug_message:
                    print(f"[GLOBAL ALERT] Alert dismissed (attempt {attempt + 1})")
                break
            except Exception as dismiss_exc:
                error_msg = str(dismiss_exc)
                # CDP -32602 means no dialog is showing (already dismissed by another handler or user)
                if "No dialog is showing" in error_msg or "-32602" in error_msg:
                    dismiss_success = True  # Consider it handled
                    if show_debug_message:
                        print("[GLOBAL ALERT] Dialog already dismissed")
                    break  # No need to retry
                if attempt < 2:
                    await asyncio.sleep(0.1)  # Small delay before retry
                else:
                    if show_debug_message:
                        print(f"[GLOBAL ALERT] Failed to dismiss alert: {dismiss_exc}")

        # Issue #188: Set cooldown timestamp instead of async sleep (event handler doesn't block main loop)
        if is_sold_out_alert and dismiss_success:
            interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
            if interval > 0:
                cooldown_until = time.time() + interval
                tixcraft_dict["sold_out_cooldown_until"] = cooldown_until
                if show_debug_message:
                    print(f"[GLOBAL ALERT] Sold out detected, setting cooldown for {interval}s")

    global tixcraft_dict

    # Initialize tixcraft_dict if not exists
    if not 'tixcraft_dict' in globals():
        tixcraft_dict = {}
        tixcraft_dict["fail_list"]=[]
        tixcraft_dict["fail_promo_list"]=[]
        tixcraft_dict["start_time"]=None
        tixcraft_dict["done_time"]=None
        tixcraft_dict["elapsed_time"]=None
        tixcraft_dict["is_popup_checkout"] = False
        tixcraft_dict["area_retry_count"]=0
        tixcraft_dict["played_sound_ticket"] = False
        tixcraft_dict["played_sound_order"] = False
        tixcraft_dict["alert_handler_registered"] = False
        tixcraft_dict["captcha_alert_detected"] = False
        tixcraft_dict["ocr_completed_url"] = ""
        tixcraft_dict["last_homepage_redirect_time"] = 0
        tixcraft_dict["sold_out_cooldown_until"] = 0  # Issue #188: Cooldown timestamp

    # Register global alert handler (remains active throughout session)
    # Only register once to prevent infinite loop
    if not tixcraft_dict.get("alert_handler_registered", False):
        try:
            tab.add_handler(cdp.page.JavascriptDialogOpening, handle_global_alert)
            tixcraft_dict["alert_handler_registered"] = True
            if show_debug_message:
                print(f"[GLOBAL ALERT] Global alert handler registered")
        except Exception as handler_exc:
            if show_debug_message:
                print(f"[GLOBAL ALERT] Failed to register alert handler: {handler_exc}")

    await nodriver_tixcraft_home_close_window(tab)

    # special case for same event re-open, redirect to user's homepage.
    # Add cooldown to prevent infinite redirect loop when area page is unavailable
    # Match homepage URLs: tixcraft.com, tixcraft.com/, tixcraft.com/activity
    is_tixcraft_home = url in ['https://tixcraft.com', 'https://tixcraft.com/', 'https://tixcraft.com/activity']
    if is_tixcraft_home:
        if "/ticket/area/" in config_dict["homepage"]:
            if len(config_dict["homepage"].split('/'))==7:
                current_time = time.time()
                last_redirect_time = tixcraft_dict.get("last_homepage_redirect_time", 0)
                # Use auto_reload_page_interval from settings, default to 3 seconds
                redirect_interval = config_dict["advanced"].get("auto_reload_page_interval", 3)
                if redirect_interval <= 0:
                    redirect_interval = 3  # Minimum 3 seconds to prevent rapid loop

                if current_time - last_redirect_time > redirect_interval:
                    try:
                        tixcraft_dict["last_homepage_redirect_time"] = current_time
                        await tab.get(config_dict["homepage"])
                    except Exception as e:
                        pass

    if "/activity/detail/" in url:
        tixcraft_dict["start_time"] = time.time()
        is_redirected = await nodriver_tixcraft_redirect(tab, url)

    is_date_selected = False
    # Check if this is a Ticketmaster page before using TixCraft logic
    if "/activity/game/" in url and 'ticketmaster' not in url:
        tixcraft_dict["start_time"] = time.time()
        if config_dict["date_auto_select"]["enable"]:
            domain_name = url.split('/')[2]
            is_date_selected = await nodriver_tixcraft_date_auto_select(tab, url, config_dict, domain_name)

    # T010: Ticketmaster date selection integration (User Story 1)
    # Support both URL formats:
    # - /artist/{artist_id} (artist listing page)
    # - /activity/game/{event_id} (event date listing page from /activity/detail redirect)
    is_ticketmaster_date_page = (
        'ticketmaster' in url and
        (('/artist/' in url and len(url.split('/'))==6) or
         ('/activity/game/' in url))
    )

    if is_ticketmaster_date_page:
        tixcraft_dict["start_time"] = time.time()
        if config_dict["date_auto_select"]["enable"]:
            if config_dict.get("advanced", {}).get("verbose", False):
                print(f"[TICKETMASTER] Detected Ticketmaster date page, calling date auto select")
            domain_name = url.split('/')[2]
            # Call Ticketmaster date auto select
            is_date_selected = await nodriver_ticketmaster_date_auto_select(tab, config_dict)
            if show_debug_message:
                if is_date_selected:
                    print("[TICKETMASTER] Date selection completed")
                else:
                    print("[TICKETMASTER] Date selection failed or no match")

    # choose area
    if '/ticket/area/' in url:
        domain_name = url.split('/')[2]
        if config_dict["area_auto_select"]["enable"]:
            if not 'ticketmaster' in domain_name:
                # for tixcraft
                await nodriver_tixcraft_area_auto_select(tab, url, config_dict)

                tixcraft_dict["area_retry_count"]+=1
                #print("count:", tixcraft_dict["area_retry_count"])
                if tixcraft_dict["area_retry_count"] >= (60 * 15):
                    # Cool-down
                    tixcraft_dict["area_retry_count"] = 0
                    await asyncio.sleep(5)
            else:
                # T013: Ticketmaster area selection integration (User Story 2)
                # Check if we already processed this page (avoid repeated execution)
                ticketmaster_area_processed = tixcraft_dict.get("ticketmaster_area_processed_url", "")
                if ticketmaster_area_processed == url:
                    # Already processed this URL, wait for page change
                    tixcraft_dict["area_retry_count"] += 1
                    if tixcraft_dict["area_retry_count"] >= 10:
                        # Reset after 10 retries to allow re-processing
                        tixcraft_dict["ticketmaster_area_processed_url"] = ""
                        tixcraft_dict["area_retry_count"] = 0
                        if show_debug_message:
                            print("[TICKETMASTER] Area page retry limit reached, resetting state")
                else:
                    # Parse zone_info and auto-select area
                    zone_info = await nodriver_ticketmaster_parse_zone_info(tab, config_dict)
                    if zone_info:
                        await nodriver_ticketmaster_area_auto_select(tab, config_dict, zone_info)

                    # T017: Ticketmaster ticket number and promo integration (User Story 3)
                    # Set ticket number (will fallback to zone_info if ticketPriceList not found)
                    await nodriver_ticketmaster_assign_ticket_number(tab, config_dict)

                    # Handle promo code
                    tixcraft_dict["fail_promo_list"] = await nodriver_ticketmaster_promo(tab, config_dict, tixcraft_dict["fail_promo_list"])

                    # Mark this URL as processed
                    tixcraft_dict["ticketmaster_area_processed_url"] = url
                    tixcraft_dict["area_retry_count"] = 0
    else:
        tixcraft_dict["fail_promo_list"] = []
        tixcraft_dict["area_retry_count"]=0

    # T020: Ticketmaster captcha integration (User Story 4)
    # https://ticketmaster.sg/ticket/check-captcha/23_blackpink/954/5/75
    if '/ticket/check-captcha/' in url:
        domain_name = url.split('/')[2]
        if 'ticketmaster' in domain_name:
            # Check if we already processed this captcha page (avoid repeated execution)
            ticketmaster_captcha_processed = tixcraft_dict.get("ticketmaster_captcha_processed_url", "")
            if ticketmaster_captcha_processed != url:
                # Call Ticketmaster captcha handler
                await nodriver_ticketmaster_captcha(tab, config_dict, ocr, Captcha_Browser)
                # Mark this URL as processed
                tixcraft_dict["ticketmaster_captcha_processed_url"] = url
    else:
        # Reset captcha processed state when leaving captcha page
        tixcraft_dict["ticketmaster_captcha_processed_url"] = ""

    if '/ticket/verify/' in url:
        # Tixcraft verify handler (already implemented)
        tixcraft_dict["fail_list"] = await nodriver_tixcraft_verify(tab, config_dict, tixcraft_dict["fail_list"])
    else:
        tixcraft_dict["fail_list"] = []

    # main app, to select ticket number.
    if '/ticket/ticket/' in url:
        domain_name = url.split('/')[2]
        await nodriver_tixcraft_ticket_main(tab, config_dict, ocr, Captcha_Browser, domain_name)
        tixcraft_dict["done_time"] = time.time()

        if not tixcraft_dict["played_sound_ticket"]:
            if config_dict["advanced"]["play_sound"]["ticket"]:
                play_sound_while_ordering(config_dict)
        tixcraft_dict["played_sound_ticket"] = True
    else:
        tixcraft_dict["played_sound_ticket"] = False

    if '/ticket/order' in url:
        tixcraft_dict["done_time"] = time.time()

    is_quit_bot = False
    if '/ticket/checkout' in url:
        if not tixcraft_dict["start_time"] is None:
            if not tixcraft_dict["done_time"] is None:
                bot_elapsed_time = tixcraft_dict["done_time"] - tixcraft_dict["start_time"]
                if tixcraft_dict["elapsed_time"] != bot_elapsed_time:
                    print("bot elapsed time:", "{:.3f}".format(bot_elapsed_time))
                tixcraft_dict["elapsed_time"] = bot_elapsed_time

        # Always set is_quit_bot when checkout page is detected (not just in headless mode)
        if not tixcraft_dict["is_popup_checkout"]:
            is_quit_bot = True
            tixcraft_dict["is_popup_checkout"] = True

            # Issue #193: Move inside the block to execute only once on first checkout detection
            # Headless-specific behavior: open checkout URL in new browser window
            if config_dict["advanced"]["headless"]:
                domain_name = url.split('/')[2]
                checkout_url = "https://%s/ticket/checkout" % (domain_name)
                print("Ticket purchase successful, please check order at: %s" % (checkout_url))
                webbrowser.open_new(checkout_url)

        if not tixcraft_dict["played_sound_order"]:
            if config_dict["advanced"]["play_sound"]["order"]:
                play_sound_while_ordering(config_dict)
            send_discord_notification(config_dict, "order", "TixCraft")
        tixcraft_dict["played_sound_order"] = True
    else:
        tixcraft_dict["is_popup_checkout"] = False
        tixcraft_dict["played_sound_order"] = False

    return is_quit_bot


async def nodriver_ticketplus_detect_layout_style(tab, config_dict=None):
    """偵測 TicketPlus 頁面佈局樣式

    Returns:
        dict: {
            'style': int,      # 0: 無法偵測, 1: style_1 (展開式), 2: style_2 (簡單式), 3: style_3 (新版Vue.js)
            'found': bool,     # 是否找到下一步按鈕
            'button_enabled': bool  # 按鈕是否已啟用
        }
    """
    try:
        result = await evaluate_with_pause_check(tab, '''
            (function() {
                console.log("=== Layout Detection Started ===");

                // 先檢查頁面中是否有 row 佈局的票種結構 (Page3特徵)
                const rowTickets = document.querySelectorAll('.row.py-1.py-md-4.rwd-margin.no-gutters.text-title');
                const expansionPanels = document.querySelectorAll('.v-expansion-panels .v-expansion-panel');

                console.log("Row ticket element count:", rowTickets.length);
                console.log("Expansion Panel element count:", expansionPanels.length);

                // 如果有 row 票種且沒有 expansion panels，優先判定為 style 3 (Page3)
                if (rowTickets.length > 0 && expansionPanels.length === 0) {
                    // 檢查 style_3 按鈕
                    const style3Button = document.querySelector("div.order-footer > div.container > div.row > div.col-sm-3.col-4 > button.nextBtn") ||
                                       document.querySelector("button.nextBtn");
                    if (style3Button) {
                        console.log("Confirmed as Page3 (Style 3) - Row layout");
                        return {
                            style: 3,
                            found: true,
                            button_enabled: style3Button.disabled === false,
                            button_class: style3Button.className,
                            debug_info: "Page3 row layout detected"
                        };
                    }
                }

                // style_3: 新版 Vue.js 佈局 (通用檢查)
                const style3Button = document.querySelector("div.order-footer > div.container > div.row > div.col-sm-3.col-4 > button.nextBtn");
                if (style3Button) {
                    console.log("Found Style 3 button");
                    return {
                        style: 3,
                        found: true,
                        button_enabled: style3Button.disabled === false,
                        button_class: style3Button.className,
                        debug_info: "Standard style 3 button"
                    };
                }

                // style_2: 新版佈局 (簡單式)
                const style2Button = document.querySelector("div.order-footer > div.container > div.row > div > button.nextBtn");
                if (style2Button) {
                    console.log("Found Style 2 button");
                    return {
                        style: 2,
                        found: true,
                        button_enabled: style2Button.disabled === false,
                        button_class: style2Button.className,
                        debug_info: "Standard style 2 button"
                    };
                }

                // style_1: 舊版佈局 (展開式) - 只有在有 expansion panels 時才判定
                if (expansionPanels.length > 0) {
                    const style1Button = document.querySelector("div.order-footer > div.container > div.row > div > div.row > div > button.nextBtn");
                    if (style1Button) {
                        console.log("Found Style 1 button (expansion panel type)");
                        return {
                            style: 1,
                            found: true,
                            button_enabled: style1Button.disabled === false,
                            button_class: style1Button.className,
                            debug_info: "Expansion panel layout"
                        };
                    }
                }

                // 通用按鈕查找 (兜底方案)
                const anyButton = document.querySelector("button.nextBtn");
                if (anyButton) {
                    console.log("Found generic nextBtn button, determining style based on content structure");
                    // 根據頁面結構特徵判斷樣式
                    if (rowTickets.length > 0) {
                        return {
                            style: 3,
                            found: true,
                            button_enabled: anyButton.disabled === false,
                            button_class: anyButton.className,
                            debug_info: "Generic button + row structure = style 3"
                        };
                    }
                    if (expansionPanels.length > 0) {
                        return {
                            style: 1,
                            found: true,
                            button_enabled: anyButton.disabled === false,
                            button_class: anyButton.className,
                            debug_info: "Generic button + expansion panels = style 1"
                        };
                    }
                }

                console.log("Unable to detect layout style");
                return {
                    style: 0,
                    found: false,
                    button_enabled: false,
                    button_class: "",
                    debug_info: "No layout detected"
                };
            })();
        ''')

        # 檢查是否因暫停而中斷
        if result is None:
            return {'style': 0, 'found': False, 'button_enabled': False, 'paused': True}

        # 使用統一解析函數處理返回值
        result = util.parse_nodriver_result(result)

        return result if isinstance(result, dict) else {
            'style': 0, 'found': False, 'button_enabled': False
        }

    except Exception as exc:
        return {'style': 0, 'found': False, 'button_enabled': False, 'error': str(exc)}

async def nodriver_ticketplus_account_sign_in(tab, config_dict):
    print("nodriver_ticketplus_account_sign_in")
    is_filled_form = False
    is_submited = False

    ticketplus_account = config_dict["accounts"]["ticketplus_account"]
    ticketplus_password = config_dict["accounts"]["ticketplus_password"].strip()

    # manually keyin verify code.
    country_code = ""
    try:
        my_css_selector = 'input[placeholder="區碼"]'
        el_country = await tab.query_selector(my_css_selector)
        if el_country:
            country_code = await el_country.apply('function (element) { return element.value; } ')
            print("country_code", country_code)
    except Exception as exc:
        print(exc)

    is_account_assigned = False
    try:
        my_css_selector = 'input[placeholder="手機號碼 *"]'
        el_account = await tab.query_selector(my_css_selector)
        if el_account:
            await el_account.click()
            await el_account.apply('function (element) {element.value = ""; } ')
            await el_account.send_keys(ticketplus_account);
            is_account_assigned = True
    except Exception as exc:
        print(exc)

    if is_account_assigned:
        try:
            my_css_selector = 'input[type="password"]'
            el_password = await tab.query_selector(my_css_selector)
            if el_password:
                print("Entering password...")
                await el_password.click()
                await el_password.apply('function (element) {element.value = ""; } ')
                await el_password.send_keys(ticketplus_password);
                await asyncio.sleep(random.uniform(0.1, 0.3))
                is_filled_form = True

                if country_code=="+886":
                    # only this case to auto sumbmit.
                    print("press enter")
                    await tab.send(cdp.input_.dispatch_key_event("keyDown", code="Enter", key="Enter", text="\r", windows_virtual_key_code=13))
                    await tab.send(cdp.input_.dispatch_key_event("keyUp", code="Enter", key="Enter", text="\r", windows_virtual_key_code=13))
                    await asyncio.sleep(random.uniform(0.8, 1.2))
                    # PS: ticketplus country field may not located at your target country.
                    is_submited = True
        except Exception as exc:
            print(exc)
            pass


    return is_filled_form, is_submited

async def nodriver_ticketplus_is_signin(tab):
    is_user_signin = False
    try:
        cookies  = await tab.browser.cookies.get_all()
        for cookie in cookies:
            if cookie.name=='user':
                if '%22account%22:%22' in cookie.value:
                    is_user_signin = True
        cookies = None
    except Exception as exc:
        print(exc)
        pass

    return is_user_signin


async def nodriver_ticketplus_account_auto_fill(tab, config_dict):
    global is_filled_ticketplus_singin_form

    if not 'is_filled_ticketplus_singin_form' in globals():
        is_filled_ticketplus_singin_form = False

    # auto fill account info.
    is_user_signin = False
    if len(config_dict["accounts"]["ticketplus_account"]) > 0:
        is_user_signin = await nodriver_ticketplus_is_signin(tab)
        #print("is_user_signin:", is_user_signin)
        if not is_user_signin:
            await asyncio.sleep(0.1)
            if not is_filled_ticketplus_singin_form:
                is_sign_in_btn_pressed = False
                try:
                    # full screen mode.
                    my_css_selector = 'button.v-btn > span.v-btn__content > i.mdi-account'
                    sign_in_btn = await tab.query_selector(my_css_selector)
                    if sign_in_btn:
                        await sign_in_btn.click()
                        is_sign_in_btn_pressed = True
                        await asyncio.sleep(0.2)
                except Exception as exc:
                    print(exc)
                    pass

                #print("is_sign_in_btn_pressed", is_sign_in_btn_pressed)
                if not is_sign_in_btn_pressed:
                    #print("rwd mode")
                    action_btns = None
                    try:
                        my_css_selector = 'div.px-4.py-3.drawerItem.cursor-pointer'
                        action_btns = await tab.query_selector_all(my_css_selector)
                    except Exception as exc:
                        print(exc)
                        pass
                    if action_btns:
                        print("len:", len(action_btns))
                        if len(action_btns) >= 4:
                            try:
                                await action_btns[3].click()
                            except Exception as exc:
                                print(exc)
                                pass

                is_filled_form, is_submited = await nodriver_ticketplus_account_sign_in(tab, config_dict)
                if is_filled_form:
                    is_filled_ticketplus_singin_form = True

    return is_user_signin

async def nodriver_ticketplus_date_auto_select(tab, config_dict):
    """TicketPlus 日期自動選擇功能"""
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # 讀取設定
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get('date_auto_fallback', False)  # T017: Safe access for new field
    pass_date_is_sold_out_enable = config_dict["tixcraft"]["pass_date_is_sold_out"]
    auto_reload_coming_soon_page_enable = config_dict["tixcraft"]["auto_reload_coming_soon_page"]

    if show_debug_message:
        print("date_auto_select_mode:", auto_select_mode)
        print("date_keyword:", date_keyword)

    # 查找日期區塊
    area_list = None
    try:
        area_list = await tab.query_selector_all('div#buyTicket > div.sesstion-item > div.row')
        if area_list and len(area_list) == 0:
            if show_debug_message:
                print("empty date item, need retry.")
            await tab.sleep(0.2)
    except Exception as exc:
        if show_debug_message:
            print("find #buyTicket fail:", exc)

    # 檢查可購買的選項（包含「尚未開賣」，點擊後在 order 頁面等待）
    find_ticket_text_list = ['>立即購', '尚未開賣']
    sold_out_text_list = ['銷售一空']

    matched_blocks = None
    formated_area_list = None
    is_vue_ready = True

    if area_list and len(area_list) > 0:
        if show_debug_message:
            print("date_list_count:", len(area_list))

        formated_area_list = []
        for row in area_list:
            row_text = ""
            row_html = ""
            try:
                row_html = await row.get_html()
                row_text = util.remove_html_tags(row_html)
            except Exception as exc:
                if show_debug_message:
                    print("Date item processing failed:", exc)
                break

            if len(row_text) > 0:
                if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                    row_text = ""

            if len(row_text) > 0:
                if '<div class="v-progress-circular__info"></div>' in row_html:
                    # Vue.js 尚未載入完成
                    is_vue_ready = False
                    break

            if len(row_text) > 0:
                row_is_enabled = False
                for text_item in find_ticket_text_list:
                    if text_item in row_html:
                        row_is_enabled = True
                        break

                # 檢查是否已售完
                if row_is_enabled and pass_date_is_sold_out_enable:
                    for sold_out_item in sold_out_text_list:
                        if sold_out_item in row_text:
                            row_is_enabled = False
                            if show_debug_message:
                                print(f"match sold out text: {sold_out_item}, skip this row.")
                            break

                if row_is_enabled:
                    formated_area_list.append(row)

        if show_debug_message:
            print("formated_area_list count:", len(formated_area_list))

        # Keyword matching - Unified JSON array parsing with AND/OR logic
        # Format: "AA BB","CC","DD" -> (AA AND BB) OR (CC) OR (DD)
        if len(date_keyword) == 0:
            matched_blocks = formated_area_list
        else:
            matched_blocks = []
            try:
                # Parse as JSON array (auto-removes quotes)
                import json
                original_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
                keyword_array = json.loads("[" + original_keyword + "]")

                if show_debug_message:
                    print(f"[TicketPlus DATE] Applying keyword filter: {keyword_array}")

                # Match keyword groups (OR logic between groups)
                for i, row in enumerate(formated_area_list):
                    # Get row text
                    row_text = ""
                    try:
                        row_html = await row.get_html()
                        row_text = util.remove_html_tags(row_html).lower()
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[TicketPlus DATE] Failed to get row text: {exc}")
                        continue

                    # Check if any keyword group matches (OR logic between groups)
                    for keyword_item in keyword_array:
                        # Split by space for AND logic (e.g., "AA BB" means AA AND BB)
                        sub_keywords = [kw.strip() for kw in keyword_item.split(' ') if kw.strip()]

                        # Check if all sub-keywords match (AND logic within group)
                        is_match = all(sub_kw.lower() in row_text for sub_kw in sub_keywords)

                        if is_match:
                            matched_blocks.append(row)
                            if show_debug_message:
                                print(f"[TicketPlus DATE] Keyword '{keyword_item}' matched row {i}")
                            break  # Stop checking other keyword groups for this row

            except json.JSONDecodeError as exc:
                if show_debug_message:
                    print(f"[TicketPlus DATE] Keyword parse error: {exc}")
                    print(f"[TicketPlus DATE] Treating as 'all keywords failed'")
                matched_blocks = []  # Let Feature 003 fallback logic handle this
            except Exception as exc:
                if show_debug_message:
                    print(f"[TicketPlus DATE] Keyword matching failed: {exc}")
                matched_blocks = []

        # T018-T020: Conditional fallback based on date_auto_fallback switch
        if len(matched_blocks) == 0 and date_keyword and len(date_keyword) > 0:
            if date_auto_fallback:
                # T018: Fallback enabled
                if show_debug_message:
                    print(f"[TicketPlus DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                matched_blocks = formated_area_list
            else:
                # T019: Fallback disabled - strict mode (no selection, but continue to JavaScript)
                if show_debug_message:
                    print(f"[TicketPlus DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                    print(f"[TicketPlus DATE SELECT] No date selected, will check if reload needed")
                # Don't return - let JavaScript handle the logic and return is_date_clicked=False
                # JavaScript will return {success: false, strict_mode: true}
    else:
        if show_debug_message:
            print("date date-time-position is None or empty")

    # 執行點擊 - 完全使用 JavaScript 避免元素物件操作
    is_date_clicked = False
    # 當有可點擊的日期時執行點擊（包含「尚未開賣」，將在 order 頁面等待刷新）
    if is_vue_ready and formated_area_list and len(formated_area_list) > 0:
        try:
            # 使用原始關鍵字進行點擊，與匹配邏輯保持一致
            original_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
            # 直接在 JavaScript 中完成日期選擇和點擊
            click_result = await tab.evaluate(f'''
                (function() {{
                    const originalKeyword = '{original_keyword}';
                    const autoSelectMode = '{auto_select_mode}';
                    const dateAutoFallback = {'true' if date_auto_fallback else 'false'};

                    console.log('[TicketPlus] Starting date selection - keyword:', originalKeyword, 'mode:', autoSelectMode, 'fallback:', dateAutoFallback);

                    // 優先選擇場次容器（包含完整日期資訊）
                    let sessionContainers = Array.from(document.querySelectorAll('.sesstion-item'));

                    // 如果沒有 .sesstion-item，fallback 到 row 元素
                    if (sessionContainers.length === 0) {{
                        sessionContainers = Array.from(document.querySelectorAll('div#buyTicket > div.row.pa-4'));
                    }}

                    console.log('[TicketPlus] Found session containers:', sessionContainers.length);

                    let matchedContainers = [];

                    // 關鍵字匹配
                    if (originalKeyword && originalKeyword.trim() !== '') {{
                        // 解析關鍵字 - 處理引號包圍和逗號分隔
                        let keywords = [];
                        if (originalKeyword.includes(',')) {{
                            keywords = originalKeyword.split(',')
                                .map(k => k.trim().replace(/^["']|["']$/g, ''))
                                .filter(k => k.length > 0);
                        }} else {{
                            keywords = [originalKeyword.replace(/^["']|["']$/g, '').trim()];
                        }}

                        console.log('[TicketPlus] Parsed keywords:', keywords);

                        // 匹配容器文字
                        for (let i = 0; i < sessionContainers.length; i++) {{
                            const container = sessionContainers[i];
                            const text = container.textContent || '';
                            const normalizedText = text.replace(/[\\s\\u3000]/g, '').toLowerCase();

                            // 檢查是否匹配任一關鍵字
                            for (let keyword of keywords) {{
                                const normalizedKeyword = keyword.replace(/[\\s\\u3000]/g, '').toLowerCase();
                                if (normalizedText.includes(normalizedKeyword)) {{
                                    matchedContainers.push(container);
                                    console.log('[TicketPlus] Keyword "' + keyword + '" matched container ' + i);
                                    console.log('  -> Text preview:', text.substring(0, 100).replace(/\\n/g, ' '));
                                    break;  // 已匹配，檢查下一個容器
                                }}
                            }}
                        }}
                    }} else {{
                        // 無關鍵字，使用所有容器
                        matchedContainers = sessionContainers;
                        console.log('[TicketPlus] No keyword specified, using all', sessionContainers.length, 'containers');
                    }}

                    // T018-T020: Conditional fallback based on date_auto_fallback switch
                    if (matchedContainers.length === 0 && originalKeyword && originalKeyword.trim() !== '') {{
                        if (dateAutoFallback) {{
                            // T018: Fallback enabled
                            console.log('[TicketPlus DATE FALLBACK] date_auto_fallback=true, triggering auto fallback');
                            matchedContainers = sessionContainers;
                        }} else {{
                            // T019: Fallback disabled - strict mode (no selection, will reload)
                            console.log('[TicketPlus DATE FALLBACK] date_auto_fallback=false, fallback is disabled');
                            console.log('[TicketPlus DATE SELECT] No date selected, will reload page and retry');
                            return {{
                                success: false,
                                error: 'No keyword matches and fallback is disabled',
                                strict_mode: true
                            }};
                        }}
                    }}

                    if (matchedContainers.length === 0) {{
                        console.log('[TicketPlus ERROR] No session containers found');
                        return {{
                            success: false,
                            error: 'No session containers found',
                            debug: {{
                                keyword: originalKeyword,
                                mode: autoSelectMode,
                                totalContainers: sessionContainers.length
                            }}
                        }};
                    }}

                    // 根據模式選擇目標容器
                    let targetIndex = 0;
                    if (autoSelectMode === 'from bottom to top') {{
                        targetIndex = matchedContainers.length - 1;
                    }} else if (autoSelectMode === 'center') {{
                        targetIndex = Math.floor(matchedContainers.length / 2);
                    }} else if (autoSelectMode === 'random') {{
                        targetIndex = Math.floor(Math.random() * matchedContainers.length);
                    }}

                    let targetContainer = matchedContainers[targetIndex];
                    const containerText = (targetContainer.textContent || '').substring(0, 150).replace(/\\n/g, ' ');
                    console.log('[TicketPlus TARGET] Selected container [' + targetIndex + '/' + matchedContainers.length + ']');
                    console.log('  -> Preview:', containerText);

                    // 在容器內查找購買按鈕
                    let buyButton = targetContainer.querySelector('button.nextBtn');
                    if (!buyButton) {{
                        buyButton = targetContainer.querySelector('button');
                    }}

                    if (!buyButton) {{
                        console.log('[TicketPlus ERROR] No buy button found in container');
                        return {{
                            success: false,
                            error: 'No buy button found in container',
                            targetText: containerText
                        }};
                    }}

                    const buttonText = buyButton.textContent || '';
                    console.log('[TicketPlus BUTTON] Found button:', buttonText);

                    // 點擊按鈕
                    try {{
                        const event = new MouseEvent('click', {{
                            bubbles: true,
                            cancelable: true,
                            view: window
                        }});
                        buyButton.dispatchEvent(event);
                        console.log('[TicketPlus SUCCESS] Button clicked successfully');
                        return {{
                            success: true,
                            action: 'button_clicked',
                            matchedCount: matchedContainers.length,
                            targetText: containerText,
                            buttonText: buttonText
                        }};
                    }} catch (e) {{
                        console.log('[TicketPlus ERROR] Click failed:', e.message);
                        return {{
                            success: false,
                            error: 'Click failed: ' + e.message,
                            targetText: containerText
                        }};
                    }}
                }})();
            ''')

            # 使用 NoDriver 結果解析器
            parsed_result = util.parse_nodriver_result(click_result)

            if isinstance(parsed_result, dict) and parsed_result.get('success'):
                if show_debug_message:
                    print(f"Date selection and click successful: {parsed_result.get('action', 'unknown')}")
                    print(f"   目標文字: {parsed_result.get('targetText', '')}")
                is_date_clicked = True
            else:
                if show_debug_message:
                    print(f"Date selection and click failed: {parsed_result.get('error', 'unknown') if isinstance(parsed_result, dict) else str(parsed_result)}")

        except Exception as exc:
            if show_debug_message:
                print("JavaScript date selection click failed:", exc)
    else:
        # Provide accurate error message based on actual condition
        if show_debug_message:
            if not is_vue_ready:
                print("[TicketPlus DATE] Vue.js not ready, waiting for page to load...")
            elif not formated_area_list or len(formated_area_list) == 0:
                print("[TicketPlus DATE] No available tickets (all sold out), waiting for refresh...")
            else:
                print("[TicketPlus DATE] Unknown condition, skip clicking")

        # Auto reload when no available tickets and auto_reload_coming_soon_page is enabled
        if auto_reload_coming_soon_page_enable and is_vue_ready and (not formated_area_list or len(formated_area_list) == 0):
            try:
                reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                if reload_interval > 0:
                    if show_debug_message:
                        print(f"[TicketPlus DATE] Waiting {reload_interval}s before auto-reload...")
                    await asyncio.sleep(reload_interval)
                else:
                    await asyncio.sleep(1.0)  # Default 1 second delay

                await tab.reload()
                if show_debug_message:
                    print("[TicketPlus DATE] Page reloaded, waiting for content...")
                await asyncio.sleep(0.5)
            except Exception as exc:
                if show_debug_message:
                    print(f"[TicketPlus DATE] Auto reload failed: {exc}")

    return is_date_clicked

async def nodriver_ticketplus_unified_select(tab, config_dict, area_keyword):
    """TicketPlus 統一選擇器 - 語言無關的票種/票區選擇"""
    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get('area_auto_fallback', False)  # T021: Safe access for new field
    ticket_number = config_dict["ticket_number"]
    keyword_exclude = config_dict.get("keyword_exclude", "")

    if show_debug_message:
        print(f"Unified selector started - keyword: {area_keyword}, tickets: {ticket_number}")

    is_selected = False

    try:
        # 檢查暫停狀態
        if await check_and_handle_pause(config_dict):
            return False

        # 等待頁面載入
        if await sleep_with_pause_check(tab, 0.6, config_dict):
            if show_debug_message:
                print("Pause check interrupted")
            return False

        # 解析排除關鍵字
        exclude_keywords = []
        if keyword_exclude:
            try:
                # Try JSON format first (standard storage format)
                # Example: "\"輪椅\",\"身障\"" → ["輪椅", "身障"]
                exclude_keywords = json.loads("[" + keyword_exclude + "]")
            except:
                # Fallback: semicolon-separated format (Issue #23)
                if util.CONST_KEYWORD_DELIMITER in keyword_exclude:
                    exclude_keywords = [kw.strip() for kw in keyword_exclude.split(util.CONST_KEYWORD_DELIMITER) if kw.strip()]
                else:
                    # Single keyword
                    exclude_keywords = [keyword_exclude.strip()] if keyword_exclude.strip() else []

        # [FIX] Wait for Vue.js elements to render (expansion panels or count buttons)
        # This is crucial because document.readyState='complete' doesn't mean Vue components are ready
        # Use auto_reload_page_interval * 2 as max wait, minimum 6 seconds, maximum 15 seconds
        auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 5)
        max_vue_wait = max(6.0, min(15.0, auto_reload_interval * 2))
        vue_check_interval = 0.15  # Check every 150ms for faster response
        vue_wait_start = time.time()
        vue_elements_found = False
        last_log_time = 0

        while time.time() - vue_wait_start < max_vue_wait:
            # Check pause status
            if await check_and_handle_pause(config_dict):
                return False

            try:
                vue_check = await tab.evaluate('''
                    (function() {
                        const panels = document.querySelectorAll('.v-expansion-panel').length;
                        const countBtn = document.querySelectorAll('.count-button .mdi-plus').length;
                        const rowTickets = document.querySelectorAll('.row.py-1.py-md-4').length;
                        return {
                            panels: panels,
                            countBtn: countBtn,
                            rowTickets: rowTickets,
                            hasElements: panels > 0 || countBtn > 0 || rowTickets > 0
                        };
                    })();
                ''')

                # Parse NoDriver result format
                if isinstance(vue_check, list):
                    vue_check = {item[0]: item[1].get('value') if isinstance(item[1], dict) else item[1] for item in vue_check}

                # Log every 1 second to reduce noise
                elapsed = time.time() - vue_wait_start
                if show_debug_message and elapsed - last_log_time >= 1.0:
                    print(f"[VUE WAIT] {elapsed:.1f}s - panels:{vue_check.get('panels', 0)}, countBtn:{vue_check.get('countBtn', 0)}, rowTickets:{vue_check.get('rowTickets', 0)}")
                    last_log_time = elapsed

                if vue_check.get('hasElements', False):
                    vue_elements_found = True
                    if show_debug_message:
                        print(f"[VUE WAIT] Vue elements found after {elapsed:.1f}s")
                    # Small delay to ensure Vue fully rendered
                    await asyncio.sleep(0.1)
                    break

            except Exception as e:
                if show_debug_message:
                    print(f"[VUE WAIT] Check error: {e}")

            await asyncio.sleep(vue_check_interval)

        if not vue_elements_found:
            if show_debug_message:
                print(f"[VUE WAIT] Timeout after {max_vue_wait:.1f}s, Vue elements not found")
            # Return early - no point continuing if no elements found
            return False

        # 統一的結構化判斷與選擇邏輯 (同步版本，避免 NoDriver async 問題)
        js_result = await tab.evaluate(f'''
            (function() {{
                const keyword = '{area_keyword}';
                const ticketNumber = {ticket_number};
                const autoSelectMode = '{auto_select_mode}';
                const areaAutoFallback = {'true' if area_auto_fallback else 'false'};
                const keywordArray = keyword.split(' ');
                const keyword1 = keywordArray[0] || '';
                const keyword2 = keywordArray[1] || '';
                const excludeKeywords = {exclude_keywords};

                console.log('Unified selector execution - keyword:', keyword, 'tickets:', ticketNumber, 'mode:', autoSelectMode, 'fallback:', areaAutoFallback);

                // 檢查是否售罄
                function isSoldOut(element) {{
                    const text = element.textContent || '';
                    const soldOutPatterns = [/剩餘\s*0(?!\d)/, /剩餘\s*:\s*0(?!\d)/, /sold\s*out/i, /售完/, /已售完/, /售罄/, /無庫存/];
                    const availablePatterns = [/熱賣中/, /熱賣/, /熱售/, /可購買/, /available/i, /剩餘\s*[1-9]\d*/];

                    for (let pattern of soldOutPatterns) {{
                        if (pattern.test(text)) {{
                            for (let avail of availablePatterns) {{
                                if (avail.test(text)) return false;
                            }}
                            return true;
                        }}
                    }}
                    return false;
                }}

                // 檢查是否包含排除關鍵字
                function containsExcludeKeywords(name) {{
                    if (!excludeKeywords || excludeKeywords.length === 0) return false;
                    for (let kw of excludeKeywords) {{
                        if (kw && name.includes(kw)) return true;
                    }}
                    return false;
                }}

                // 計算目標索引
                function getTargetIndex(items, mode) {{
                    const count = items.length;
                    if (count === 0) return -1;
                    switch(mode) {{
                        case 'from top to bottom': return 0;
                        case 'from bottom to top': return count - 1;
                        case 'center': return Math.floor((count - 1) / 2);
                        case 'random': return Math.floor(Math.random() * count);
                        default: return 0;
                    }}
                }}

                // 結構化判斷頁面類型
                const hasExpansionPanel = document.querySelector('.v-expansion-panel');
                const hasCountButton = document.querySelector('.count-button .mdi-plus');

                console.log('hasExpansionPanel:', !!hasExpansionPanel, 'hasCountButton:', !!hasCountButton);

                // 類型1: 展開面板型
                if (hasExpansionPanel) {{
                    const panels = document.querySelectorAll('.v-expansion-panel');
                    const validPanels = [];

                    for (let i = 0; i < panels.length; i++) {{
                        const panel = panels[i];
                        const nameEl = panel.querySelector('.v-expansion-panel-header');
                        if (nameEl) {{
                            const name = nameEl.textContent.trim().replace(/\s+/g, ' ');
                            if (!isSoldOut(panel) && !containsExcludeKeywords(name)) {{
                                validPanels.push({{ panel, name, index: i }});
                            }}
                        }}
                    }}

                    console.log('Valid panels:', validPanels.length);
                    if (validPanels.length === 0) {{
                        return {{ success: false, message: 'No valid panels' }};
                    }}

                    // 選擇目標面板
                    let target = null;
                    if (keyword1) {{
                        target = validPanels.find(p => p.name.includes(keyword1) && (!keyword2 || p.name.includes(keyword2)));
                    }}
                    if (!target && keyword1 && !areaAutoFallback) {{
                        return {{ success: false, strict_mode: true }};
                    }}
                    if (!target) {{
                        const idx = getTargetIndex(validPanels, autoSelectMode);
                        target = validPanels[idx];
                    }}

                    if (!target) {{
                        return {{ success: false, message: 'No target panel' }};
                    }}

                    // 展開面板
                    const header = target.panel.querySelector('.v-expansion-panel-header');
                    const isExpanded = target.panel.classList.contains('v-expansion-panel--active');
                    if (!isExpanded && header) {{
                        console.log('Clicking to expand:', target.name);
                        header.click();
                    }}

                    // 立即嘗試找加號按鈕（面板可能已經展開或很快展開）
                    let plusBtn = target.panel.querySelector('.mdi-plus') ||
                                  target.panel.querySelector('.count-button .mdi-plus');

                    if (plusBtn) {{
                        console.log('Found plus button, clicking', ticketNumber, 'times');
                        for (let j = 0; j < ticketNumber; j++) {{
                            plusBtn.click();
                        }}
                        return {{ success: true, type: 'expansion_panel', selected: target.name, clicked: true }};
                    }}

                    // 沒找到加號，返回需要重試的狀態
                    return {{ success: true, type: 'expansion_panel', selected: target.name, clicked: false, needRetry: true }};

                }} else if (hasCountButton) {{
                    // 類型2: 直接有加減按鈕
                    const rows = document.querySelectorAll('.row.py-1.py-md-4');
                    const validRows = [];

                    for (let row of rows) {{
                        const plusBtn = row.querySelector('.count-button .mdi-plus');
                        if (!plusBtn) continue;

                        const nameEl = row.querySelector('.font-weight-medium');
                        if (nameEl) {{
                            const name = nameEl.textContent.trim();
                            if (!isSoldOut(row) && !containsExcludeKeywords(name)) {{
                                validRows.push({{ row, name, plusBtn }});
                            }}
                        }}
                    }}

                    console.log('Valid rows:', validRows.length);
                    if (validRows.length === 0) {{
                        return {{ success: false, message: 'No valid rows' }};
                    }}

                    // 選擇目標
                    let target = null;
                    if (keyword1) {{
                        target = validRows.find(r => r.name.includes(keyword1) && (!keyword2 || r.name.includes(keyword2)));
                    }}
                    if (!target && keyword1 && !areaAutoFallback) {{
                        return {{ success: false, strict_mode: true }};
                    }}
                    if (!target) {{
                        const idx = getTargetIndex(validRows, autoSelectMode);
                        target = validRows[idx];
                    }}

                    if (target && target.plusBtn) {{
                        console.log('Clicking plus button for:', target.name);
                        for (let j = 0; j < ticketNumber; j++) {{
                            target.plusBtn.click();
                        }}
                        return {{ success: true, type: 'count_button', selected: target.name, clicked: true }};
                    }}
                }}

                return {{ success: false, message: 'No selectable elements found' }};
            }})();
        ''')

        # 增加詳細除錯日誌
        if show_debug_message:
            print(f"[DEBUG] Raw JS result type: {type(js_result)}")
            print(f"[DEBUG] Raw JS result value: {js_result}")

        result = util.parse_nodriver_result(js_result)

        if show_debug_message:
            print(f"[DEBUG] Parsed result type: {type(result)}")
            print(f"[DEBUG] Parsed result value: {result}")

        if isinstance(result, dict):
            is_selected = result.get('success', False) and result.get('clicked', False)

            # 處理需要重試的情況（展開面板後等待加號按鈕出現）
            if result.get('needRetry', False):
                if show_debug_message:
                    print(f"[RETRY] Panel expanded but plus button not found, retrying...")

                # 等待面板展開動畫完成
                await asyncio.sleep(0.3)

                # 重試點擊加號按鈕
                for retry in range(5):  # 最多重試 5 次
                    retry_result = await tab.evaluate(f'''
                        (function() {{
                            const panels = document.querySelectorAll('.v-expansion-panel');
                            for (let panel of panels) {{
                                if (panel.classList.contains('v-expansion-panel--active')) {{
                                    const plusBtn = panel.querySelector('.mdi-plus') ||
                                                   panel.querySelector('.count-button .mdi-plus');
                                    if (plusBtn) {{
                                        console.log('Retry: Found plus button');
                                        for (let j = 0; j < {ticket_number}; j++) {{
                                            plusBtn.click();
                                        }}
                                        return {{ success: true, clicked: true }};
                                    }}
                                }}
                            }}
                            return {{ success: false, clicked: false }};
                        }})();
                    ''')

                    retry_parsed = util.parse_nodriver_result(retry_result)
                    if isinstance(retry_parsed, dict) and retry_parsed.get('clicked', False):
                        if show_debug_message:
                            print(f"[RETRY] Success on attempt {retry + 1}")
                        is_selected = True
                        break

                    await asyncio.sleep(0.2)

            if show_debug_message:
                if is_selected:
                    selected_type = result.get('type', '')
                    selected_name = result.get('selected', '')
                    print(f"Selection successful - type: {selected_type}, item: {selected_name}")
                else:
                    print(f"Selection failed: {result.get('message', 'unknown error')}")
        else:
            if show_debug_message:
                print(f"Unified selector returned invalid result: {result}")
            is_selected = False

    except Exception as exc:
        if show_debug_message:
            import traceback
            print(f"Unified selector exception error: {exc}")
            print(f"Exception type: {type(exc).__name__}")
            print(f"Traceback: {traceback.format_exc()}")
        is_selected = False

    # Fallback logic: if selector fails, check page status to decide whether to continue
    if not is_selected:
        try:
            if show_debug_message:
                print("Checking page status to decide whether to continue...")

            # Check if ticket count is set and next button is enabled
            page_status = await tab.evaluate('''
                (function() {
                    // Check if ticket count is set (number in expanded panel is not 0)
                    const ticketCounts = document.querySelectorAll('.count-button div');
                    let hasTickets = false;
                    for (let count of ticketCounts) {
                        const text = count.textContent.trim();
                        if (text && !isNaN(text) && parseInt(text) > 0) {
                            hasTickets = true;
                            break;
                        }
                    }

                    // Check if next button is enabled
                    const nextBtn = document.querySelector('button.nextBtn');
                    const buttonEnabled = nextBtn && !nextBtn.disabled && !nextBtn.classList.contains('v-btn--disabled') && !nextBtn.classList.contains('disabledBtn');

                    return {
                        hasTickets: hasTickets,
                        buttonEnabled: buttonEnabled,
                        buttonText: nextBtn ? nextBtn.textContent.trim() : '',
                        canContinue: hasTickets && buttonEnabled
                    };
                })();
            ''')

            status = util.parse_nodriver_result(page_status)
            if isinstance(status, dict):
                if show_debug_message:
                    print(f"[STATUS] Page state: Has tickets={status.get('hasTickets', False)}, Button enabled={status.get('buttonEnabled', False)}")

                if status.get('canContinue', False):
                    if show_debug_message:
                        print("Page status is good, considered selection successful")
                    is_selected = True

        except Exception as backup_exc:
            if show_debug_message:
                print(f"Backup check failed: {backup_exc}")

    return is_selected

async def nodriver_ticketplus_click_next_button_unified(tab, config_dict):
    """TicketPlus 統一下一步按鈕點擊器 - 不依賴 layout_style"""
    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print("Unified next button clicker started")

    try:
        # 先等待較長時間讓按鈕狀態更新（特別是展開面板後）
        if await sleep_with_pause_check(tab, 0.6, config_dict):
            return False

        js_result = await tab.evaluate('''
            (function() {
                console.log('[NEXT BUTTON] 統一下一步按鈕點擊器執行');

                // 等待按鈕狀態更新的函數
                function waitForButtonEnable(selector, maxWait = 10000) {
                    return new Promise((resolve) => {
                        const startTime = Date.now();
                        const checkButton = () => {
                            const button = document.querySelector(selector);
                            if (button && !button.disabled && !button.classList.contains('v-btn--disabled') && !button.classList.contains('disabledBtn')) {
                                resolve(button);
                                return;
                            }

                            if (Date.now() - startTime < maxWait) {
                                setTimeout(checkButton, 100);
                            } else {
                                resolve(null);
                            }
                        };
                        checkButton();
                    });
                }

                // 嘗試多種可能的下一步按鈕選擇器
                const buttonSelectors = [
                    'button.nextBtn:not(.disabledBtn):not(.v-btn--disabled)',
                    '.order-footer button.nextBtn:not(.disabledBtn)',
                    '.order-footer .v-btn--has-bg:not(.v-btn--disabled):not(.disabledBtn)',
                    'button:contains("下一步"):not(.disabledBtn)',
                    'button:contains("Next"):not(.disabledBtn)',
                    '.nextBtn:not([disabled])'
                ];

                // 首先嘗試直接找到啟用的按鈕
                let nextButton = null;
                for (let selector of buttonSelectors) {
                    nextButton = document.querySelector(selector);
                    if (nextButton && !nextButton.disabled && !nextButton.classList.contains('v-btn--disabled') && !nextButton.classList.contains('disabledBtn')) {
                        console.log('[SUCCESS] 找到啟用的下一步按鈕:', selector);
                        break;
                    }
                }

                // 如果沒有找到啟用的按鈕，等待一下
                if (!nextButton) {
                    console.log('[WAITING] 等待下一步按鈕啟用...');
                    return waitForButtonEnable('button.nextBtn, .nextBtn').then(button => {
                        if (button) {
                            console.log('[SUCCESS] 下一步按鈕已啟用');
                            button.click();
                            return {
                                success: true,
                                message: '下一步按鈕已點擊（等待後）',
                                buttonText: button.textContent.trim()
                            };
                        } else {
                            console.log('[ERROR] 等待後仍未找到可用的下一步按鈕');
                            return { success: false, message: '等待後仍未找到可用的下一步按鈕' };
                        }
                    });
                }

                // 點擊按鈕
                nextButton.click();
                console.log('[SUCCESS] 下一步按鈕已點擊');

                return {
                    success: true,
                    message: '下一步按鈕已點擊',
                    buttonText: nextButton.textContent.trim()
                };
            })();
        ''')

        result = util.parse_nodriver_result(js_result)
        if isinstance(result, dict):
            success = result.get('success', False)
            if show_debug_message:
                if success:
                    button_text = result.get('buttonText', '')
                    print(f"[SUCCESS] Next button clicked successfully - Button text: {button_text}")
                else:
                    print(f"[ERROR] Next button click failed: {result.get('message', 'Unknown error')}")
            return success

    except Exception as exc:
        if show_debug_message:
            print(f"Unified next button click error: {exc}")

    return False


# NOTE: nodriver_ticketplus_order_expansion_auto_select and _set_expansion_panel_tickets
# removed - functionality merged into nodriver_ticketplus_unified_select (line 6887)

async def nodriver_ticketplus_ticket_agree(tab, config_dict):
    """TicketPlus 同意條款勾選功能"""
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_finish_checkbox_click = False

    # 查找同意條款 checkbox
    try:
        agree_checkbox_list = await tab.query_selector_all('input[type="checkbox"]')

        for checkbox in agree_checkbox_list:
            try:
                # 檢查 checkbox 是否為 None 或無效
                if not checkbox:
                    continue

                # 檢查 checkbox 是否已勾選
                is_checked = await checkbox.evaluate('el => el.checked')

                if not is_checked:
                    # 嘗試點擊勾選
                    await checkbox.click()

                    # 確認是否勾選成功
                    is_checked_after = await checkbox.evaluate('el => el.checked')
                    if is_checked_after:
                        is_finish_checkbox_click = True
                        if show_debug_message:
                            print("successfully checked agreement checkbox")
                    else:
                        # 如果直接點擊失敗，嘗試 JavaScript 方式
                        if checkbox:  # 再次確認 checkbox 不是 None
                            await tab.evaluate('''
                                (checkbox) => {
                                    if (checkbox) {
                                        checkbox.checked = true;
                                        checkbox.dispatchEvent(new Event('change', {bubbles: true}));
                                    }
                                }
                            ''', checkbox)

                            final_check = await checkbox.evaluate('el => el.checked')
                            if final_check:
                                is_finish_checkbox_click = True
                                if show_debug_message:
                                    print("successfully checked agreement checkbox via JS")
                else:
                    is_finish_checkbox_click = True
                    if show_debug_message:
                        print("agreement checkbox already checked")

            except Exception as exc:
                if show_debug_message:
                    print("process checkbox fail:", exc)
                continue

    except Exception as exc:
        if show_debug_message:
            print("find agreement checkbox fail:", exc)

    return is_finish_checkbox_click

async def nodriver_ticketplus_accept_realname_card(tab):
    """接受實名制卡片彈窗"""
    is_button_clicked = False
    try:
        # 查找並點擊實名制確認按鈕
        button = await tab.query_selector('div.v-dialog__content > div > div > div > div.row > div > button.primary')
        if button:
            await button.click()
            is_button_clicked = True
    except Exception as exc:
        pass
    return is_button_clicked

async def nodriver_ticketplus_accept_other_activity(tab):
    """接受其他活動彈窗"""
    is_button_clicked = False
    try:
        # 查找並點擊其他活動確認按鈕
        button = await tab.query_selector('div[role="dialog"] > div.v-dialog > button.primary-1 > span > i.v-icon')
        if button:
            await button.click()
            is_button_clicked = True
    except Exception as exc:
        pass
    return is_button_clicked

async def nodriver_ticketplus_accept_order_fail(tab):
    """處理訂單失敗彈窗"""
    is_button_clicked = False
    try:
        # 查找並點擊訂單失敗確認按鈕
        button = await tab.query_selector('div[role="dialog"] > div.v-dialog > div.v-card > div > div.row > div.col > button.v-btn')
        if button:
            await button.click()
            is_button_clicked = True
    except Exception as exc:
        pass
    return is_button_clicked

async def check_and_handle_pause(config_dict=None):
    """檢查暫停檔案並處理暫停狀態"""
    if os.path.exists(CONST_MAXBOT_INT28_FILE):
        return True
    return False

# === 暫停機制改進：增強版暫停檢查函數 ===
# 為了讓 NoDriver 的暫停功能接近 Chrome 版本的即時反應性，
# 新增以下輔助函數在關鍵操作點檢查暫停狀態：
# 1. sleep_with_pause_check: tab.sleep() 的暫停檢查版本
# 2. asyncio_sleep_with_pause_check: asyncio.sleep() 的暫停檢查版本
# 3. evaluate_with_pause_check: JavaScript 執行前的暫停檢查版本
# 4. with_pause_check: 任務包裝器，支援中途暫停

async def sleep_with_pause_check(tab, seconds, config_dict=None):
    """延遲等待並檢查暫停狀態"""
    if await check_and_handle_pause(config_dict):
        return True  # 暫停中
    await tab.sleep(seconds)
    return False  # 未暫停

async def asyncio_sleep_with_pause_check(seconds, config_dict=None):
    """asyncio.sleep 並檢查暫停狀態"""
    import asyncio
    if await check_and_handle_pause(config_dict):
        return True  # 暫停中
    await asyncio.sleep(seconds)
    return False  # 未暫停

async def evaluate_with_pause_check(tab, javascript_code, config_dict=None):
    """執行 JavaScript 前檢查暫停狀態"""
    if await check_and_handle_pause(config_dict):
        return None  # 暫停中，返回 None
    try:
        result = await tab.evaluate(javascript_code)
        return result
    except Exception as exc:
        # Always print JS execution errors for debugging
        print(f"[JS ERROR] JavaScript execution failed: {exc}")
        import traceback
        traceback.print_exc()
        return None

async def with_pause_check(task_func, config_dict, *args, **kwargs):
    """包裝函數，支援暫停中斷機制"""
    import asyncio

    # 先檢查一次暫停狀態
    if await check_and_handle_pause(config_dict):
        return None

    # 創建任務但不立即等待
    task = asyncio.create_task(task_func(*args, **kwargs))

    # 在任務執行過程中定期檢查暫停狀態
    while not task.done():
        if await check_and_handle_pause(config_dict):
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass
            return None
        await asyncio.sleep(0.05)  # 每 50ms 檢查一次

    return await task

async def nodriver_ticketplus_check_queue_status(tab, config_dict, force_show_debug=False):
    """檢查排隊狀態 - 優化版，避免重複輸出"""
    show_debug_message = config_dict["advanced"].get("verbose", False) or force_show_debug

    try:
        result = await tab.evaluate('''
            (function() {
                // 檢查排隊中的關鍵字
                const queueKeywords = [
                    '排隊購票中',
                    '請稍候',
                    '請別離開頁面',
                    '請勿離開',
                    '請勿關閉網頁',
                    '同時使用多個裝置',
                    '視窗購票',
                    '正在處理',
                    '處理中'
                ];

                const bodyText = document.body.textContent || '';

                // 檢查是否包含任何排隊關鍵字
                const hasQueueKeyword = queueKeywords.some(keyword => bodyText.includes(keyword));

                // 檢查是否有遮罩層（排隊中的視覺指示）
                const overlayScrim = document.querySelector('.v-overlay__scrim');
                const hasOverlay = overlayScrim &&
                    (overlayScrim.style.opacity === '1' ||
                     overlayScrim.style.display !== 'none');

                // 檢查對話框中的排隊訊息
                const dialogText = document.querySelector('.v-dialog')?.textContent || '';
                const hasQueueDialog = dialogText.includes('排隊') ||
                                       dialogText.includes('請稍候');

                // 返回匹配的關鍵字列表（字串格式）
                const foundKeywords = queueKeywords.filter(keyword => bodyText.includes(keyword));

                return {
                    inQueue: hasQueueKeyword || hasOverlay || hasQueueDialog,
                    queueTitle: '',
                    foundKeywords: foundKeywords,
                    hasOverlay: hasOverlay,
                    hasQueueDialog: hasQueueDialog,
                    dialogText: hasQueueDialog ? dialogText.trim() : ''
                };
            })();
        ''')

        result = util.parse_nodriver_result(result)

        if isinstance(result, dict):
            is_in_queue = result.get('inQueue', False)
            # Only output detailed info on forced display or first detection
            if show_debug_message and is_in_queue and force_show_debug:
                print(f"[QUEUE] Queue status detected")
                if result.get('hasOverlay'):
                    print("   Overlay scrim found (v-overlay__scrim)")
                if result.get('hasQueueDialog'):
                    print(f"   Dialog content: {result.get('dialogText', '')}")
                if result.get('foundKeywords'):
                    keywords = result.get('foundKeywords', [])
                    # Handle possible dict format (NoDriver special return)
                    if keywords and isinstance(keywords[0], dict):
                        keywords = [str(k.get('value', k)) for k in keywords]
                    elif keywords:
                        keywords = [str(k) for k in keywords]  # Ensure all are strings
                    if keywords:
                        print(f"   Keywords found: {', '.join(keywords)}")
            return is_in_queue

        return False

    except Exception as exc:
        if show_debug_message:
            print(f"Queue status check error: {exc}")
        return False

async def nodriver_ticketplus_confirm(tab, config_dict):
    """確認訂單頁面處理"""
    # 先確認勾選同意條款
    is_checkbox_checked = await nodriver_ticketplus_ticket_agree(tab, config_dict)

    # 查找並點擊確認按鈕
    is_confirm_clicked = False
    if is_checkbox_checked:
        try:
            # 嘗試找到確認訂單按鈕
            confirm_button = await tab.query_selector('button.v-btn.primary')
            if not confirm_button:
                confirm_button = await tab.query_selector('button[type="submit"]')

            if confirm_button:
                # 檢查按鈕是否可用
                is_enabled = await tab.evaluate('''
                    (function(button) {
                        return button && !button.disabled && button.offsetParent !== null;
                    })(arguments[0]);
                ''', confirm_button)

                if is_enabled:
                    await confirm_button.click()
                    is_confirm_clicked = True
        except Exception as exc:
            pass

    return is_confirm_clicked

async def nodriver_ticketplus_order(tab, config_dict, ocr, Captcha_Browser, ticketplus_dict):
    """TicketPlus 訂單處理 - 支援三種佈局偵測"""

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # 檢查是否已經成功選票，避免重複執行
    if ticketplus_dict.get("is_ticket_assigned", False):
        if show_debug_message:
            print("Ticket selection completed, skipping duplicate execution")
        return ticketplus_dict

    if show_debug_message:
        print("=== TicketPlus Auto Layout Detection Started ===")

    # Wait for page load to complete, with sufficient delay for Vue.js initialization
    # Reduced to 0.8-1.5s since initial delay (1.5-2.0s) has already been applied at order page entry
    # This prevents excessive waiting while maintaining stability
    if await sleep_with_pause_check(tab, random.uniform(0.8, 1.5), config_dict):
        if show_debug_message:
            print("Paused during page wait")
        return ticketplus_dict

    # 偵測頁面佈局樣式（包含暫停檢查）
    layout_info = await nodriver_ticketplus_detect_layout_style(tab, config_dict)

    # 檢查是否在佈局偵測時暫停
    if layout_info and layout_info.get('paused'):
        if show_debug_message:
            print("Paused during layout detection")
        return ticketplus_dict

    current_layout_style = layout_info.get('style', 0) if isinstance(layout_info, dict) else 0

    if show_debug_message:
        layout_names = {1: "展開面板型 (Page4)", 2: "座位選擇型 (Page2)", 3: "簡化型 (Page1/Page3)"}
        button_status = "啟用" if layout_info.get('button_enabled', False) else "禁用"
        print(f"Detected layout style: {current_layout_style} - {layout_names.get(current_layout_style, 'Unknown')}")
        print(f"Layout detection details: Button found={layout_info.get('found', False)}, Button status={button_status}")
        if layout_info.get('debug_info'):
            print(f"Layout detection debug: {layout_info.get('debug_info')}")

    # 檢查下一步按鈕是否啟用
    is_button_enabled = await nodriver_ticketplus_check_next_button(tab)

    if show_debug_message:
        print(f"Next button status: {'Enabled' if is_button_enabled else 'Disabled'}")

    # 檢查是否需要選票
    is_price_assign_by_bot = False

    # 獲取關鍵字設定（修正讀取路徑）
    area_keyword_raw = config_dict.get("area_auto_select", {}).get("area_keyword", "").strip()

    # Parse keywords using JSON to avoid splitting keywords containing commas (e.g., "5,600")
    # Format: "\"keyword1\",\"keyword2\"" → ['keyword1', 'keyword2']
    # Multiple keywords use OR logic (try each one sequentially - Early Return Pattern)
    keyword_array = util.parse_keyword_string_to_array(area_keyword_raw)

    if show_debug_message:
        print(f"[TicketPlus] Parsed keywords: {keyword_array}")
        print(f"[TicketPlus] Total keyword groups: {len(keyword_array)}")

    # 總是執行票數選擇（TicketPlus 按鈕可以在票數為 0 時啟用）
    need_select_ticket = True

    if show_debug_message:
        print(f"Ticket selection is always required (TicketPlus quirk)")

    # Early Return Pattern: Try each keyword in order until one succeeds
    is_price_assign_by_bot = False
    keyword_matched = False

    if len(keyword_array) > 0:
        # Try each keyword sequentially (OR logic)
        for keyword_index, area_keyword_item in enumerate(keyword_array):
            if show_debug_message:
                print(f"[TicketPlus AREA KEYWORD] Trying keyword #{keyword_index + 1}/{len(keyword_array)}: '{area_keyword_item}'")

            # Try this keyword
            is_price_assign_by_bot = await nodriver_ticketplus_unified_select(tab, config_dict, area_keyword_item)

            if is_price_assign_by_bot:
                # Success! Stop trying other keywords (Early Return)
                keyword_matched = True
                if show_debug_message:
                    print(f"[TicketPlus AREA KEYWORD] Keyword #{keyword_index + 1} matched: '{area_keyword_item}' ✓")
                break  # Early return - stop trying subsequent keywords

            # This keyword failed, try next one
            if show_debug_message:
                print(f"[TicketPlus AREA KEYWORD] Keyword #{keyword_index + 1} failed, trying next...")

        # All keywords failed
        if not keyword_matched and show_debug_message:
            print(f"[TicketPlus AREA KEYWORD] All {len(keyword_array)} keywords failed to match")
    else:
        # No keyword specified, use auto select mode
        if show_debug_message:
            print(f"[TicketPlus AREA KEYWORD] No keyword specified, using auto select mode")
        is_price_assign_by_bot = await nodriver_ticketplus_unified_select(tab, config_dict, "")

    is_need_refresh = not is_price_assign_by_bot  # 如果選擇失敗則需要刷新

    # 如果票種選擇成功，處理後續步驟
    if is_price_assign_by_bot:
        # 檢查暫停狀態
        if await check_and_handle_pause(config_dict):
            return ticketplus_dict

        if show_debug_message:
            print("Ticket selection successful, processing discount code and submit")

        # 處理優惠碼
        is_answer_sent, ticketplus_dict["fail_list"], is_question_popup = await nodriver_ticketplus_order_exclusive_code(tab, config_dict, ticketplus_dict["fail_list"])

        # 提交表單（包含暫停檢查）
        if await sleep_with_pause_check(tab, 0.3, config_dict):
            if show_debug_message:
                print("Paused before form submission")
            return ticketplus_dict
        await nodriver_ticketplus_ticket_agree(tab, config_dict)

        # 使用統一的下一步按鈕點擊邏輯
        is_form_submitted = await nodriver_ticketplus_click_next_button_unified(tab, config_dict)

        if is_form_submitted:
            # 隨機等待 5-10 秒讓排隊狀態初始化（避免固定時間被偵測）
            await tab.sleep(random.uniform(5.0, 10.0))
            # 注意：不在此處標記 is_ticket_assigned，避免重載時跳過選票邏輯
            # 應在進入 /confirm/ 頁面後才標記（見 nodriver_ticketplus_main line ~5882）

            # 檢查是否進入排隊狀態
            is_in_queue = await nodriver_ticketplus_check_queue_status(tab, config_dict, force_show_debug=False)
            if is_in_queue:
                if show_debug_message:
                    print("Entered queue monitoring (check every 5 seconds, display only on status change)")

                # 進入排隊監控循環，每5秒檢查一次，無時間上限
                last_url = ""

                while True:
                    # 檢查暫停狀態
                    if await check_and_handle_pause(config_dict):
                        break

                    try:
                        current_url = tab.url

                        # 檢查是否進入確認頁面，如果是則跳出排隊監控
                        if '/confirm/' in current_url.lower() or '/confirmseat/' in current_url.lower():
                            if show_debug_message:
                                print("Detected entry to confirmation page, exiting queue monitoring")
                            # 不自動建立暫停檔案，讓程式繼續處理確認頁面
                            break

                        # 僅在 URL 變化時顯示狀態（移除重複的排隊檢查訊息）
                        if show_debug_message and current_url != last_url:
                            print(f"Page status update - URL: {current_url}")
                            last_url = current_url

                        # 檢查是否已經跳出排隊狀態（不顯示重複的偵測訊息）
                        is_still_in_queue = await nodriver_ticketplus_check_queue_status(tab, config_dict, force_show_debug=False)

                        if not is_still_in_queue:
                            # 檢查是否進入確認頁面
                            if '/confirm/' in current_url.lower() or '/confirmseat/' in current_url.lower():
                                if show_debug_message:
                                    print("Queue ended, entered confirmation page")
                                # 不自動建立暫停檔案，讓程式繼續處理確認頁面
                                break
                            else:
                                if show_debug_message:
                                    print("[QUEUE END] Queue ended, continuing page processing")
                                break

                        # Random wait 5-10 seconds before next check (prevent fixed frequency detection)
                        await tab.sleep(random.uniform(5.0, 10.0))

                    except Exception as exc:
                        if show_debug_message:
                            print(f"Queue monitoring error: {exc}")
                        break

                # Queue monitoring completed (exited via other conditions)

        if show_debug_message:
            print(f"Form submission: {'Success' if is_form_submitted else 'Failed'}")
    else:
        if show_debug_message:
            print("Ticket selection failed, cannot continue")

        # 票選擇失敗時自動刷新頁面（等待票區有票）
        # interval=0: 立即刷新, interval>0: 等待N秒後刷新
        auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
        if auto_reload_interval >= 0:
            if auto_reload_interval > 0:
                if show_debug_message:
                    print(f"[AUTO RELOAD] Waiting {auto_reload_interval} seconds before reload...")
                await asyncio.sleep(auto_reload_interval)
            if show_debug_message:
                print("[AUTO RELOAD] Reloading page...")
            try:
                await tab.reload()
            except Exception as reload_exc:
                if show_debug_message:
                    print(f"[AUTO RELOAD] Reload failed: {reload_exc}")

    if show_debug_message:
        print("=== TicketPlus Simplified Booking Ended ===")

    return ticketplus_dict

async def nodriver_ticketplus_wait_for_vue_ready(tab, max_wait_ms=800):
    """Wait for Vue.js ticket area elements to render (dynamic detection).

    Args:
        tab: NoDriver tab
        max_wait_ms: Maximum wait time in milliseconds, default 800ms

    Returns:
        bool: True if Vue.js is ready, False if timed out
    """
    try:
        # Wait for basic page load (DOM needs time to rebuild after reload)
        await asyncio.sleep(0.15)

        result = await tab.evaluate(f'''
            (function() {{
                return new Promise((resolve) => {{
                    const startTime = Date.now();
                    const maxWait = {max_wait_ms};

                    const check = () => {{
                        // TicketPlus ticket area element selectors (in priority order)
                        const selectors = [
                            '.v-expansion-panel-header',  // Expansion panel header (most common)
                            '.order-content .v-btn',      // Order content buttons
                            'button.nextBtn',             // Next step button
                            '.ticket-list button'         // Ticket list buttons
                        ];

                        let hasContent = false;
                        for (const selector of selectors) {{
                            const elements = document.querySelectorAll(selector);
                            if (elements.length > 0) {{
                                // Check if elements contain expected keywords
                                hasContent = Array.from(elements).some(el => {{
                                    const text = el.textContent || '';
                                    return text.includes('NT') ||
                                           text.includes('剩餘') ||
                                           text.includes('熱賣') ||
                                           text.includes('下一步') ||
                                           text.includes('售完');
                                }});
                                if (hasContent) break;
                            }}
                        }}

                        if (hasContent) {{
                            resolve({{ ready: true, elapsed: Date.now() - startTime }});
                        }} else if (Date.now() - startTime < maxWait) {{
                            setTimeout(check, 30);  // Check every 30ms
                        }} else {{
                            resolve({{ ready: false, elapsed: maxWait }});
                        }}
                    }};

                    // Start checking
                    check();
                }});
            }})();
        ''')

        if isinstance(result, dict):
            return result.get('ready', False)
        return False

    except Exception as exc:
        return False

async def nodriver_ticketplus_check_next_button(tab):
    """檢查下一步按鈕是否啟用"""
    try:
        result = await tab.evaluate('''
            (function() {
                // 使用多種選擇器找下一步按鈕
                const selectors = [
                    "div.order-footer button.nextBtn",
                    "button.nextBtn",
                    "button[class*='next']",
                    ".order-footer .nextBtn"
                ];

                for (let selector of selectors) {
                    const btn = document.querySelector(selector);
                    if (btn) {
                        return {
                            found: true,
                            enabled: !btn.disabled && !btn.classList.contains('disabledBtn')
                        };
                    }
                }

                return { found: false, enabled: false };
            })();
        ''')

        result = util.parse_nodriver_result(result)
        return result.get('enabled', False) if isinstance(result, dict) else False

    except Exception as exc:
        return False




async def nodriver_ticketplus_order_exclusive_code(tab, config_dict, fail_list):
    """處理活動專屬代碼（折價券/優惠序號）"""
    show_debug_message = util.get_debug_mode(config_dict)

    # 檢查暫停狀態
    if await check_and_handle_pause(config_dict):
        return False, fail_list, False

    # 讀取折價券代碼設定
    discount_code = config_dict["advanced"].get("discount_code", "").strip()

    # 如果沒有設定折價券代碼，直接跳過
    if not discount_code:
        if show_debug_message:
            print("[DISCOUNT CODE] No discount code configured, skipping")
        return False, fail_list, False

    if show_debug_message:
        print(f"[DISCOUNT CODE] Attempting to fill discount code: {discount_code}")

    try:
        # 轉義 JavaScript 字串，避免注入攻擊
        escaped_discount_code = discount_code.replace("\\", "\\\\").replace("'", "\\'").replace("\n", "\\n").replace("\r", "\\r")

        # 使用 JavaScript 注入填入折價券代碼
        result = await tab.evaluate(f'''
            (function() {{
                const keywords = ['序號', '加購', '優惠'];
                const discountCode = '{escaped_discount_code}';
                let filledCount = 0;

                // 策略 1: 透過標籤文字偵測
                const labelDivs = document.querySelectorAll('.exclusive-code .label');
                for (let label of labelDivs) {{
                    const labelText = label.textContent.trim();
                    const container = label.closest('.exclusive-code');
                    if (!container) continue;

                    const input = container.querySelector('.v-text-field__slot input[type="text"]');

                    // 檢查是否包含任一關鍵字
                    const hasKeyword = keywords.some(keyword => labelText.includes(keyword));
                    if (hasKeyword && input && !input.value) {{
                        input.value = discountCode;
                        input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        filledCount++;
                    }}
                }}

                return {{
                    success: filledCount > 0,
                    filledCount: filledCount
                }};
            }})()
        ''')

        # 處理返回結果（可能是 dict 或其他類型）
        if result:
            # 確保 result 是字典類型
            if isinstance(result, dict):
                success = result.get('success', False)
                filled_count = result.get('filledCount', 0)
            else:
                # 如果返回非 dict，記錄並假設成功
                if show_debug_message:
                    print(f"[DISCOUNT CODE] Unexpected result type: {type(result)}, value: {result}")
                success = True
                filled_count = 1

            if success and filled_count > 0:
                if show_debug_message:
                    print(f"[DISCOUNT CODE] Successfully filled {filled_count} discount code field(s)")
                return True, fail_list, False

        if show_debug_message:
            print("[DISCOUNT CODE] No matching discount code fields found on page")
        return False, fail_list, False

    except Exception as e:
        if show_debug_message:
            print(f"[DISCOUNT CODE] Error filling discount code: {str(e)}")
        return False, fail_list, False

async def nodriver_ticketplus_main(tab, url, config_dict, ocr, Captcha_Browser):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    global ticketplus_dict
    if not 'ticketplus_dict' in globals():
        ticketplus_dict = {}
        ticketplus_dict["fail_list"]=[]
        ticketplus_dict["is_popup_confirm"] = False
        ticketplus_dict["is_ticket_assigned"] = False
        ticketplus_dict["start_time"] = None
        ticketplus_dict["done_time"] = None
        ticketplus_dict["elapsed_time"] = None

    home_url = 'https://ticketplus.com.tw/'
    is_user_signin = False
    # https://ticketplus.com.tw/
    if home_url == url.lower():
        if config_dict["ocr_captcha"]["enable"]:
            domain_name = url.split('/')[2]
            if not Captcha_Browser is None:
                Captcha_Browser.set_domain(domain_name)

        is_user_signin = await nodriver_ticketplus_account_auto_fill(tab, config_dict)

    if is_user_signin:
        # Only redirect if homepage is NOT the main page itself (prevent loop)
        config_homepage = config_dict["homepage"].lower().rstrip('/')
        is_homepage_target = config_homepage in ['https://ticketplus.com.tw', 'ticketplus.com.tw']
        if not is_homepage_target and url.lower() != config_dict["homepage"].lower():
            try:
                await tab.get(config_dict["homepage"])
            except Exception as e:
                pass

    # https://ticketplus.com.tw/activity/XXX
    if '/activity/' in url.lower():
        is_event_page = False
        if len(url.split('/'))==5:
            is_event_page = True

        if is_event_page:
            # 重置確認頁標記（用戶可能取消購票回到活動頁重新刷票）
            ticketplus_dict["is_popup_confirm"] = False
            ticketplus_dict["order_page_visited"] = False  # 同時重置訂票頁訪問標記

            is_button_pressed = await nodriver_ticketplus_accept_realname_card(tab)
            if config_dict["advanced"].get("verbose", False):
                print("Realname Card:", is_button_pressed)

            is_button_pressed = await nodriver_ticketplus_accept_other_activity(tab)
            if config_dict["advanced"].get("verbose", False):
                print("Other Activity:", is_button_pressed)

            if config_dict["date_auto_select"]["enable"]:
                await nodriver_ticketplus_date_auto_select(tab, config_dict)

    # https://ticketplus.com.tw/order/XXX/OOO
    if '/order/' in url.lower():
        is_event_page = False
        if len(url.split('/'))==6:
            is_event_page = True

        if is_event_page:
            ticketplus_dict["start_time"] = time.time()
            show_debug_message = config_dict["advanced"].get("verbose", False)

            # Unified dynamic detection: longer wait for first visit, shorter for reload
            is_first_visit = not ticketplus_dict.get("order_page_visited", False)
            if is_first_visit:
                max_wait = 2000  # First visit: max 2.0s (cold start, more init needed)
                fallback_delay = 0.5  # Fallback delay if detection times out
                ticketplus_dict["order_page_visited"] = True
            else:
                max_wait = 1000  # Reload: max 1.0s (warm start, faster)
                fallback_delay = 0.3  # Shorter fallback for reload

            if show_debug_message:
                visit_type = "First visit" if is_first_visit else "Reload"
                print(f"[VUE INIT] {visit_type}, dynamic detection (max {max_wait}ms)...")

            is_ready = await nodriver_ticketplus_wait_for_vue_ready(tab, max_wait_ms=max_wait)

            if show_debug_message:
                print(f"[VUE INIT] Vue.js ready: {is_ready}")

            # Add fallback delay if detection failed (timed out)
            if not is_ready:
                await asyncio.sleep(fallback_delay)

            is_button_pressed = await nodriver_ticketplus_accept_realname_card(tab)
            is_order_fail_handled = await nodriver_ticketplus_accept_order_fail(tab)

            # 註：自動重載邏輯已移至 nodriver_ticketplus_order() 函數內
            # 當票選擇失敗時（關鍵字匹配的票區無票），會自動刷新頁面

            # 無論是否刷新，都執行訂單處理（展開票區、選票數）
            ticketplus_dict = await nodriver_ticketplus_order(tab, config_dict, ocr, Captcha_Browser, ticketplus_dict)

    else:
        ticketplus_dict["fail_list"]=[]
        ticketplus_dict["is_ticket_assigned"] = False
        ticketplus_dict["start_time"] = None

    # https://ticketplus.com.tw/confirm/xx/oo
    # https://ticketplus.com.tw/confirmseat/xx/oo
    if '/confirm/' in url.lower() or '/confirmseat/' in url.lower():
        is_event_page = False
        if len(url.split('/'))==6:
            is_event_page = True

        if is_event_page:
            ticketplus_dict["is_ticket_assigned"] = True

            if not ticketplus_dict["is_popup_confirm"]:
                ticketplus_dict["is_popup_confirm"] = True

                # 記錄訂票時間（只在首次進入時計算）
                if ticketplus_dict["start_time"]:
                    ticketplus_dict["done_time"] = time.time()
                    ticketplus_dict["elapsed_time"] = ticketplus_dict["done_time"] - ticketplus_dict["start_time"]
                    if config_dict["advanced"].get("verbose", False):
                        print(f"NoDriver TicketPlus booking time: {ticketplus_dict['elapsed_time']:.3f} seconds")

                if config_dict["advanced"].get("verbose", False):
                    print("Entered confirmation page, booking successful")

                if config_dict["advanced"]["play_sound"]["order"]:
                    play_sound_while_ordering(config_dict)
                send_discord_notification(config_dict, "order", "TicketPlus")

                try:
                    await nodriver_ticketplus_confirm(tab, config_dict)
                    if config_dict["advanced"].get("verbose", False):
                        print("Confirmation page processing completed")
                except Exception as exc:
                    if config_dict["advanced"].get("verbose", False):
                        print(f"Confirmation page processing error: {exc}")

            ticketplus_dict["purchase_completed"] = True
        else:
            ticketplus_dict["is_popup_confirm"] = False
    else:
        ticketplus_dict["is_popup_confirm"] = False

async def nodriver_ibon_login(tab, config_dict, driver):
    """
    專門的 ibon 登入函數，整合 cookie 處理、頁面重新載入和登入狀態驗證
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print("=== ibon Auto-Login Started ===")

    # 檢查是否有 ibon cookie 設定
    ibonqware = config_dict["accounts"]["ibonqware"]
    if len(ibonqware) <= 1:
        if show_debug_message:
            print("No ibon cookie configured, skipping auto-login")
        return {'success': False, 'reason': 'no_cookie_configured'}

    if show_debug_message:
        print(f"Setting ibon cookie (NoDriver) with length: {len(ibonqware)}")
        print(f"Cookie contains mem_id: {'mem_id=' in ibonqware}")
        print(f"Cookie contains mem_email: {'mem_email=' in ibonqware}")
        print(f"Cookie contains huiwanTK: {'huiwanTK=' in ibonqware}")
        print(f"Cookie contains ibonqwareverify: {'ibonqwareverify=' in ibonqware}")

    try:
        from nodriver import cdp

        # Set ibon cookie using CDP
        cookie_result = await tab.send(cdp.network.set_cookie(
            name="ibonqware",
            value=ibonqware,
            domain=".ibon.com.tw",
            path="/",
            secure=True,
            http_only=True
        ))

        if show_debug_message:
            print(f"CDP setCookie result: {cookie_result}")
            print("ibon cookie set successfully (NoDriver)")

        # 驗證 cookie 是否設定成功
        updated_cookies = await driver.cookies.get_all()
        ibon_cookies = [c for c in updated_cookies if c.name == 'ibonqware']
        if not ibon_cookies:
            if show_debug_message:
                print("Warning: ibon cookie not found after setting")
            return {'success': False, 'reason': 'cookie_not_set'}

        if show_debug_message:
            print(f"Verified: ibon cookie exists with value length: {len(ibon_cookies[0].value)}")
            print(f"Cookie domain: {ibon_cookies[0].domain}")
            print("[SUCCESS] ibon cookie set successfully")
            print("[INFO] Cookie will be applied when navigating to event page")

        # No page reload needed - cookie is set on homepage,
        # and navigation to event page will automatically apply the cookie
        return {'success': True, 'reason': 'cookie_set'}

    except Exception as cookie_error:
        print(f"Failed to set ibon cookie (NoDriver): {cookie_error}")
        if show_debug_message:
            import traceback
            traceback.print_exc()
        return {'success': False, 'reason': 'exception', 'error': str(cookie_error)}

async def nodriver_fami_login(tab, config_dict, show_debug_message=True):
    """
    FamiTicket 帳號密碼登入

    參考：chrome_tixcraft.py line 6308 (fami_login)
    對應規格：FR-001, FR-002, FR-003, FR-004

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: 登入成功返回 True，失敗返回 False
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    # 讀取帳號密碼（優先使用明碼，若為空則解密）
    fami_account = config_dict["accounts"]["fami_account"].strip()
    fami_password = config_dict["accounts"]["fami_password"].strip()

    if len(fami_account) < 4:
        if show_debug_message:
            print("[FAMI LOGIN] Account is empty or too short")
        return False

    if len(fami_password) == 0:
        if show_debug_message:
            print("[FAMI LOGIN] Password is empty")
        return False

    if show_debug_message:
        print(f"[FAMI LOGIN] Attempting login with account: {fami_account[:3]}***")

    is_login_success = False

    try:
        import random

        # 進入登入頁面後隨機等待 0.8-1.2 秒
        await asyncio.sleep(random.uniform(0.8, 1.2))

        # 記錄當前 URL
        original_url = tab.url if hasattr(tab, 'url') else str(tab.target.url)

        # 檢查帳號欄位是否已有值
        inputed_text = await tab.evaluate('document.querySelector("#usr_act").value')
        if not inputed_text or len(inputed_text) == 0:
            # 使用 NoDriver 原生 send_keys
            account_elem = await tab.query_selector('#usr_act')
            if account_elem:
                await account_elem.click()
                await asyncio.sleep(random.uniform(0.1, 0.2))
                await account_elem.send_keys(fami_account)
                if show_debug_message:
                    print("[FAMI LOGIN] Account filled")
                await asyncio.sleep(random.uniform(0.3, 0.5))
        elif inputed_text == fami_account:
            if show_debug_message:
                print("[FAMI LOGIN] Account already correct")
        else:
            if show_debug_message:
                print(f"[FAMI LOGIN] Account has different value: {inputed_text[:10]}...")

        # 檢查密碼欄位是否已有值
        inputed_pwd = await tab.evaluate('document.querySelector("#usr_pwd").value')
        if not inputed_pwd or len(inputed_pwd) == 0:
            # 使用 NoDriver 原生 send_keys
            password_elem = await tab.query_selector('#usr_pwd')
            if password_elem:
                await password_elem.click()
                await asyncio.sleep(random.uniform(0.1, 0.2))
                await password_elem.send_keys(fami_password)
                if show_debug_message:
                    print(f"[FAMI LOGIN] Password filled (length: {len(fami_password)})")
                await asyncio.sleep(random.uniform(0.3, 0.5))

                # Debug: 檢查實際輸入的值
                actual_pwd = await tab.evaluate('document.querySelector("#usr_pwd").value')
                if show_debug_message:
                    print(f"[FAMI LOGIN] Actual password length in field: {len(actual_pwd) if actual_pwd else 0}")
        else:
            if show_debug_message:
                print("[FAMI LOGIN] Password already filled")

        # 點擊登入按鈕
        login_btn = await tab.query_selector('button#btnLogin')
        if login_btn:
            await login_btn.click()
            if show_debug_message:
                print("[FAMI LOGIN] Login button clicked, waiting for URL change...")

            # 等待 URL 變化（最多 10 秒）
            for _ in range(20):
                await asyncio.sleep(0.5)
                current_url = tab.url if hasattr(tab, 'url') else str(tab.target.url)
                if current_url != original_url:
                    is_login_success = True
                    if show_debug_message:
                        print(f"[FAMI LOGIN] URL changed to: {current_url[:50]}...")
                    break
            else:
                if show_debug_message:
                    print("[FAMI LOGIN] URL did not change after 10 seconds")

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMI LOGIN] Error: {str(exc)}")

    return is_login_success


async def nodriver_fami_activity(tab, config_dict, show_debug_message=True):
    """
    FamiTicket 活動頁面處理 - 點擊「購買」按鈕

    參考：chrome_tixcraft.py line 3342 (fami_activity)
    對應規格：FR-005, FR-006, FR-007, FR-008

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: 點擊成功返回 True，失敗返回 False
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    if show_debug_message:
        print("[FAMI ACTIVITY] Looking for buy button (#buyWaiting)")

    is_button_clicked = False

    try:
        # 使用 evaluate 直接執行 JavaScript，避免大型 DOM 的 CBOR 序列化問題
        click_result = await tab.evaluate('''
            (function() {
                var btn = document.querySelector('#buyWaiting');
                if (btn && !btn.disabled) {
                    btn.click();
                    return true;
                }
                return false;
            })()
        ''')

        if click_result:
            is_button_clicked = True
            if show_debug_message:
                print("[FAMI ACTIVITY] Buy button clicked via JS")
            # 等待頁面轉跳到 Sales 頁面
            for _ in range(10):
                await asyncio.sleep(0.5)
                current_url = tab.url if hasattr(tab, 'url') else str(tab.target.url)
                if '/Sales/' in current_url:
                    if show_debug_message:
                        print("[FAMI ACTIVITY] Redirected to Sales page")
                    break
        else:
            if show_debug_message:
                print("[FAMI ACTIVITY] Buy button not found or disabled")

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMI ACTIVITY] Error: {str(exc)}")

    return is_button_clicked


async def nodriver_fami_verify(tab, config_dict, fail_list=None, show_debug_message=True):
    """
    FamiTicket 驗證問題處理

    對應規格：FR-021, FR-022, FR-023, FR-024, FR-025

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        fail_list: 錯誤答案清單
        show_debug_message: 是否顯示除錯訊息

    Returns:
        tuple[bool, list]: (成功與否, 更新後的 fail_list)
    """
    if fail_list is None:
        fail_list = []

    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    is_verify_success = False

    try:
        # 使用 evaluate 檢查是否存在驗證輸入框，避免大型 DOM 的 CBOR 序列化問題
        has_verify_input = await tab.evaluate('''
            (function() {
                return document.querySelector('#verifyPrefAnswer') !== null;
            })()
        ''')

        if has_verify_input:
            if show_debug_message:
                print("[FAMI VERIFY] Verification input found (#verifyPrefAnswer)")

            # 取得答案
            answer_string = config_dict["area_auto_select"].get("area_answer", "").strip()
            auto_guess_enable = config_dict["advanced"].get("auto_guess_options", False)

            answer_list = []
            if answer_string:
                answer_list = [ans.strip() for ans in answer_string.split(',') if ans.strip()]

            # 自動猜測
            if auto_guess_enable and len(answer_list) == 0:
                if show_debug_message:
                    print("[FAMI VERIFY] Auto guess enabled but no implementation yet")
                # TODO: 實作 guess_tixcraft_question() 整合

            # 選擇未失敗的答案
            inferred_answer = ""
            for answer in answer_list:
                if answer not in fail_list:
                    inferred_answer = answer
                    break

            if inferred_answer:
                if show_debug_message:
                    print(f"[FAMI VERIFY] Trying answer: {inferred_answer}")

                # 使用 evaluate 填寫答案並提交
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector('#verifyPrefAnswer');
                        if (input) {{
                            input.value = "{inferred_answer}";
                            input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                            // 模擬按 Enter
                            var event = new KeyboardEvent('keypress', {{ key: 'Enter', keyCode: 13 }});
                            input.dispatchEvent(event);
                            // 或者直接提交表單
                            var form = input.closest('form');
                            if (form) form.submit();
                        }}
                    }})()
                ''')

                # 等待驗證結果
                await asyncio.sleep(0.5)

                # 檢查是否仍在驗證頁面（表示答案錯誤）
                still_on_verify = await tab.evaluate('''
                    (function() {
                        return document.querySelector('#verifyPrefAnswer') !== null;
                    })()
                ''')
                if still_on_verify:
                    fail_list.append(inferred_answer)
                    if show_debug_message:
                        print(f"[FAMI VERIFY] Answer failed, added to fail_list: {fail_list}")
                else:
                    is_verify_success = True
                    if show_debug_message:
                        print("[FAMI VERIFY] Verification successful")
            else:
                if show_debug_message:
                    print("[FAMI VERIFY] No valid answer available")
        else:
            # 無驗證輸入框，視為成功（不需要驗證）
            is_verify_success = True

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMI VERIFY] Error: {str(exc)}")

    return is_verify_success, fail_list


async def nodriver_fami_date_auto_select(tab, config_dict, last_activity_url, show_debug_message=True):
    """
    FamiTicket 日期自動選擇

    參考：chrome_tixcraft.py line 3386 (fami_date_auto_select)
    對應規格：FR-009 ~ FR-015, FR-014a, FR-014b

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        last_activity_url: 活動頁面 URL（用於自動補票）
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: 選擇成功返回 True，失敗返回 False
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    # 讀取設定
    auto_select_mode = config_dict["date_auto_select"].get("mode", "from_top_to_bottom")
    date_keyword = config_dict["date_auto_select"].get("date_keyword", "").strip()
    date_auto_fallback = config_dict.get('date_auto_fallback', False)  # Feature 003: 條件回退
    auto_reload_coming_soon_page_enable = config_dict["tixcraft"].get("auto_reload_coming_soon_page", False)
    auto_reload_page_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)

    if show_debug_message:
        print(f"[FAMI DATE] date_keyword: {date_keyword}")
        print(f"[FAMI DATE] auto_select_mode: {auto_select_mode}")
        print(f"[FAMI DATE] date_auto_fallback: {date_auto_fallback}")

    is_date_selected = False
    matched_rows = []

    try:
        # 使用 evaluate 掃描日期列表，返回 JSON 字串避免物件轉換問題
        formated_area_list_result = await tab.evaluate('''
            (function() {
                var rows = document.querySelectorAll('.session__list > tbody > tr');
                var result = [];
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    var html = row.innerHTML || "";
                    var text = row.innerText || "";
                    if (html.indexOf('<button') !== -1 && html.indexOf('立即購買') !== -1) {
                        result.push({
                            idx: i,
                            txt: text
                        });
                    }
                }
                return JSON.stringify(result);
            })()
        ''')

        import json
        formated_area_list = []
        if formated_area_list_result:
            if isinstance(formated_area_list_result, str):
                formated_area_list = json.loads(formated_area_list_result)
            elif isinstance(formated_area_list_result, list):
                formated_area_list = formated_area_list_result

        if show_debug_message:
            print(f"[FAMI DATE] Found {len(formated_area_list)} date rows with buy button")

        # 關鍵字匹配
        if len(formated_area_list) > 0:
            if len(date_keyword) == 0:
                # 無關鍵字，全部匹配
                matched_rows = formated_area_list
            else:
                # 有關鍵字，進行 OR 匹配
                keywords = util.parse_keyword_string_to_array(date_keyword)
                if not keywords:
                    # Fallback: comma-separated plain text
                    keywords = [kw.strip() for kw in date_keyword.split(',') if kw.strip()]
                for item in formated_area_list:
                    item_text = item.get('txt', item.get('text', ''))
                    row_text = util.format_keyword_string(item_text)
                    for keyword in keywords:
                        formatted_keyword = util.format_keyword_string(keyword)
                        if formatted_keyword in row_text:
                            matched_rows.append(item)
                            if show_debug_message:
                                print(f"[FAMI DATE KEYWORD] Matched keyword '{keyword}' in: {item_text[:50]}...")
                            break

                if show_debug_message:
                    print(f"[FAMI DATE] Matched dates: {len(matched_rows)}")

        # Feature 003: 條件回退機制
        if len(matched_rows) == 0 and len(formated_area_list) > 0:
            if date_auto_fallback:
                # 回退模式：使用所有可用日期
                print("[DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                matched_rows = formated_area_list
            else:
                # 嚴格模式：不選擇任何日期
                print("[DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                return False

        # 選擇目標日期
        target_item = util.get_target_item_from_matched_list(matched_rows, auto_select_mode)

        # 點擊目標日期的按鈕
        if target_item:
            try:
                target_index = target_item.get('idx', target_item.get('index', 0))
                target_text = target_item.get('txt', target_item.get('text', ''))
                click_result = await tab.evaluate(f'''
                    (function() {{
                        var rows = document.querySelectorAll('.session__list > tbody > tr');
                        if (rows[{target_index}]) {{
                            var btn = rows[{target_index}].querySelector('button');
                            if (btn) {{
                                btn.click();
                                return true;
                            }}
                        }}
                        return false;
                    }})()
                ''')

                if click_result:
                    is_date_selected = True
                    if show_debug_message:
                        print(f"[FAMI DATE SELECT] Selected date: {target_text[:50]}...")
                else:
                    if show_debug_message:
                        print("[FAMI DATE] Button not found in target row")
            except Exception as click_exc:
                if show_debug_message:
                    print(f"[FAMI DATE] Click error: {str(click_exc)}")

        # 自動補票邏輯（日期列表為空時）
        if len(formated_area_list) == 0:
            # 可能是 SPA 頁面延遲渲染，再次檢查是否為其他頁面類型
            await asyncio.sleep(0.5)

            # 使用 evaluate 檢查頁面類型，避免 CBOR 問題
            page_type = await tab.evaluate('''
                (function() {
                    if (document.querySelector('.ticket__title')) return 'ticket';
                    if (document.querySelector('.purchase-detail')) return 'cart';
                    return 'date';
                })()
            ''')

            # 檢查是否為票種選擇頁面
            if page_type == 'ticket':
                if show_debug_message:
                    print("[FAMI DATE] No date rows, but found ticket selection page - delegating")
                return await nodriver_fami_ticket_select(tab, config_dict, show_debug_message)

            # 檢查是否為購物車頁面
            if page_type == 'cart':
                if show_debug_message:
                    print("[FAMI DATE] No date rows, but found cart page - clicking next")
                next_result = await tab.evaluate('''
                    (function() {
                        var btn = document.querySelector('.purchase-detail__next');
                        if (btn && !btn.disabled) {
                            btn.click();
                            return true;
                        }
                        return false;
                    })()
                ''')
                return next_result

            # 確認是日期選擇頁面但無可用日期，才觸發 auto-reload
            if auto_reload_coming_soon_page_enable:
                if show_debug_message:
                    print("[FAMI DATE] Date list is empty, triggering auto-reload")

                if auto_reload_page_interval > 0:
                    await asyncio.sleep(auto_reload_page_interval)

                # FamiTicket 特定邏輯：返回活動頁面
                if last_activity_url:
                    await tab.get(last_activity_url)
                    await asyncio.sleep(0.3)

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMI DATE] Error: {str(exc)}")

    return is_date_selected


async def nodriver_fami_area_auto_select(tab, config_dict, area_keyword_item, show_debug_message=True):
    """
    FamiTicket 區域自動選擇

    參考：chrome_tixcraft.py line 3520 (fami_area_auto_select)
    對應規格：FR-016 ~ FR-020b

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        area_keyword_item: 區域關鍵字（空格分隔 = AND 邏輯）
        show_debug_message: 是否顯示除錯訊息

    Returns:
        tuple[bool, bool]: (is_need_refresh, is_area_selected)
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    auto_select_mode = config_dict["area_auto_select"].get("mode", "from_top_to_bottom")
    area_auto_fallback = config_dict.get('area_auto_fallback', False)  # Feature 003: 條件回退

    if show_debug_message:
        print(f"[FAMI AREA] area_keyword_item: {area_keyword_item}")
        print(f"[FAMI AREA] auto_select_mode: {auto_select_mode}")
        print(f"[FAMI AREA] area_auto_fallback: {area_auto_fallback}")

    is_area_selected = False
    is_need_refresh = False
    matched_areas = []

    # 隨機等待 0.4-0.8 秒,讓 Vue.js/動態內容完全載入
    import random
    wait_time = random.uniform(0.4, 0.8)
    await tab.sleep(wait_time)

    try:
        formated_area_list_result = await tab.evaluate('''
            (function() {
                var areas = document.querySelectorAll('div > a.area');
                var result = [];
                for (var i = 0; i < areas.length; i++) {
                    var area = areas[i];
                    var html = area.outerHTML || "";
                    var text = area.innerText || "";
                    if (text.indexOf('售完') !== -1) continue;
                    if (html.indexOf('"area disabled"') !== -1) continue;
                    if (area.classList.contains('disabled')) continue;
                    if (text.length > 0) {
                        result.push({
                            idx: i,
                            txt: text
                        });
                    }
                }
                return JSON.stringify(result);
            })()
        ''')

        import json
        formated_area_list = []
        if formated_area_list_result:
            if isinstance(formated_area_list_result, str):
                formated_area_list = json.loads(formated_area_list_result)
            elif isinstance(formated_area_list_result, list):
                formated_area_list = formated_area_list_result

        if show_debug_message:
            print(f"[FAMI AREA] Found {len(formated_area_list)} available areas")

        # 關鍵字匹配（AND 邏輯）
        if len(formated_area_list) > 0:
            if len(area_keyword_item) == 0:
                # 無關鍵字，全部匹配
                matched_areas = formated_area_list
            else:
                # 有關鍵字，進行 AND 匹配（空格分隔）
                keywords = [kw.strip() for kw in area_keyword_item.split(' ') if kw.strip()]

                for item in formated_area_list:
                    item_text = item.get('txt', item.get('text', ''))
                    row_text = util.format_keyword_string(item_text)
                    is_match = True

                    for keyword in keywords:
                        formatted_keyword = util.format_keyword_string(keyword)
                        if formatted_keyword not in row_text:
                            is_match = False
                            break

                    if is_match:
                        matched_areas.append(item)
                        if show_debug_message:
                            print(f"[FAMI AREA KEYWORD] AND logic matched: {keywords} in: {item_text[:50]}...")

                        if auto_select_mode == "from_top_to_bottom":
                            break  # 找到第一個匹配就停止

                if show_debug_message:
                    print(f"[FAMI AREA] Matched areas: {len(matched_areas)}")

        # Feature 003: 條件回退機制
        if len(matched_areas) == 0 and len(formated_area_list) > 0:
            if area_auto_fallback:
                # 回退模式：使用所有可用區域
                print("[AREA FALLBACK] area_auto_fallback=true, triggering auto fallback")
                matched_areas = formated_area_list
            else:
                # 嚴格模式：不選擇任何區域
                print("[AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
                return True, False  # is_need_refresh=True, is_area_selected=False

        # 選擇目標區域
        target_item = util.get_target_item_from_matched_list(matched_areas, auto_select_mode)

        # 點擊目標區域
        if target_item:
            try:
                target_index = target_item.get('idx', target_item.get('index', 0))
                target_text = target_item.get('txt', target_item.get('text', ''))
                click_result = await tab.evaluate(f'''
                    (function() {{
                        var areas = document.querySelectorAll('div > a.area');
                        if (areas[{target_index}]) {{
                            areas[{target_index}].click();
                            return true;
                        }}
                        return false;
                    }})()
                ''')

                if click_result:
                    is_area_selected = True
                    if show_debug_message:
                        print(f"[FAMI AREA SELECT] Selected area: {target_text[:50]}...")
                else:
                    if show_debug_message:
                        print("[FAMI AREA] Area element not found")
            except Exception as click_exc:
                if show_debug_message:
                    print(f"[FAMI AREA] Click error: {str(click_exc)}")

        if len(matched_areas) == 0:
            is_need_refresh = True
            if show_debug_message:
                print("[FAMI AREA] No matched areas, need refresh")

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMI AREA] Error: {str(exc)}")

    return is_need_refresh, is_area_selected


async def nodriver_fami_date_to_area(tab, config_dict, last_activity_url, show_debug_message=True):
    """
    FamiTicket 日期/區域選擇協調器

    參考：chrome_tixcraft.py line 3665 (fami_date_to_area)
    對應規格：FR-034

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        last_activity_url: 活動頁面 URL
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: 操作成功返回 True，失敗返回 False
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    if show_debug_message:
        print("[FAMI DATE TO AREA] Starting date to area flow")

    # 讀取區域關鍵字
    area_keyword = config_dict["area_auto_select"].get("area_keyword", "").strip()
    area_keyword_and = config_dict["area_auto_select"].get("area_keyword_and", [])

    # 使用 util.format_keyword_for_display 清理引號 (處理 "\"藍區\"" → "藍區")
    area_keyword = util.format_keyword_for_display(area_keyword)

    # 處理多組 AND 關鍵字
    keyword_groups = []

    # 優先使用 area_keyword_and（二維陣列）
    if isinstance(area_keyword_and, list) and len(area_keyword_and) > 0:
        for group in area_keyword_and:
            if isinstance(group, list) and len(group) > 0:
                # 將列表轉為空格分隔字串（AND 邏輯）
                keyword_groups.append(' '.join(group))

    # 若 AND 邏輯無設定，使用 OR 邏輯（area_keyword）
    if len(keyword_groups) == 0 and len(area_keyword) > 0:
        # area_keyword 使用分號分隔（OR 邏輯），每個作為獨立組
        # 支援舊格式逗號分隔 (向後相容)
        delimiter = util.CONST_KEYWORD_DELIMITER if util.CONST_KEYWORD_DELIMITER in area_keyword else ','
        for kw in area_keyword.split(delimiter):
            if kw.strip():
                keyword_groups.append(kw.strip())

    # 若完全無設定，使用空字串（選擇任意可用區域）
    if len(keyword_groups) == 0:
        keyword_groups.append("")

    if show_debug_message:
        print(f"[FAMI DATE TO AREA] ========================================")
        print(f"[FAMI DATE TO AREA] Raw area_keyword: '{area_keyword}'")
        print(f"[FAMI DATE TO AREA] Raw area_keyword_and: {area_keyword_and}")
        print(f"[FAMI DATE TO AREA] Parsed keyword_groups: {keyword_groups}")
        print(f"[FAMI DATE TO AREA] Total groups to try: {len(keyword_groups)}")
        print(f"[FAMI DATE TO AREA] ========================================")

    is_area_selected = False

    # 嘗試每組關鍵字
    for keyword_item in keyword_groups:
        if show_debug_message:
            print(f"[FAMI DATE TO AREA] Trying keyword group: '{keyword_item}'")

        is_need_refresh, is_area_selected = await nodriver_fami_area_auto_select(
            tab, config_dict, keyword_item, show_debug_message
        )

        if is_area_selected:
            break

    return is_area_selected


async def nodriver_fami_ticket_select(tab, config_dict, show_debug_message=True):
    """
    FamiTicket 票種選擇頁面處理

    處理 Sales 頁面的票種選擇流程：
    1. 根據區域關鍵字匹配票種（ticket__title）
    2. 選擇票券數量
    3. 勾選同意 checkbox
    4. 點擊確認選購按鈕

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: 操作成功返回 True，失敗返回 False
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    if show_debug_message:
        print("[FAMI TICKET] Processing ticket selection page")

    result = False

    try:
        # 1. 檢查是否有票種選擇頁面的特徵元素（使用 evaluate 避免 CBOR 問題）
        title_text = await tab.evaluate('document.querySelector(".ticket__title")?.innerText || ""')
        if not title_text:
            if show_debug_message:
                print("[FAMI TICKET] Not a ticket selection page (no .ticket__title)")
            return False
        if show_debug_message:
            print(f"[FAMI TICKET] Found ticket: {title_text}")

        # 2. 選擇票券數量
        ticket_number = config_dict.get("ticket_number", 2)
        if show_debug_message:
            print(f"[FAMI TICKET] Selecting ticket number: {ticket_number}")

        # 選擇下拉選單的值
        select_result = await tab.evaluate(f'''
            (function() {{
                var select = document.querySelector('.ticket select, .ticket-selector select');
                if (select) {{
                    var targetValue = "{ticket_number}";
                    for (var i = 0; i < select.options.length; i++) {{
                        if (select.options[i].value == targetValue) {{
                            select.selectedIndex = i;
                            select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                            return true;
                        }}
                    }}
                    // 若找不到指定數量，選擇最後一個非空選項
                    for (var i = select.options.length - 1; i >= 0; i--) {{
                        if (select.options[i].value && select.options[i].value !== "") {{
                            select.selectedIndex = i;
                            select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                            return true;
                        }}
                    }}
                }}
                return false;
            }})()
        ''')

        if select_result and show_debug_message:
            print("[FAMI TICKET] Ticket number selected")

        await asyncio.sleep(0.3)

        # 3. 勾選同意 checkbox（兩個）
        checkbox_result = await tab.evaluate('''
            (function() {
                var checkboxes = document.querySelectorAll('.ts-note__check');
                var checked = 0;
                checkboxes.forEach(function(cb) {
                    if (!cb.checked) {
                        cb.click();
                        checked++;
                    }
                });
                return checked;
            })()
        ''')

        if show_debug_message:
            print(f"[FAMI TICKET] Checked {checkbox_result} checkboxes")

        await asyncio.sleep(0.3)

        # 4. 點擊確認選購按鈕
        submit_result = await tab.evaluate('''
            (function() {
                var btn = document.querySelector('.ts-opts__auto');
                if (btn && !btn.classList.contains('disabled')) {
                    btn.click();
                    return true;
                }
                return false;
            })()
        ''')

        if submit_result:
            if show_debug_message:
                print("[FAMI TICKET] Submit button clicked")
            result = True

            # 等待頁面轉跳
            for _ in range(10):
                await asyncio.sleep(0.5)
                current_url = tab.url if hasattr(tab, 'url') else str(tab.target.url)
                if '/Order/' in current_url or '/Checkout/' in current_url:
                    if show_debug_message:
                        print("[FAMI TICKET] Redirected to order page")
                    break
        else:
            if show_debug_message:
                print("[FAMI TICKET] Submit button not available or disabled")

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMI TICKET] Error: {str(exc)}")

    return result


async def nodriver_fami_home_auto_select(tab, config_dict, last_activity_url, show_debug_message=True):
    """
    FamiTicket 首頁入口處理

    對應規格：FR-037（URL 路由）

    Args:
        tab: NoDriver tab 物件
        config_dict: 設定字典
        last_activity_url: 活動頁面 URL
        show_debug_message: 是否顯示除錯訊息

    Returns:
        bool: 操作成功返回 True，失敗返回 False
    """
    if config_dict["advanced"].get("verbose", False):
        show_debug_message = True

    if show_debug_message:
        print("[FAMI HOME] Processing home/sales page")

    # 使用 evaluate 檢查頁面類型，避免大型 DOM 的 CBOR 序列化問題
    page_type = await tab.evaluate('''
        (function() {
            if (document.querySelector('.purchase-detail')) return 'cart';
            if (document.querySelector('.ticket__title')) return 'ticket';
            if (document.querySelector('.area-list') ||
                document.querySelector('.area-selector__title')) return 'area';
            return 'date';
        })()
    ''')

    # Debug: 輸出頁面類型判斷結果
    if show_debug_message:
        print(f"[FAMI HOME DEBUG] Page type detected: '{page_type}'")
        debug_selectors = await tab.evaluate('''
            (function() {
                return {
                    cart: !!document.querySelector('.purchase-detail'),
                    ticket: !!document.querySelector('.ticket__title'),
                    area_list: !!document.querySelector('.area-list'),
                    area_selector: !!document.querySelector('.area-selector__title')
                };
            })()
        ''')
        print(f"[FAMI HOME DEBUG] Selector check: {debug_selectors}")
        print(f"[FAMI HOME DEBUG] area_auto_select.enable: {config_dict['area_auto_select'].get('enable', True)}")

    # 1. 購物車頁面
    if page_type == 'cart':
        if show_debug_message:
            print("[FAMI HOME] Detected cart/order page")
        # 點擊下一步按鈕
        next_result = await tab.evaluate('''
            (function() {
                var btn = document.querySelector('.purchase-detail__next');
                if (btn && !btn.disabled) {
                    btn.click();
                    return true;
                }
                return false;
            })()
        ''')
        if next_result:
            if show_debug_message:
                print("[FAMI HOME] Next button clicked on cart page")
            return True
        else:
            if show_debug_message:
                print("[FAMI HOME] Next button not found or disabled")
            return False

    # 2. 票種選擇頁面
    if page_type == 'ticket':
        if show_debug_message:
            print("[FAMI HOME] Detected ticket selection page")
        return await nodriver_fami_ticket_select(tab, config_dict, show_debug_message)

    # 3. 區域選擇頁面
    if page_type == 'area':
        if show_debug_message:
            print("[FAMI HOME] Detected area selection page")
        if config_dict["area_auto_select"].get("enable", True):
            is_area_selected = await nodriver_fami_date_to_area(tab, config_dict, last_activity_url, show_debug_message)

            # 參考 TixCraft 和 FamiTicket Chrome 版本的處理方式
            # 當未選中區域時,等待 auto_reload_page_interval 後重試
            if not is_area_selected:
                auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 5)
                if auto_reload_interval > 0:
                    if show_debug_message:
                        print(f"[FAMI HOME] No area selected, waiting {auto_reload_interval}s before retry...")
                    await tab.sleep(auto_reload_interval)

            return is_area_selected
        return False

    # 4. 日期選擇頁面（預設）
    if config_dict["date_auto_select"].get("enable", True):
        is_date_selected = await nodriver_fami_date_auto_select(
            tab, config_dict, last_activity_url, show_debug_message
        )
        return is_date_selected

    return False


async def nodriver_famiticket_main(tab, url, config_dict):
    """
    FamiTicket 主函數 - URL 路由器

    參考：chrome_tixcraft.py line 6315 (famiticket_main)
    對應規格：FR-036, FR-037, FR-038, FR-039

    Args:
        tab: NoDriver tab 物件
        url: 當前頁面 URL
        config_dict: 設定字典

    Returns:
        bool: 操作成功返回 True，失敗返回 False
    """
    global fami_dict
    if not 'fami_dict' in globals():
        fami_dict = {}
        fami_dict["fail_list"] = []
        fami_dict["last_activity"] = ""
        fami_dict["payment_logged"] = False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print(f"[FAMITICKET MAIN] Processing URL: {url[:80]}...")

    result = False

    try:
        # URL 路由分派
        if '/Payment/' in url:
            # 結帳頁面 - 不做任何操作，讓用戶自行完成付款
            # 只顯示一次訊息，避免重複輸出
            if not fami_dict.get("payment_logged", False):
                print("[FAMITICKET MAIN] Payment page detected - waiting for user to complete payment")
                fami_dict["payment_logged"] = True
            return True

        if '/Home/User/SignIn' in url and '/SignInCheck' not in url:
            # 登入頁面（排除 SignInCheck 驗證頁面）
            fami_account = config_dict["advanced"].get("fami_account", "")
            if len(fami_account) > 4:
                result = await nodriver_fami_login(tab, config_dict, show_debug_message)

        elif '/Home/Activity/Info/' in url:
            # 活動頁面
            fami_dict["last_activity"] = url
            result = await nodriver_fami_activity(tab, config_dict, show_debug_message)

            # 處理驗證問題
            is_verify_success, fami_dict["fail_list"] = await nodriver_fami_verify(
                tab, config_dict, fami_dict["fail_list"], show_debug_message
            )

        elif '/Sales/Home/Index/' in url:
            # 銷售首頁（日期/區域選擇）
            if config_dict["date_auto_select"].get("enable", True):
                result = await nodriver_fami_home_auto_select(
                    tab, config_dict, fami_dict["last_activity"], show_debug_message
                )

        elif url.endswith('/Home/') or url.endswith('/Home'):
            # 登入成功後的首頁，判斷是否需要轉跳
            homepage = config_dict.get("homepage", "")
            if homepage and '/Home/Activity/Info/' in homepage:
                # 設定的是活動頁面，需要轉跳
                if show_debug_message:
                    print(f"[FAMITICKET MAIN] Redirecting to activity: {homepage[:60]}...")
                await tab.get(homepage)
                result = True
            else:
                # 設定的就是首頁，不轉跳
                if show_debug_message:
                    print("[FAMITICKET MAIN] On homepage, no redirect needed")

        else:
            # 其他頁面：清空 fail_list
            if show_debug_message:
                print(f"[FAMITICKET MAIN] Unknown URL pattern, clearing fail_list")
            fami_dict["fail_list"] = []

    except Exception as exc:
        if show_debug_message:
            print(f"[FAMITICKET MAIN] Error: {str(exc)}")

    return result


async def nodriver_ibon_date_auto_select_pierce(tab, config_dict):
    """
    NoDriver ibon 日期自動選擇實作 - 使用 CDP pierce=True 參數
    直接穿透 Shadow DOM，比 DOMSnapshot 更簡潔高效

    使用 CDP DOM.query_selector_all(pierce=True) 直接查詢 Shadow DOM 中的按鈕
    參考：https://ultrafunkamsterdam.github.io/nodriver/nodriver/cdp/dom.html
    """
    from nodriver import cdp
    from nodriver.cdp import runtime
    import random
    import json

    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get('date_auto_fallback', False)  # T017: Safe access for new field

    if show_debug_message:
        print("[IBON DATE PIERCE] Starting date selection with pierce=True")
        print("date_keyword:", date_keyword)
        print("auto_select_mode:", auto_select_mode)

    # Step 1: Auto-detect buttons (no fixed wait - responds immediately when ready)
    if show_debug_message:
        print("[IBON DATE PIERCE] Auto-detecting purchase buttons...")

    await tab  # Sync state

    # Initialize CDP DOM state (required for perform_search to work)
    try:
        await tab.send(cdp.dom.get_document(depth=0, pierce=False))
    except:
        pass

    # Auto-detect: fast polling until buttons found or timeout
    import time
    max_wait = 3  # Maximum wait (safety limit)
    check_interval = 0.1  # Fast polling for quick response
    start_time = time.time()
    button_found = False

    while (time.time() - start_time) < max_wait:
        try:
            # Use CDP search to check button presence (penetrates Shadow DOM)
            search_id, result_count = await tab.send(cdp.dom.perform_search(
                query='button.btn-buy',
                include_user_agent_shadow_dom=True
            ))

            # Clean up search
            try:
                await tab.send(cdp.dom.discard_search_results(search_id=search_id))
            except:
                pass

            if result_count > 0:
                button_found = True
                elapsed = time.time() - start_time
                if show_debug_message:
                    print(f"[IBON DATE PIERCE] Found {result_count} button(s) after {elapsed:.2f}s")
                break
        except:
            pass

        await tab.sleep(check_interval)

    if not button_found and show_debug_message:
        elapsed = time.time() - start_time
        print(f"[IBON DATE PIERCE] No buttons found after {elapsed:.1f}s, proceeding with search anyway...")

    # Step 4: Get document with pierce=True to enable Shadow DOM traversal
    # Use shallow depth to avoid CBOR stack overflow on complex pages
    try:
        doc_result = await tab.send(cdp.dom.get_document(depth=0, pierce=False))
        root_node_id = doc_result.node_id
        if show_debug_message:
            print(f"[IBON DATE PIERCE] Got document root: {root_node_id}")
    except Exception as e:
        if show_debug_message:
            print(f"[IBON DATE PIERCE] Failed to get document: {e}")
        return False

    # Step 5: Use perform_search with pierce capability
    # Note: query_selector_all doesn't support pierce in current NoDriver version
    # Use perform_search which can traverse Shadow DOM
    try:
        # Perform search to find buttons (automatically pierces Shadow DOM)
        search_id, result_count = await tab.send(cdp.dom.perform_search(
            query='button.btn-buy',
            include_user_agent_shadow_dom=True
        ))

        if show_debug_message:
            print(f"[IBON DATE PIERCE] Found {result_count} button(s) via search")

        if result_count == 0:
            if show_debug_message:
                print("[IBON DATE PIERCE] No purchase buttons found")
            # Cleanup search
            try:
                await tab.send(cdp.dom.discard_search_results(search_id=search_id))
            except:
                pass
            return False

        # Get search results (node IDs)
        button_node_ids = await tab.send(cdp.dom.get_search_results(
            search_id=search_id,
            from_index=0,
            to_index=result_count
        ))

        # Cleanup search
        try:
            await tab.send(cdp.dom.discard_search_results(search_id=search_id))
        except:
            pass

    except Exception as e:
        if show_debug_message:
            print(f"[IBON DATE PIERCE] perform_search failed: {e}")
        return False

    # Step 5: Extract button data and date context
    purchase_buttons = []

    for node_id in button_node_ids:
        try:
            # Describe button node to get attributes
            node_desc = await tab.send(cdp.dom.describe_node(node_id=node_id))
            # node_desc directly contains the node info, not wrapped in .node
            node = node_desc if hasattr(node_desc, 'attributes') else node_desc.node

            # Parse attributes
            attrs = {}
            if hasattr(node, 'attributes') and node.attributes:
                for i in range(0, len(node.attributes), 2):
                    if i + 1 < len(node.attributes):
                        attrs[node.attributes[i]] = node.attributes[i + 1]

            button_class = attrs.get('class', '')
            button_disabled = 'disabled' in attrs

            # Extract date context by traversing up to find .tr container
            date_context = ''

            # Start from button's parent (not the button itself)
            try:
                button_desc = await tab.send(cdp.dom.describe_node(node_id=node_id))
                button_node = button_desc if hasattr(button_desc, 'attributes') else button_desc.node

                # Get parent_id to start traversal
                if not hasattr(button_node, 'parent_id') or not button_node.parent_id:
                    current_node_id = None
                else:
                    current_node_id = button_node.parent_id  # Start from parent, not button itself
            except Exception:
                current_node_id = None

            if current_node_id:
                for level in range(10):  # Max 10 levels up (now starting from parent = level 1)
                    try:
                        parent_desc = await tab.send(cdp.dom.describe_node(node_id=current_node_id))
                        # Same fix: node_desc might be the node itself
                        parent_node = parent_desc if hasattr(parent_desc, 'attributes') else parent_desc.node

                        # Parse parent attributes
                        parent_attrs = {}
                        if hasattr(parent_node, 'attributes') and parent_node.attributes:
                            for i in range(0, len(parent_node.attributes), 2):
                                if i + 1 < len(parent_node.attributes):
                                    parent_attrs[parent_node.attributes[i]] = parent_node.attributes[i + 1]

                        parent_class = parent_attrs.get('class', '')

                        # Check if this is .tr container (flexible matching)
                        is_tr_container = (
                            ' tr ' in f' {parent_class} ' or
                            parent_class.endswith(' tr') or
                            parent_class.startswith('tr ') or
                            'd-flex' in parent_class  # ibon uses d-flex for containers
                        )

                        if is_tr_container:
                            # Found potential container, extract outer HTML for date context
                            try:
                                outer_html = await tab.send(cdp.dom.get_outer_html(node_id=current_node_id))
                                date_context = outer_html[:200]  # Use first 200 chars
                                break
                            except Exception:
                                pass

                        # Move up to parent
                        if hasattr(parent_node, 'parent_id') and parent_node.parent_id:
                            current_node_id = parent_node.parent_id
                        else:
                            break

                    except Exception:
                        break

            purchase_buttons.append({
                'node_id': node_id,
                'class': button_class,
                'disabled': button_disabled,
                'date_context': date_context
            })

        except Exception as e:
            if show_debug_message:
                print(f"[IBON DATE PIERCE] Failed to process button: {e}")
            continue

    if len(purchase_buttons) == 0:
        if show_debug_message:
            print("[IBON DATE PIERCE] No valid buttons extracted")
        return False

    # Step 6: Filter disabled buttons
    enabled_buttons = [btn for btn in purchase_buttons if not btn['disabled']]

    if show_debug_message:
        print(f"[IBON DATE PIERCE] {len(enabled_buttons)} enabled button(s)")

    if len(enabled_buttons) == 0:
        if show_debug_message:
            print("[IBON DATE PIERCE] All buttons disabled")
        return False

    # Step 7: Apply keyword matching with early return pattern (T004-T007)
    matched_buttons = []
    target_found = False

    if len(date_keyword) > 0 and enabled_buttons:
        keyword_array = util.parse_keyword_string_to_array(date_keyword)
        if show_debug_message:
            print(f"[IBON DATE PIERCE KEYWORD] Start checking keywords in order: {keyword_array}")

        # NEW: Iterate keywords in priority order (early return)
        for keyword_index, keyword_item in enumerate(keyword_array):
            if show_debug_message:
                print(f"[IBON DATE PIERCE KEYWORD] Checking keyword #{keyword_index + 1}: {keyword_item}")

            # Check all buttons for this keyword
            for button in enabled_buttons:
                date_context = button.get('date_context', '').lower()
                sub_keywords = [kw.strip() for kw in keyword_item.split(' ') if kw.strip()]
                is_match = all(sub_kw.lower() in date_context for sub_kw in sub_keywords)

                if is_match:
                    # T006: Keyword matched log - IMMEDIATELY select and stop
                    matched_buttons = [button]
                    target_found = True
                    if show_debug_message:
                        print(f"[IBON DATE PIERCE KEYWORD] Keyword #{keyword_index + 1} matched: '{keyword_item}'")
                        print(f"[IBON DATE PIERCE SELECT] Selected date: {date_context[:50]} (keyword match)")
                    break

            if target_found:
                # EARLY RETURN: Stop checking further keywords
                break

        # T007: All keywords failed log
        if not target_found:
            if show_debug_message:
                print(f"[IBON DATE PIERCE KEYWORD] All keywords failed to match")
    else:
        matched_buttons = enabled_buttons

    # Step 8: Conditional fallback based on date_auto_fallback switch (T018-T020)
    if len(matched_buttons) == 0 and len(date_keyword) > 0:
        if date_auto_fallback:
            # T018: Fallback enabled
            if show_debug_message:
                print(f"[IBON DATE PIERCE FALLBACK] date_auto_fallback=true, triggering auto fallback")
            matched_buttons = enabled_buttons
        else:
            # T019: Fallback disabled - strict mode (no selection, will reload)
            if show_debug_message:
                print(f"[IBON DATE PIERCE FALLBACK] date_auto_fallback=false, fallback is disabled")
                print(f"[IBON DATE PIERCE SELECT] No date selected, will reload page and retry")
            return False  # Return False to trigger reload logic in caller

    # Step 9: Select target based on mode
    target_button = util.get_target_item_from_matched_list(matched_buttons, auto_select_mode)

    # T013: Log selected date with selection type
    if show_debug_message:
        is_keyword_match = (len(date_keyword) > 0 and len(matched_buttons) < len(enabled_buttons))
        selection_type = "keyword match" if is_keyword_match else "fallback"
        print(f"[IBON DATE PIERCE SELECT] Selected date: {target_button.get('date_context', 'N/A')} ({selection_type})")

    # Step 10: Click button using CDP
    try:
        # Scroll into view
        await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=target_button['node_id']))
        await tab.sleep(0.2)

        # Resolve node to RemoteObject
        resolved = await tab.send(cdp.dom.resolve_node(node_id=target_button['node_id']))

        if hasattr(resolved, 'object'):
            remote_object_id = resolved.object.object_id
        elif hasattr(resolved, 'object_id'):
            remote_object_id = resolved.object_id
        else:
            raise Exception("Could not get object_id")

        # Click using JavaScript
        result = await tab.send(runtime.call_function_on(
            function_declaration='function() { this.click(); return true; }',
            object_id=remote_object_id,
            return_by_value=True
        ))

        if show_debug_message:
            print(f"[IBON DATE PIERCE] Click result: {result}")
            print("[IBON DATE PIERCE] Button clicked successfully")

        await tab.sleep(0.5)
        return True

    except Exception as e:
        if show_debug_message:
            print(f"[IBON DATE PIERCE] Click failed: {e}")
        return False

async def nodriver_ibon_date_auto_select(tab, config_dict):
    """
    NoDriver ibon 日期自動選擇實作 - 主入口（包含 fallback）

    優先使用 pierce=True 方法（更快、更簡潔）
    失敗時回退到 DOMSnapshot 方法（更穩定但較慢）
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Try pierce method first (faster)
    try:
        result = await nodriver_ibon_date_auto_select_pierce(tab, config_dict)
        if result:
            return True
        else:
            if show_debug_message:
                print("[IBON DATE] pierce method failed, trying DOMSnapshot fallback...")
    except Exception as e:
        if show_debug_message:
            print(f"[IBON DATE] pierce method error: {e}, trying DOMSnapshot fallback...")

    # Fallback to original DOMSnapshot method
    return await nodriver_ibon_date_auto_select_domsnapshot(tab, config_dict)

async def nodriver_ibon_date_auto_select_domsnapshot(tab, config_dict):
    """
    NoDriver ibon 日期自動選擇實作 - DOMSnapshot 回退版本
    使用 CDP DOMSnapshot 穿透 closed Shadow DOM 搜尋購票按鈕
    參考：NoDriver API Guide 範例 1
    """
    from nodriver import cdp
    from nodriver.cdp import input_ as cdp_input
    import random

    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get('date_auto_fallback', False)  # T017: Safe access for new field
    auto_reload_coming_soon_page_enable = config_dict["tixcraft"]["auto_reload_coming_soon_page"]

    if show_debug_message:
        print("[IBON DATE] Starting date selection on ActivityInfo/Details page")
        print("date_keyword:", date_keyword)
        print("auto_select_mode:", auto_select_mode)

    is_date_assigned = False

    # Auto-detect buttons (no fixed wait - responds immediately when ready)
    # IMPORTANT: get_document() must be called before perform_search() to initialize CDP DOM state
    try:
        await tab.send(cdp.dom.get_document(depth=0, pierce=False))
    except:
        pass

    import time
    max_wait = 3  # Maximum wait (safety limit)
    check_interval = 0.1  # Fast polling for quick response
    start_time = time.time()
    content_appeared = False

    if show_debug_message:
        print("[IBON DATE] Auto-detecting purchase buttons...")

    while (time.time() - start_time) < max_wait:
        try:
            # Use CDP search to check button presence (penetrates Shadow DOM, same as pierce method)
            search_id, result_count = await tab.send(cdp.dom.perform_search(
                query='button.btn-buy',
                include_user_agent_shadow_dom=True
            ))

            # Clean up search
            try:
                await tab.send(cdp.dom.discard_search_results(search_id=search_id))
            except:
                pass

            if result_count > 0:
                content_appeared = True
                elapsed = time.time() - start_time
                if show_debug_message:
                    print(f"[IBON DATE] Found {result_count} purchase button(s) after {elapsed:.2f}s")
                break
        except:
            pass
        await tab.sleep(check_interval)

    if not content_appeared and show_debug_message:
        elapsed = time.time() - start_time
        print(f"[IBON DATE] No buttons found after {elapsed:.1f}s, proceeding with snapshot anyway...")

    # Capture DOM snapshot to penetrate closed Shadow DOM and search for purchase buttons
    if show_debug_message:
        print("[IBON DATE] Capturing DOM snapshot with CDP...")

    try:
        documents, strings = await tab.send(cdp.dom_snapshot.capture_snapshot(
            computed_styles=[],
            include_dom_rects=True
        ))
    except Exception as e:
        if show_debug_message:
            print(f"[IBON DATE] Error capturing snapshot: {e}")
        return False

    purchase_buttons = []

    if documents and len(documents) > 0:
        if show_debug_message:
            print(f"[IBON DATE] Analyzing {len(documents)} document(s)...")

        document_snapshot = documents[0]
        nodes = document_snapshot.nodes

        node_names = [strings[i] for i in nodes.node_name]
        node_values = [strings[i] if i >= 0 else '' for i in nodes.node_value]
        attributes_list = nodes.attributes
        backend_node_ids = list(nodes.backend_node_id)

        if show_debug_message:
            print(f"[IBON DATE] Total nodes in snapshot: {len(node_names)}")

        # Step 1: Extract parent_index for tracking node relationships
        parent_indices = list(nodes.parent_index) if hasattr(nodes, 'parent_index') else []

        # Debug: Count all buttons found
        button_count = sum(1 for name in node_names if name.upper() == 'BUTTON')
        if show_debug_message:
            print(f"[IBON DATE] Total BUTTON nodes found: {button_count}")

        # Step 2: Search for purchase buttons and extract date context
        for i, node_name in enumerate(node_names):
            if node_name.upper() == 'BUTTON':
                attrs = {}
                if i < len(attributes_list):
                    attr_indices = attributes_list[i]
                    for j in range(0, len(attr_indices), 2):
                        if j + 1 < len(attr_indices):
                            key = strings[attr_indices[j]]
                            val = strings[attr_indices[j + 1]]
                            attrs[key] = val

                button_class = attrs.get('class', '')
                button_disabled = 'disabled' in attrs


                # ibon purchase buttons have 'btn-buy' or 'ng-tns-c57' in class
                if 'btn-buy' in button_class or ('ng-tns-c57' in button_class and 'btn' in button_class):
                    # Get button text from adjacent text nodes
                    button_text = ''
                    if i + 1 < len(node_names) and node_names[i + 1] == '#text':
                        button_text = node_values[i + 1].strip()

                    # Step 3: Extract date context by finding parent .tr container
                    date_context = ''
                    if parent_indices:
                        # Traverse up to find .tr container
                        current_idx = i
                        tr_container_idx = -1
                        for _ in range(10):  # Max 10 levels up
                            if current_idx < len(parent_indices):
                                parent_idx = parent_indices[current_idx]
                                if parent_idx >= 0 and parent_idx < len(attributes_list):
                                    # Check if this parent has class='tr' or class contains 'tr'
                                    parent_attrs = {}
                                    parent_attr_indices = attributes_list[parent_idx]
                                    for j in range(0, len(parent_attr_indices), 2):
                                        if j + 1 < len(parent_attr_indices):
                                            key = strings[parent_attr_indices[j]]
                                            val = strings[parent_attr_indices[j + 1]]
                                            parent_attrs[key] = val

                                    parent_class = parent_attrs.get('class', '')
                                    if ' tr ' in f' {parent_class} ' or parent_class.endswith(' tr') or parent_class.startswith('tr '):
                                        tr_container_idx = parent_idx
                                        break

                                current_idx = parent_idx
                            else:
                                break

                        # Step 4: Find .date element within .tr container
                        if tr_container_idx >= 0:
                            # Search siblings and children of .tr container for .date element
                            for j in range(len(node_names)):
                                if parent_indices[j] == tr_container_idx or parent_indices[j] == i:
                                    # Check if this node has class='date' or class contains 'date'
                                    if j < len(attributes_list):
                                        node_attrs = {}
                                        node_attr_indices = attributes_list[j]
                                        for k in range(0, len(node_attr_indices), 2):
                                            if k + 1 < len(node_attr_indices):
                                                key = strings[node_attr_indices[k]]
                                                val = strings[node_attr_indices[k + 1]]
                                                node_attrs[key] = val

                                        node_class = node_attrs.get('class', '')
                                        if 'date' in node_class:
                                            # Extract text content from this node's children
                                            for text_idx in range(j + 1, min(j + 10, len(node_names))):
                                                if node_names[text_idx] == '#text':
                                                    date_text = node_values[text_idx].strip()
                                                    if date_text:
                                                        date_context = date_text
                                                        break
                                            if date_context:
                                                break

                    purchase_buttons.append({
                        'backend_node_id': backend_node_ids[i],
                        'class': button_class,
                        'disabled': button_disabled,
                        'text': button_text,
                        'index': i,
                        'date_context': date_context
                    })

                    if show_debug_message:
                        print(f"[IBON DATE] Found button: class='{button_class[:50]}...', disabled={button_disabled}, text='{button_text}', date_context='{date_context}'")

    if show_debug_message:
        print(f"[IBON DATE] Found {len(purchase_buttons)} purchase button(s)")

    if len(purchase_buttons) == 0:
        if show_debug_message:
            print("[IBON DATE] No purchase buttons found in Shadow DOM")
        return False

    # Step 5: Filter disabled buttons
    enabled_buttons = [btn for btn in purchase_buttons if not btn['disabled']]

    if show_debug_message:
        print(f"[IBON DATE] Found {len(enabled_buttons)} enabled button(s)")

    if len(enabled_buttons) == 0:
        if show_debug_message:
            print("[IBON DATE] All buttons are disabled")
        return False

    # Step 6: Apply keyword matching with early return pattern (T004-T007)
    # Unified keyword processing: JSON array parsing with AND/OR logic
    # Format: "AA BB","CC","DD" -> (AA AND BB) OR (CC) OR (DD)
    matched_buttons = []
    target_found = False

    if len(date_keyword) > 0 and enabled_buttons:
        # Parse as JSON array (auto-removes quotes)
        keyword_array = util.parse_keyword_string_to_array(date_keyword)
        if show_debug_message:
            print(f"[IBON DATE KEYWORD] Start checking keywords in order: {keyword_array}")

        # NEW: Iterate keywords in priority order (early return)
        for keyword_index, keyword_item in enumerate(keyword_array):
            if show_debug_message:
                print(f"[IBON DATE KEYWORD] Checking keyword #{keyword_index + 1}: {keyword_item}")

            # Check all buttons for this keyword
            for button in enabled_buttons:
                button_text = button.get('text', '').lower()
                date_context = button.get('date_context', '').lower()
                search_text = f"{button_text} {date_context}"

                # Split by space for AND logic (e.g., "AA BB" means AA AND BB)
                sub_keywords = [kw.strip() for kw in keyword_item.split(' ') if kw.strip()]
                # Check if all sub-keywords match (AND logic within group)
                is_match = all(sub_kw.lower() in search_text for sub_kw in sub_keywords)

                if is_match:
                    # T006: Keyword matched log - IMMEDIATELY select and stop
                    matched_buttons = [button]
                    target_found = True
                    if show_debug_message:
                        print(f"[IBON DATE KEYWORD] Keyword #{keyword_index + 1} matched: '{keyword_item}'")
                        print(f"[IBON DATE SELECT] Selected date: {date_context[:50]} (keyword match)")
                    break

            if target_found:
                # EARLY RETURN: Stop checking further keywords
                break

        # T007: All keywords failed log
        if not target_found:
            if show_debug_message:
                print(f"[IBON DATE KEYWORD] All keywords failed to match")
    else:
        matched_buttons = enabled_buttons

    # Step 7: Conditional fallback based on date_auto_fallback switch (T018-T020)
    if len(matched_buttons) == 0 and len(date_keyword) > 0:
        if date_auto_fallback:
            # T018: Fallback enabled - use auto_select_mode
            if show_debug_message:
                print(f"[IBON DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                print(f"[IBON DATE FALLBACK] Selecting available date based on date_select_order='{auto_select_mode}'")
            matched_buttons = enabled_buttons
        else:
            # T019: Fallback disabled - strict mode (no selection, will reload)
            if show_debug_message:
                print(f"[IBON DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                print(f"[IBON DATE SELECT] No date selected, will reload page and retry")
            return False  # Return False to trigger reload logic in caller

    # Step 8: Select target button based on mode
    target_button = util.get_target_item_from_matched_list(matched_buttons, auto_select_mode)

    # Determine selection method (T013 equivalent)
    is_keyword_match = (len(date_keyword) > 0 and len(matched_buttons) < len(enabled_buttons))
    selection_type = "keyword match" if is_keyword_match else "fallback"
    selection_method = selection_type if is_keyword_match else f"mode '{auto_select_mode}'"

    if show_debug_message:
        print(f"[IBON DATE SELECT] Selected date: {target_button.get('date_context', 'N/A')} ({selection_type})")
        print(f"[IBON DATE] Selected target button ({selection_method}): date_context='{target_button.get('date_context', 'N/A')}'")

    try:
        await tab.send(cdp.dom.get_document())

        # Convert backend_node_id to node_id
        result = await tab.send(cdp.dom.push_nodes_by_backend_ids_to_frontend([target_button['backend_node_id']]))
        node_id = result[0]

        if show_debug_message:
            print(f"[IBON DATE] Button node_id: {node_id}")

        # Scroll element into view
        await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=node_id))
        await tab.sleep(0.2)

        # Use CDP Runtime.callFunctionOn to click button in closed Shadow DOM
        from nodriver.cdp import runtime

        # Resolve node to RemoteObject
        resolved = await tab.send(cdp.dom.resolve_node(node_id=node_id))

        # resolved should have an 'object' field containing the RemoteObject
        # But based on error, try accessing object_id directly
        if hasattr(resolved, 'object'):
            remote_object_id = resolved.object.object_id
        elif hasattr(resolved, 'object_id'):
            remote_object_id = resolved.object_id
        else:
            # Debug: print the actual structure
            if show_debug_message:
                print(f"[IBON DATE] Resolved structure: {resolved}")
                print(f"[IBON DATE] Resolved type: {type(resolved)}")
                print(f"[IBON DATE] Resolved attributes: {dir(resolved)}")
            raise Exception("Could not find object_id in resolved node")

        if show_debug_message:
            print(f"[IBON DATE] Resolved button object_id: {remote_object_id}")

        result = await tab.send(runtime.call_function_on(
            function_declaration='function() { this.click(); return true; }',
            object_id=remote_object_id,
            return_by_value=True
        ))

        if show_debug_message:
            print(f"[IBON DATE] Button clicked, result: {result}")

        if result:
            if show_debug_message:
                print("[IBON DATE] Purchase button clicked successfully")
            is_date_assigned = True
            await tab.sleep(0.5)
        else:
            if show_debug_message:
                print("[IBON DATE] Click failed")

    except Exception as e:
        if show_debug_message:
            print(f"[IBON DATE] Error clicking button: {e}")
        is_date_assigned = False

    return is_date_assigned


async def nodriver_ibon_ticket_agree(tab):
    for i in range(3):
        is_finish_checkbox_click = await nodriver_check_checkbox(tab, '#agreen:not(:checked)')
        if is_finish_checkbox_click:
            break

async def nodriver_ibon_allow_not_adjacent_seat(tab, config_dict):
    """
    Check and click the 'allow non-adjacent seats' checkbox on ibon

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary for debug settings

    Returns:
        bool: True if checkbox was clicked successfully, False otherwise
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_finish_checkbox_click = False

    # Selector for non-adjacent seat checkbox
    checkbox_selector = 'div.not-consecutive > div.custom-control > span > input[type="checkbox"]:not(:checked)'

    try:
        for i in range(3):
            is_finish_checkbox_click = await nodriver_check_checkbox(tab, checkbox_selector)
            if is_finish_checkbox_click:
                if show_debug_message:
                    print("[IBON] Non-adjacent seat checkbox clicked")
                break
    except Exception as e:
        if show_debug_message:
            print(f"[IBON] Non-adjacent seat checkbox error: {e}")

    return is_finish_checkbox_click

async def nodriver_ibon_event_area_auto_select(tab, config_dict, area_keyword_item=""):
    """
    ibon seat area auto-selection for NEW Event page format (NoDriver version)

    Handles seat area selection on /Event/{id}/{id} page (Angular SPA).
    Uses DOMSnapshot for data extraction and CDP for clicking.

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary
        area_keyword_item: Area keyword string (space-separated for AND logic)

    Returns:
        tuple: (is_need_refresh, is_price_assign_by_bot)
            - is_need_refresh: Whether page refresh is needed
            - is_price_assign_by_bot: Whether area selection succeeded
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get('area_auto_fallback', False)  # T021: Safe access for new field
    ticket_number = config_dict["ticket_number"]

    is_price_assign_by_bot = False
    is_need_refresh = False

    if show_debug_message:
        print("[ibon] 區域選擇開始")

    # Optimized wait for Angular app to fully load (reduced from 2.3-2.7s to 1.0-1.4s)
    try:
        import random
        wait_time = random.uniform(0.6, 0.8)
        await tab.sleep(wait_time)
        # Reduced second wait (1.5s -> 0.6s) - total now 1.2-1.4s instead of 2.3-2.7s
        await tab.sleep(0.6)
    except:
        pass

    # Phase 1: Extract all area data using DOMSnapshot (to pierce Shadow DOM if present)
    try:
        from nodriver import cdp

        # Use DOMSnapshot to get flattened page structure
        documents, strings = await tab.send(cdp.dom_snapshot.capture_snapshot(
            computed_styles=[],
            include_paint_order=True,
            include_dom_rects=True
        ))

        areas_data = []

        if documents and len(documents) > 0:
            document_snapshot = documents[0]

            # Extract node information
            node_names = []
            node_values = []
            parent_indices = []
            attributes_list = []
            backend_node_ids = []

            if hasattr(document_snapshot, 'nodes'):
                nodes = document_snapshot.nodes
                if hasattr(nodes, 'node_name'):
                    node_names = [strings[i] if isinstance(i, int) and i < len(strings) else str(i)
                                 for i in nodes.node_name]
                if hasattr(nodes, 'node_value'):
                    node_values = [strings[i] if isinstance(i, int) and i >= 0 and i < len(strings) else ''
                                  for i in nodes.node_value]
                if hasattr(nodes, 'parent_index'):
                    parent_indices = list(nodes.parent_index)
                if hasattr(nodes, 'attributes'):
                    attributes_list = nodes.attributes
                if hasattr(nodes, 'backend_node_id'):
                    backend_node_ids = list(nodes.backend_node_id)

            # Build children map for traversal
            children_map = {}
            for i, parent_idx in enumerate(parent_indices):
                if parent_idx >= 0:
                    if parent_idx not in children_map:
                        children_map[parent_idx] = []
                    children_map[parent_idx].append(i)

            # Helper function to get attributes as dict
            def get_attributes_dict(node_index):
                attrs = {}
                if node_index < len(attributes_list):
                    attr_indices = attributes_list[node_index]
                    for j in range(0, len(attr_indices), 2):
                        if j + 1 < len(attr_indices):
                            key_idx = attr_indices[j]
                            val_idx = attr_indices[j + 1]
                            key = strings[key_idx] if key_idx < len(strings) else ''
                            val = strings[val_idx] if val_idx < len(strings) else ''
                            attrs[key] = val
                return attrs

            # Helper function to get all text content from node and its children
            def get_text_content(node_index, depth=0, max_depth=10):
                if depth > max_depth or node_index >= len(node_names):
                    return ''

                text_parts = []

                # If this is a text node, get its value
                if node_names[node_index] == '#text' and node_index < len(node_values):
                    text_parts.append(node_values[node_index])

                # Recursively get text from children
                if node_index in children_map:
                    for child_idx in children_map[node_index]:
                        child_text = get_text_content(child_idx, depth + 1, max_depth)
                        if child_text:
                            text_parts.append(child_text)

                return ' '.join(text_parts).strip()

            # Find all TR elements in the table
            tr_indices = []
            for i, node_name in enumerate(node_names):
                if node_name.upper() == 'TR':
                    tr_indices.append(i)

            # Extract data from each TR
            area_index = 0
            tr_count = 0
            for tr_idx in tr_indices:
                # Get TR attributes
                tr_attrs = get_attributes_dict(tr_idx)
                tr_class = tr_attrs.get('class', '')

                # Skip header rows (check if parent is THEAD)
                parent_idx = parent_indices[tr_idx] if tr_idx < len(parent_indices) else -1
                is_header = False
                if parent_idx >= 0 and parent_idx < len(node_names):
                    parent_name = node_names[parent_idx].upper()
                    if parent_name == 'THEAD':
                        is_header = True

                if is_header:
                    continue

                is_disabled = 'disabled' in tr_class.lower()

                # Find TD children
                td_indices = []
                if tr_idx in children_map:
                    for child_idx in children_map[tr_idx]:
                        if node_names[child_idx].upper() == 'TD':
                            td_indices.append(child_idx)

                # Get backend_node_id for this TR
                tr_backend_node_id = None
                if tr_idx < len(backend_node_ids):
                    tr_backend_node_id = backend_node_ids[tr_idx]

                tr_count += 1

                # Detect "giant TR" pattern (ibon Event page uses 1 TR with all areas)
                # Pattern: [color, area_name, price, seat_status] x N areas
                if len(td_indices) > 10:
                    # Giant TR: loop through TDs in groups of 4
                    for i in range(0, len(td_indices), 4):
                        if i + 3 < len(td_indices):
                            # Extract this group of 4 TDs
                            td_texts = [
                                get_text_content(td_indices[i]),     # color
                                get_text_content(td_indices[i+1]),   # area_name
                                get_text_content(td_indices[i+2]),   # price
                                get_text_content(td_indices[i+3])    # seat_status
                            ]

                            # Skip empty TDs (color-tag TDs may be empty)
                            area_name = td_texts[1].strip()
                            if len(area_name) == 0:
                                continue

                            price = td_texts[2].strip()
                            seat_text = td_texts[3].strip()

                            # For giant TR, determine disabled from seat_text
                            # (cannot use TR class since all areas share the same TR)
                            is_area_disabled = ('已售完' in seat_text)

                            # Build area data object
                            area_data = {
                                'index': area_index,
                                'disabled': is_area_disabled,
                                'areaName': area_name,
                                'price': price,
                                'seatText': seat_text,
                                'innerHTML': f'<tr><td>{area_name}</td><td>{price}</td><td>{seat_text}</td></tr>',
                                'tr_node_index': tr_idx,
                                'backend_node_id': tr_backend_node_id
                            }
                            areas_data.append(area_data)
                            area_index += 1
                else:
                    # Standard TR structure: each TR = 1 area
                    # Expected order: [0]=color, [1]=area_name, [2]=price, [3]=seat_status
                    td_texts = []
                    for td_idx in td_indices:
                        td_text = get_text_content(td_idx)
                        td_texts.append(td_text)

                    if len(td_texts) >= 4:
                        area_name = td_texts[1].strip()
                        price = td_texts[2].strip()
                        seat_text = td_texts[3].strip()

                        # Build area data object
                        area_data = {
                            'index': area_index,
                            'disabled': is_disabled,
                            'areaName': area_name,
                            'price': price,
                            'seatText': seat_text,
                            'innerHTML': f'<tr class="{tr_class}"><td>{area_name}</td><td>{price}</td><td>{seat_text}</td></tr>',
                            'tr_node_index': tr_idx,
                            'backend_node_id': tr_backend_node_id
                        }
                        areas_data.append(area_data)
                        area_index += 1

    except Exception as exc:
        if show_debug_message:
            print(f"[NEW EVENT ERROR] Failed to extract area data: {exc}")
            import traceback
            traceback.print_exc()
        return True, False

    if not areas_data or len(areas_data) == 0:
        if show_debug_message:
            print("[ibon] 頁面無區域")
        return True, False

    # Debug extraction (disabled by default)
    # if show_debug_message:
    #     print(f"[IBON EXTRACT DEBUG] Total extracted areas: {len(areas_data)}")

    # Phase 2: Filter areas (disabled, sold out, insufficient seats)
    valid_areas = []

    for area in areas_data:
        # Skip disabled areas
        if area['disabled']:
            if show_debug_message:
                print(f"[ibon] 跳過: {area['areaName']}")
            continue

        # 同時檢查區域名稱、票價與內容
        row_text = area['areaName'] + ' ' + area.get('price', '') + ' ' + util.remove_html_tags(area['innerHTML'])

        # Skip sold out areas
        if '已售完' in area['seatText']:
            if show_debug_message:
                print(f"[ibon] 已售完: {area['areaName']}")
            continue

        # Check exclude keywords
        if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
            if show_debug_message:
                print(f"[ibon] 排除: {area['areaName']}")
            continue

        # Check remaining seat count
        seat_text = area['seatText']
        if seat_text.isdigit():
            remaining_seats = int(seat_text)
            if remaining_seats < ticket_number:
                if show_debug_message:
                    print(f"[ibon] 座位不足: {area['areaName']} ({remaining_seats}/{ticket_number})")
                continue

        valid_areas.append(area)

    if show_debug_message:
        print(f"[ibon] 有效區域: {len(valid_areas)}")

    # Phase 3: Keyword matching with early return pattern (T010-T016)
    matched_areas = []
    target_found = False

    if area_keyword_item and len(area_keyword_item) > 0:
        try:
            # NOTE: area_keyword_item is already a SINGLE keyword string from upper layer
            # Upper layer (line 11225) splits by comma using JSON parsing:
            #   Input: "\"5600\",\"5,600\""
            #   After JSON: ["5600", "5,600"]
            #   This function is called once per keyword: "5600" or "5,600"
            #
            # DO NOT split by comma again here, or "5,600" becomes ['5', '600'] (BUG!)
            # Only support space-separated AND logic within each keyword

            area_keyword_clean = area_keyword_item.strip()
            if area_keyword_clean.startswith('"') and area_keyword_clean.endswith('"'):
                area_keyword_clean = area_keyword_clean[1:-1]

            # Treat the entire string as a single keyword
            keyword_item = area_keyword_clean

            if show_debug_message:
                print(f"[IBON EVENT AREA KEYWORD] Checking keyword: {keyword_item}")
                print(f"[IBON EVENT AREA KEYWORD] Total valid areas: {len(valid_areas)}")
                if len(valid_areas) > 0:
                    print(f"[IBON EVENT AREA KEYWORD] First 5 areas: {[a['areaName'] for a in valid_areas[:5]]}")

            # Check all areas for this keyword
            for area in valid_areas:
                row_text = area['areaName'] + ' ' + area.get('price', '') + ' ' + util.remove_html_tags(area['innerHTML'])
                row_text = util.format_keyword_string(row_text)

                # Support AND logic with space-separated sub-keywords
                # Example: "VIP 區" → ['VIP', '區'] → must match both
                sub_keywords = [kw.strip() for kw in keyword_item.split(' ') if kw.strip()]
                is_match = all(sub_kw.lower() in row_text.lower() for sub_kw in sub_keywords)

                if is_match:
                    # Keyword matched - IMMEDIATELY select and stop
                    matched_areas = [area]
                    target_found = True
                    if show_debug_message:
                        print(f"[IBON EVENT AREA KEYWORD] Keyword matched: '{keyword_item}'")
                        print(f"[IBON EVENT AREA SELECT] Selected area: {area['areaName']} (keyword match)")
                    break

            # All keywords failed log
            if not target_found:
                if show_debug_message:
                    print(f"[IBON EVENT AREA KEYWORD] Keyword '{keyword_item}' failed to match")
        except Exception as e:
            if show_debug_message:
                print(f"[IBON EVENT AREA] Keyword parse error: {e}")
                print(f"[IBON EVENT AREA] Treating as 'all keywords failed'")
            matched_areas = []  # Let Feature 003 fallback logic handle this
    else:
        matched_areas = valid_areas

    if show_debug_message and not target_found:
        print(f"[IBON EVENT AREA] Total matched areas: {len(matched_areas)}")

    # T022-T024: Conditional fallback based on area_auto_fallback switch
    if len(matched_areas) == 0 and area_keyword_item and len(area_keyword_item) > 0:
        if area_auto_fallback:
            # T022: Fallback enabled - use all valid areas
            if show_debug_message:
                print(f"[IBON EVENT AREA FALLBACK] area_auto_fallback=true, triggering auto fallback")
                print(f"[IBON EVENT AREA FALLBACK] Selecting available area based on area_select_order='{auto_select_mode}'")
            matched_areas = valid_areas
        else:
            # T023: Fallback disabled - strict mode (no selection, will reload)
            if show_debug_message:
                print(f"[IBON EVENT AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
                print(f"[IBON EVENT AREA SELECT] No area selected, will reload page and retry")
            # T024: No available options after keyword matching failed
            if len(valid_areas) == 0:
                if show_debug_message:
                    print(f"[IBON EVENT AREA FALLBACK] No available options after exclusion")
            is_need_refresh = True
            return is_need_refresh, False

    # Phase 4: Select target area based on mode
    target_area = util.get_target_item_from_matched_list(matched_areas, auto_select_mode)

    if not target_area:
        is_need_refresh = True
        if show_debug_message:
            print("[ibon] 選擇失敗")
        return is_need_refresh, False

    if show_debug_message:
        print(f"[ibon] 已選: {target_area['areaName']}")

    # Phase 5: Click target area using CDP
    try:
        from nodriver import cdp

        if show_debug_message:
            print(f"[NEW EVENT CDP CLICK] Starting CDP click for area: {target_area['areaName']}")

        backend_node_id = target_area.get('backend_node_id')

        if not backend_node_id:
            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] No backend_node_id available for TR")
            return is_need_refresh, is_price_assign_by_bot

        # Request document first
        try:
            document = await tab.send(cdp.dom.get_document(depth=-1, pierce=True))
            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Requested document with pierce=True")
        except Exception as doc_exc:
            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Document request failed: {doc_exc}")
            return is_need_refresh, is_price_assign_by_bot

        # Convert backend_node_id to node_id
        try:
            result = await tab.send(cdp.dom.push_nodes_by_backend_ids_to_frontend(backend_node_ids=[backend_node_id]))
            node_ids = result if isinstance(result, list) else (result.node_ids if hasattr(result, 'node_ids') else [])

            if not node_ids or len(node_ids) == 0:
                if show_debug_message:
                    print(f"[NEW EVENT CDP CLICK] Failed to convert backend_node_id to node_id")
                return is_need_refresh, is_price_assign_by_bot

            node_id = node_ids[0]

            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Node ID: {node_id}")

            # Scroll into view
            try:
                await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=node_id))
                if show_debug_message:
                    print(f"[NEW EVENT CDP CLICK] Scrolled element into view")
            except Exception as e:
                if show_debug_message:
                    print(f"[NEW EVENT CDP CLICK] Scroll warning: {e}")

            # Focus element
            try:
                await tab.send(cdp.dom.focus(node_id=node_id))
                if show_debug_message:
                    print(f"[NEW EVENT CDP CLICK] Focused element")
            except Exception as e:
                if show_debug_message:
                    print(f"[NEW EVENT CDP CLICK] Focus warning: {e}")

            # Get box model
            box_model = await tab.send(cdp.dom.get_box_model(node_id=node_id))
            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Got box model")

            # Calculate center point
            content_quad = box_model.content if hasattr(box_model, 'content') else box_model.model.content
            x = (content_quad[0] + content_quad[2]) / 2
            y = (content_quad[1] + content_quad[5]) / 2

            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Click position: ({x:.1f}, {y:.1f})")

            # Execute mouse click
            await tab.mouse_click(x, y)

            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Mouse click executed successfully")

            # Wait for navigation
            await tab.sleep(1.5)

            is_price_assign_by_bot = True

            if show_debug_message:
                print(f"[NEW EVENT SUCCESS] Clicked area: {target_area['areaName']}")

        except Exception as resolve_exc:
            if show_debug_message:
                print(f"[NEW EVENT CDP CLICK] Resolve/click failed: {resolve_exc}")
                import traceback
                traceback.print_exc()

    except Exception as exc:
        if show_debug_message:
            print(f"[NEW EVENT ERROR] Exception during click: {exc}")
            import traceback
            traceback.print_exc()

    return is_need_refresh, is_price_assign_by_bot

async def nodriver_ibon_area_auto_select(tab, config_dict, area_keyword_item=""):
    """
    ibon seat area auto-selection (NoDriver version)

    Handles seat area selection on UTK0201_000.aspx page after date selection.
    Uses JavaScript for data extraction and CDP for clicking.

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary
        area_keyword_item: Area keyword string (space-separated for AND logic)

    Returns:
        tuple: (is_need_refresh, is_price_assign_by_bot)
            - is_need_refresh: Whether page refresh is needed
            - is_price_assign_by_bot: Whether area selection succeeded
    """
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False, False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get('area_auto_fallback', False)  # T021: Safe access for new field
    ticket_number = config_dict["ticket_number"]

    is_price_assign_by_bot = False
    is_need_refresh = False

    if show_debug_message:
        print("NoDriver ibon_area_auto_select started")
        print(f"area_keyword_item: {area_keyword_item}")
        print(f"auto_select_mode: {auto_select_mode}")
        print(f"ticket_number: {ticket_number}")

    # Wait for Shadow DOM to fully load (ibon orders page needs more time for TR elements to render)
    # Auto-detect TR elements (no fixed wait - responds immediately when ready)
    try:
        # First, ensure page state is synced
        await tab  # Sync state

        # Quick check: Is this actually an area selection page?
        # If URL is verification page (UTK0201_0.aspx with rn=), skip area selection
        try:
            current_url = tab.target.url
            if current_url and '/UTK02/UTK0201_0.' in current_url.upper() and 'rn=' in current_url.lower():
                if show_debug_message:
                    print("[IBON AREA] Detected verification page URL, skipping area selection")
                # Return (False, False) to skip reload and let main loop re-check URL
                return False, False
        except:
            pass

        # Quick check: Does page have Cloudflare or verification form instead of area table?
        try:
            import time as time_module
            cloudflare_max_wait = 15  # Maximum wait for Cloudflare (seconds)
            cloudflare_check_interval = 0.5  # Check interval (seconds)
            cloudflare_start_time = time_module.time()
            cloudflare_detected_once = False
            page_type_result = "area"

            while (time_module.time() - cloudflare_start_time) < cloudflare_max_wait:
                page_type_result = await tab.evaluate('''
                    (function() {
                        // Check for Cloudflare verification page
                        var bodyText = document.body ? document.body.innerText : '';
                        var title = document.title || '';

                        // Cloudflare indicators
                        if (title === '請稍候...' ||
                            bodyText.indexOf('正在驗證') !== -1 ||
                            bodyText.indexOf('驗證您是否是人類') !== -1 ||
                            bodyText.indexOf('Checking your browser') !== -1 ||
                            bodyText.indexOf('verify you are human') !== -1) {
                            return "cloudflare";
                        }

                        // Check for ibon verification form markers
                        var verifyInputs = document.querySelectorAll('#content div.form-group input');
                        var areaTable = document.querySelector('table.table, table[class*="area"], tbody tr td a');

                        if (verifyInputs.length > 0 && !areaTable) {
                            return "verify";
                        }
                        return "area";
                    })()
                ''')

                if page_type_result == "cloudflare":
                    if not cloudflare_detected_once:
                        cloudflare_detected_once = True
                        if show_debug_message:
                            print("[IBON AREA] Detected Cloudflare verification, waiting for completion...")
                    # Continue waiting, check again
                    await tab.sleep(cloudflare_check_interval)
                    continue
                elif page_type_result == "verify":
                    if show_debug_message:
                        print("[IBON AREA] Detected verification form, skipping area selection")
                    return False, False
                else:
                    # page_type_result == "area" - Cloudflare completed or not present
                    if cloudflare_detected_once and show_debug_message:
                        elapsed = time_module.time() - cloudflare_start_time
                        print(f"[IBON AREA] Cloudflare verification completed after {elapsed:.1f}s")
                    break

            # If timeout while Cloudflare still active
            if cloudflare_detected_once and page_type_result == "cloudflare":
                if show_debug_message:
                    print("[IBON AREA] Cloudflare verification timeout, letting main loop retry")
                return False, False

        except Exception as cf_exc:
            if show_debug_message:
                print(f"[IBON AREA] Cloudflare/page type check error: {cf_exc}")
            pass

        # Initialize CDP DOM state (required for perform_search to work)
        try:
            await tab.send(cdp.dom.get_document(depth=0, pierce=False))
        except:
            pass

        import time
        max_wait = 5  # Maximum wait (increased for page load after Cloudflare)
        check_interval = 0.15  # Polling interval
        start_time = time.time()
        min_tr_count = 3  # Minimum TR elements to consider page loaded (header + at least 1 data row)

        if show_debug_message:
            print("[IBON AREA] Auto-detecting area table...")

        last_tr_count = 0
        stable_count = 0  # Track if TR count is stable (page finished loading)

        while (time.time() - start_time) < max_wait:
            # Check if URL changed to verification page (UTK0201_0.aspx)
            try:
                current_url = tab.target.url
                if current_url and '/UTK02/UTK0201_0.' in current_url.upper() and 'rn=' in current_url.lower():
                    if show_debug_message:
                        print("[IBON AREA] URL changed to verification page, exiting area selection")
                    # Return (False, False) to skip reload and let main loop re-check URL
                    return False, False
            except:
                pass

            try:
                # Use CDP search to check TR presence (penetrates Shadow DOM)
                search_id, tr_count = await tab.send(cdp.dom.perform_search(
                    query='tbody tr',
                    include_user_agent_shadow_dom=True
                ))

                # Clean up search
                try:
                    await tab.send(cdp.dom.discard_search_results(search_id=search_id))
                except:
                    pass

                # Check if TR count is stable (same as last check)
                if tr_count == last_tr_count and tr_count >= min_tr_count:
                    stable_count += 1
                else:
                    stable_count = 0
                last_tr_count = tr_count

                # Page loaded: minimum TR count reached AND stable for 2 consecutive checks
                if tr_count >= min_tr_count and stable_count >= 1:
                    elapsed = time.time() - start_time
                    if show_debug_message:
                        print(f"[IBON AREA] Found {tr_count} TR elements after {elapsed:.2f}s")
                    break
            except:
                pass

            await tab.sleep(check_interval)

    except Exception as e:
        if show_debug_message:
            print(f"[IBON AREA] Error during auto-detect: {e}")
        pass

    # Phase 1: Extract all area data using DOMSnapshot (to pierce closed Shadow DOM)
    try:
        # cdp already imported at function start (Line 10535)

        if show_debug_message:
            print("[DOMSNAPSHOT] Capturing page structure for area extraction...")

        # Use DOMSnapshot to get flattened page structure (pierces Shadow DOM)
        documents, strings = await tab.send(cdp.dom_snapshot.capture_snapshot(
            computed_styles=[],
            include_paint_order=True,
            include_dom_rects=True
        ))

        areas_data = []

        if documents and len(documents) > 0:
            document_snapshot = documents[0]

            # Extract node information
            node_names = []
            node_values = []
            parent_indices = []
            attributes_list = []
            backend_node_ids = []

            if hasattr(document_snapshot, 'nodes'):
                nodes = document_snapshot.nodes
                if hasattr(nodes, 'node_name'):
                    node_names = [strings[i] if isinstance(i, int) and i < len(strings) else str(i)
                                 for i in nodes.node_name]
                if hasattr(nodes, 'node_value'):
                    node_values = [strings[i] if isinstance(i, int) and i >= 0 and i < len(strings) else ''
                                  for i in nodes.node_value]
                if hasattr(nodes, 'parent_index'):
                    parent_indices = list(nodes.parent_index)
                if hasattr(nodes, 'attributes'):
                    attributes_list = nodes.attributes
                if hasattr(nodes, 'backend_node_id'):
                    backend_node_ids = list(nodes.backend_node_id)

            if show_debug_message:
                print(f"[DOMSNAPSHOT] Extracted {len(node_names)} nodes, {len(strings)} strings")


            # Build children map for traversal
            children_map = {}
            for i, parent_idx in enumerate(parent_indices):
                if parent_idx >= 0:
                    if parent_idx not in children_map:
                        children_map[parent_idx] = []
                    children_map[parent_idx].append(i)

            # Helper function to get attributes as dict
            def get_attributes_dict(node_index):
                attrs = {}
                if node_index < len(attributes_list):
                    attr_indices = attributes_list[node_index]
                    for j in range(0, len(attr_indices), 2):
                        if j + 1 < len(attr_indices):
                            key_idx = attr_indices[j]
                            val_idx = attr_indices[j + 1]
                            key = strings[key_idx] if key_idx < len(strings) else ''
                            val = strings[val_idx] if val_idx < len(strings) else ''
                            attrs[key] = val
                return attrs

            # Helper function to get all text content from node and its children
            def get_text_content(node_index, depth=0, max_depth=10):
                if depth > max_depth or node_index >= len(node_names):
                    return ''

                text_parts = []

                # If this is a text node, get its value
                if node_names[node_index] == '#text' and node_index < len(node_values):
                    text_parts.append(node_values[node_index])

                # Recursively get text from children
                if node_index in children_map:
                    for child_idx in children_map[node_index]:
                        child_text = get_text_content(child_idx, depth + 1, max_depth)
                        if child_text:
                            text_parts.append(child_text)

                return ' '.join(text_parts).strip()

            # Find all TR elements in the table
            tr_indices = []
            for i, node_name in enumerate(node_names):
                if node_name.upper() == 'TR':
                    # Check if it's inside a table (basic check)
                    tr_indices.append(i)

            if show_debug_message:
                print(f"[DOMSNAPSHOT] Found {len(tr_indices)} TR elements")

            # Extract data from each TR
            area_index = 0
            for tr_idx in tr_indices:
                # Get TR attributes
                tr_attrs = get_attributes_dict(tr_idx)
                tr_id = tr_attrs.get('id', '')
                tr_class = tr_attrs.get('class', '')

                # Skip header rows (check if parent is THEAD)
                parent_idx = parent_indices[tr_idx] if tr_idx < len(parent_indices) else -1
                is_header = False
                if parent_idx >= 0 and parent_idx < len(node_names):
                    parent_name = node_names[parent_idx].upper()
                    if parent_name == 'THEAD':
                        is_header = True

                if is_header:
                    continue

                is_disabled = 'disabled' in tr_class.lower()

                # Find TD children
                td_indices = []
                if tr_idx in children_map:
                    for child_idx in children_map[tr_idx]:
                        if node_names[child_idx].upper() == 'TD':
                            td_indices.append(child_idx)

                # Extract text from each TD
                # Expected order: [0]=color, [1]=area_name, [2]=price, [3]=seat_status
                td_texts = []
                for td_idx in td_indices:
                    td_text = get_text_content(td_idx)
                    td_texts.append(td_text)

                if len(td_texts) >= 4:
                    area_name = td_texts[1].strip()
                    price = td_texts[2].strip()
                    seat_text = td_texts[3].strip()

                    # Get layout information (bounding box) for this TR
                    layout_rect = None
                    if hasattr(document_snapshot, 'layout'):
                        layout = document_snapshot.layout
                        if hasattr(layout, 'node_index') and hasattr(layout, 'bounds'):
                            # Find this TR's layout index
                            node_indices = list(layout.node_index)
                            bounds_list = list(layout.bounds)

                            if tr_idx in node_indices:
                                layout_idx = node_indices.index(tr_idx)
                                # bounds is an array of Rectangle objects: [x_rect, y_rect, width_rect, height_rect, ...]
                                bounds_idx = layout_idx * 4
                                if bounds_idx + 3 < len(bounds_list):
                                    # Each bound is a Rectangle object, extract the first value
                                    x_rect = bounds_list[bounds_idx]
                                    y_rect = bounds_list[bounds_idx + 1]
                                    width_rect = bounds_list[bounds_idx + 2]
                                    height_rect = bounds_list[bounds_idx + 3]

                                    # Rectangle objects contain an array, get the first value
                                    x = x_rect[0] if hasattr(x_rect, '__getitem__') else float(x_rect)
                                    y = y_rect[0] if hasattr(y_rect, '__getitem__') else float(y_rect)
                                    width = width_rect[0] if hasattr(width_rect, '__getitem__') else float(width_rect)
                                    height = height_rect[0] if hasattr(height_rect, '__getitem__') else float(height_rect)

                                    layout_rect = {'x': x, 'y': y, 'width': width, 'height': height}
                                    if show_debug_message and area_index < 3:  # Only show first 3 for debugging
                                        print(f"[DOMSNAPSHOT] TR #{area_index} (node {tr_idx}): layout_idx={layout_idx}, rect={layout_rect}")
                            else:
                                if show_debug_message and area_index < 3:
                                    print(f"[DOMSNAPSHOT] TR #{area_index} (node {tr_idx}): NOT in layout.node_index")

                    # Get backend_node_id for this TR
                    tr_backend_node_id = None
                    if tr_idx < len(backend_node_ids):
                        tr_backend_node_id = backend_node_ids[tr_idx]

                    # Build area data object (matching JavaScript version format)
                    area_data = {
                        'index': area_index,
                        'id': tr_id,
                        'disabled': is_disabled,
                        'areaName': area_name,
                        'price': price,
                        'seatText': seat_text,
                        'innerHTML': f'<tr id="{tr_id}" class="{tr_class}">...mock...</tr>',  # Mock HTML for compatibility
                        'tr_node_index': tr_idx,  # Store for reference
                        'layout_rect': layout_rect,  # Store bounding box for clicking
                        'backend_node_id': tr_backend_node_id  # Store for CDP node resolution
                    }
                    areas_data.append(area_data)
                    area_index += 1

        if show_debug_message:
            print(f"[AREA EXTRACT] Found {len(areas_data)} total areas")

    except Exception as exc:
        if show_debug_message:
            print(f"[ERROR] Failed to extract area data: {exc}")
            import traceback
            traceback.print_exc()
        return True, False

    if not areas_data or len(areas_data) == 0:
        if show_debug_message:
            print("[AREA EXTRACT] No areas found on page")
        return True, False

    # Phase 2: Filter areas (disabled, sold out, insufficient seats)
    valid_areas = []

    for area in areas_data:
        # Skip disabled areas
        if area['disabled']:
            if show_debug_message:
                print(f"[ibon] 跳過: {area['areaName']}")
            continue

        # 同時檢查區域名稱、票價與內容
        row_text = area['areaName'] + ' ' + area.get('price', '') + ' ' + util.remove_html_tags(area['innerHTML'])

        # Skip sold out areas
        if '已售完' in area['seatText']:
            if show_debug_message:
                print(f"[ibon] 已售完: {area['areaName']}")
            continue

        if 'disabled' in area['innerHTML'].lower() or 'sold-out' in area['innerHTML'].lower():
            if show_debug_message:
                print(f"[ibon] 跳過: {area['areaName']}")
            continue

        # Skip description rows (not actual seat areas)
        if row_text in ["座位已被選擇", "座位已售出", "舞台區域"]:
            continue

        # Check exclude keywords
        if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
            if show_debug_message:
                print(f"[ibon] 排除: {area['areaName']}")
            continue

        # Check remaining seat count
        seat_text = area['seatText']
        if seat_text.isdigit():
            remaining_seats = int(seat_text)
            if remaining_seats < ticket_number:
                if show_debug_message:
                    print(f"[ibon] 座位不足: {area['areaName']} ({remaining_seats}/{ticket_number})")
                continue

        valid_areas.append(area)

    if show_debug_message:
        print(f"[ibon] 有效區域: {len(valid_areas)}")

    # Phase 3: Keyword matching with early return pattern (T010-T016)
    matched_areas = []
    target_found = False

    if area_keyword_item and len(area_keyword_item) > 0:
        try:
            # NOTE: area_keyword_item is already a SINGLE keyword string from upper layer
            # Upper layer (line 10908) splits by comma using JSON parsing:
            #   Input: "\"5600\",\"5,600\""
            #   After JSON: ["5600", "5,600"]
            #   This function is called once per keyword: "5600" or "5,600"
            #
            # DO NOT split by comma again here, or "5,600" becomes ['5', '600'] (BUG!)
            # Only support space-separated AND logic within each keyword

            area_keyword_clean = area_keyword_item.strip()
            if area_keyword_clean.startswith('"') and area_keyword_clean.endswith('"'):
                area_keyword_clean = area_keyword_clean[1:-1]

            # Treat the entire string as a single keyword
            keyword_item = area_keyword_clean

            if show_debug_message:
                print(f"[IBON AREA KEYWORD] Checking keyword: {keyword_item}")

            # Check all areas for this keyword
            for area in valid_areas:
                row_text = area['areaName'] + ' ' + area.get('price', '') + ' ' + util.remove_html_tags(area['innerHTML'])
                row_text = util.format_keyword_string(row_text)

                # Support AND logic with space-separated sub-keywords
                # Example: "VIP 區" → ['VIP', '區'] → must match both
                sub_keywords = [kw.strip() for kw in keyword_item.split(' ') if kw.strip()]
                is_match = all(sub_kw.lower() in row_text.lower() for sub_kw in sub_keywords)

                if is_match:
                    # Keyword matched - IMMEDIATELY select and stop
                    matched_areas = [area]
                    target_found = True
                    if show_debug_message:
                        print(f"[IBON AREA KEYWORD] Keyword matched: '{keyword_item}'")
                        print(f"[IBON AREA SELECT] Selected area: {area['areaName']} (keyword match)")
                    break

            # All keywords failed log
            if not target_found:
                if show_debug_message:
                    print(f"[IBON AREA KEYWORD] Keyword '{keyword_item}' failed to match")
        except Exception as e:
            if show_debug_message:
                print(f"[IBON AREA] Keyword parse error: {e}")
                print(f"[IBON AREA] Treating as 'all keywords failed'")
            matched_areas = []  # Let Feature 003 fallback logic handle this
    else:
        matched_areas = valid_areas

    if show_debug_message and not target_found:
        print(f"[IBON AREA] Total matched areas: {len(matched_areas)}")

    # T022-T024: Conditional fallback based on area_auto_fallback switch
    if len(matched_areas) == 0 and area_keyword_item and len(area_keyword_item) > 0:
        if area_auto_fallback:
            # T022: Fallback enabled - use all valid areas
            if show_debug_message:
                print(f"[IBON AREA FALLBACK] area_auto_fallback=true, triggering auto fallback")
                print(f"[IBON AREA FALLBACK] Selecting available area based on area_select_order='{auto_select_mode}'")
            matched_areas = valid_areas
        else:
            # T023: Fallback disabled - strict mode (no selection, will reload)
            if show_debug_message:
                print(f"[IBON AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
                print(f"[IBON AREA SELECT] No area selected, will reload page and retry")
            # T024: No available options after keyword matching failed
            if len(valid_areas) == 0:
                if show_debug_message:
                    print(f"[IBON AREA FALLBACK] No available options after exclusion")
            is_need_refresh = True
            return is_need_refresh, False

    # Phase 4: Select target area based on mode
    target_area = util.get_target_item_from_matched_list(matched_areas, auto_select_mode)

    if not target_area:
        is_need_refresh = True
        if show_debug_message:
            print("[RESULT] Failed to select target area, refresh needed")
        return is_need_refresh, False

    # T013 equivalent: Log selected area with selection type
    if show_debug_message:
        is_keyword_match = (area_keyword_item and len(area_keyword_item) > 0 and len(matched_areas) < len(valid_areas))
        selection_type = "keyword match" if is_keyword_match else "fallback"
        print(f"[IBON AREA SELECT] Selected area: {target_area['areaName']} ({selection_type})")
        print(f"[TARGET] Selected area: {target_area['areaName']} (index: {target_area['index']}, id: {target_area['id']})")

    # Phase 5: Click target area using CDP real-time coordinates
    try:
        # cdp already imported at file start (Line 29)

        # Get backend_node_id from target area
        backend_node_id = target_area.get('backend_node_id')

        if not backend_node_id:
            if show_debug_message:
                print(f"[CDP CLICK] No backend_node_id available for TR")
        else:
            # Request document first (required for pushNodesByBackendIdsToFrontend)
            try:
                document = await tab.send(cdp.dom.get_document(depth=-1, pierce=True))
            except Exception as doc_exc:
                if show_debug_message:
                    print(f"[CDP CLICK] Document request failed: {doc_exc}")
                return is_need_refresh, is_price_assign_by_bot

            # Convert backend_node_id to node_id using pushNodesByBackendIdsToFrontend
            try:
                result = await tab.send(cdp.dom.push_nodes_by_backend_ids_to_frontend(backend_node_ids=[backend_node_id]))
                node_ids = result if isinstance(result, list) else (result.node_ids if hasattr(result, 'node_ids') else [])

                if not node_ids or len(node_ids) == 0:
                    if show_debug_message:
                        print(f"[CDP CLICK] Failed to convert backend_node_id to node_id")
                    return is_need_refresh, is_price_assign_by_bot

                node_id = node_ids[0]

                # Scroll into view
                try:
                    await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=node_id))
                except Exception:
                    pass  # Scroll not always needed

                # Focus element (ignore focus warnings)
                try:
                    await tab.send(cdp.dom.focus(node_id=node_id))
                except Exception:
                    pass  # Element may not be focusable

                # Get real-time box model and click
                box_model = await tab.send(cdp.dom.get_box_model(node_id=node_id))
                content_quad = box_model.content if hasattr(box_model, 'content') else box_model.model.content
                x = (content_quad[0] + content_quad[2]) / 2
                y = (content_quad[1] + content_quad[5]) / 2

                # Execute mouse click
                await tab.mouse_click(x, y)

                # Wait for navigation
                await tab.sleep(random.uniform(0.5, 0.8))

                is_price_assign_by_bot = True

                if show_debug_message:
                    print(f"[CLICK SUCCESS] Clicked area: {target_area['areaName']} (id: {target_area['id']})")

            except Exception as resolve_exc:
                if show_debug_message:
                    print(f"[CDP CLICK] Resolve/click failed: {resolve_exc}")
                    import traceback
                    traceback.print_exc()

    except Exception as exc:
        if show_debug_message:
            print(f"[CLICK ERROR] Exception during click: {exc}")
            import traceback
            traceback.print_exc()

    return is_need_refresh, is_price_assign_by_bot

async def nodriver_ibon_ticket_number_auto_select(tab, config_dict):
    """
    ibon ticket number auto-selection using NoDriver CDP with keyword matching

    Enhancement (2026-01-07):
    - Supports ticket type keyword matching using area_keyword
    - Supports keyword exclusion using keyword_exclude
    - Respects auto_select_mode for fallback selection

    Returns: is_ticket_number_assigned (bool)
    """
    # Check pause at function start
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    ticket_number = str(config_dict.get("ticket_number", 2))
    is_ticket_number_assigned = False

    # Get keyword settings for ticket type matching
    area_keyword = config_dict["area_auto_select"].get("area_keyword", "").strip()
    keyword_exclude = config_dict.get("keyword_exclude", "")
    auto_select_mode = config_dict["area_auto_select"].get("mode", 1)

    try:
        # Step 1: Wait for SELECT element
        wait_result = await tab.evaluate('''
            () => {
                return new Promise((resolve) => {
                    let attempts = 0;
                    const maxAttempts = 15;

                    const checkSelect = setInterval(() => {
                        attempts++;

                        let select = document.querySelector('table.rwdtable select.form-control-sm') ||
                                    document.querySelector('table.table select[name*="AMOUNT_DDL"]') ||
                                    document.querySelector('select.form-control-sm');

                        if (select) {
                            clearInterval(checkSelect);
                            resolve({ready: true, selector_used: select.className || select.name});
                        } else if (attempts >= maxAttempts) {
                            clearInterval(checkSelect);
                            resolve({ready: false, error: "Timeout waiting for SELECT element"});
                        }
                    }, 100);
                });
            }
        ''')

        wait_parsed = util.parse_nodriver_result(wait_result)
        if show_debug_message and isinstance(wait_parsed, dict):
            if wait_parsed.get('ready'):
                print(f"[TICKET DOM] SELECT element ready: {wait_parsed.get('selector_used')}")
            else:
                print(f"[TICKET DOM] {wait_parsed.get('error')}")

        # Step 2: Extract all ticket types with their names and availability
        ticket_types_result = await tab.evaluate(f'''
            (function() {{
                let ticketTypes = [];
                const targetTicketNumber = "{ticket_number}";

                // Try new format first (table.rwdtable)
                let rows = document.querySelectorAll('table.rwdtable tbody tr');
                let tableType = 'rwdtable';

                // Fallback to old format (table.table)
                if (rows.length === 0) {{
                    rows = document.querySelectorAll('table.table tbody tr');
                    tableType = 'table';
                }}

                rows.forEach((row, index) => {{
                    // Find SELECT element in this row
                    let select = row.querySelector('select.form-control-sm') ||
                                row.querySelector('select[name*="AMOUNT_DDL"]');

                    if (!select) return;

                    // Get ticket type name from first cell
                    let nameCell = row.querySelector('td:first-child, td[data-title]');
                    let ticketName = nameCell ? nameCell.textContent.trim() : '';

                    // Get price from price cell
                    let priceCell = row.querySelector('td:nth-child(3)');
                    let price = priceCell ? priceCell.textContent.trim() : '';

                    // Check if this ticket type has valid options (not sold out)
                    let hasValidOption = Array.from(select.options).some(
                        opt => opt.value !== '0' && opt.value !== ''
                    );

                    // Check current value
                    let currentValue = select.value;
                    let isAlreadySelected = currentValue !== '0' && currentValue !== '';

                    // Check if target ticket_number option exists
                    let hasTargetOption = Array.from(select.options).some(
                        opt => opt.value === targetTicketNumber
                    );

                    ticketTypes.push({{
                        index: index,
                        name: ticketName,
                        price: price,
                        hasValidOption: hasValidOption,
                        isAlreadySelected: isAlreadySelected,
                        currentValue: currentValue,
                        hasTargetOption: hasTargetOption,
                        selectName: select.name || ''
                    }});
                }});

                return {{
                    ticketTypes: ticketTypes,
                    tableType: tableType,
                    totalRows: rows.length
                }};
            }})();
        ''')

        ticket_types_parsed = util.parse_nodriver_result(ticket_types_result)

        if not isinstance(ticket_types_parsed, dict):
            if show_debug_message:
                print(f"[TICKET] Failed to parse ticket types")
            return False

        ticket_types = ticket_types_parsed.get('ticketTypes', [])

        if show_debug_message:
            print(f"[TICKET] Found {len(ticket_types)} ticket type(s)")
            for tt in ticket_types:
                status = "selected" if tt.get('isAlreadySelected') else ("available" if tt.get('hasValidOption') else "sold out")
                print(f"  [{tt.get('index')}] {tt.get('name')} - {tt.get('price')} ({status})")

        if len(ticket_types) == 0:
            if show_debug_message:
                print(f"[TICKET] No ticket types found")
            return False

        # Step 3: Check if any ticket type is already selected
        for tt in ticket_types:
            if tt.get('isAlreadySelected'):
                if show_debug_message:
                    print(f"[TICKET] Already assigned: {tt.get('name')} = {tt.get('currentValue')}")
                return True

        # Step 4: Filter valid ticket types (with available options)
        valid_tickets = [tt for tt in ticket_types if tt.get('hasValidOption')]

        if len(valid_tickets) == 0:
            if show_debug_message:
                print(f"[TICKET] All ticket types sold out")
            return False

        # Step 5: Apply keyword_exclude filter
        filtered_tickets = []
        for ticket in valid_tickets:
            ticket_name = ticket.get('name', '')
            if keyword_exclude and len(keyword_exclude) > 0:
                if util.reset_row_text_if_match_keyword_exclude(config_dict, ticket_name):
                    if show_debug_message:
                        print(f"[TICKET] Excluded by keyword: {ticket_name}")
                    continue
            filtered_tickets.append(ticket)

        if len(filtered_tickets) == 0:
            if show_debug_message:
                print(f"[TICKET] All ticket types excluded by keyword_exclude")
            # Fallback to valid_tickets if all excluded
            filtered_tickets = valid_tickets

        # Step 5.5: Shortcut for single ticket type (skip keyword matching)
        # Fix (2026-01-07): If only 1 valid ticket type, select it directly
        if len(filtered_tickets) == 1:
            matched_ticket = filtered_tickets[0]
            if show_debug_message:
                print(f"[TICKET] Single ticket type, selecting directly: {matched_ticket.get('name')}")
        else:
            # Step 6: Apply area_keyword matching (for multiple ticket types)
            matched_ticket = None

            if area_keyword and len(area_keyword) > 0:
                # Parse keyword array (supports "kw1","kw2" format)
                try:
                    area_keyword_array = json.loads("[" + area_keyword + "]")
                except:
                    area_keyword_array = [area_keyword]

                # Try each keyword in priority order
                for keyword_item in area_keyword_array:
                    keyword_item = keyword_item.strip()
                    if not keyword_item:
                        continue

                    for ticket in filtered_tickets:
                        ticket_name = ticket.get('name', '')
                        row_text = util.format_keyword_string(ticket_name)

                        # Support AND logic (space-separated keywords must all match)
                        keyword_parts = [kw.strip() for kw in keyword_item.split(' ') if kw.strip()]
                        is_match = all(
                            util.format_keyword_string(kw) in row_text
                            for kw in keyword_parts
                        )

                        if is_match:
                            matched_ticket = ticket
                            if show_debug_message:
                                print(f"[TICKET] Keyword matched: '{keyword_item}' -> {ticket_name}")
                            break

                    if matched_ticket:
                        break

                if not matched_ticket and show_debug_message:
                    print(f"[TICKET] No ticket matched keyword: {area_keyword}")

        # Step 7: Fallback selection if no keyword match
        if not matched_ticket:
            if len(filtered_tickets) > 0:
                # Use auto_select_mode for fallback
                matched_ticket = util.get_target_item_from_matched_list(
                    filtered_tickets, auto_select_mode
                )
                if show_debug_message:
                    print(f"[TICKET] Fallback selection: {matched_ticket.get('name') if matched_ticket else 'None'}")

        if not matched_ticket:
            if show_debug_message:
                print(f"[TICKET] No suitable ticket type found")
            return False

        # Step 8: Set the ticket quantity for the matched ticket type
        target_index = matched_ticket.get('index', 0)
        has_target_option = matched_ticket.get('hasTargetOption', False)

        # Determine which value to set
        value_to_set = ticket_number if has_target_option else "1"

        result = await tab.evaluate(f'''
            (function() {{
                // Find all rows
                let rows = document.querySelectorAll('table.rwdtable tbody tr');
                if (rows.length === 0) {{
                    rows = document.querySelectorAll('table.table tbody tr');
                }}

                if ({target_index} >= rows.length) {{
                    return {{success: false, error: "Target row index out of range"}};
                }}

                let row = rows[{target_index}];
                let select = row.querySelector('select.form-control-sm') ||
                            row.querySelector('select[name*="AMOUNT_DDL"]');

                if (!select) {{
                    return {{success: false, error: "SELECT not found in target row"}};
                }}

                // Set the value
                select.value = "{value_to_set}";

                // Trigger events
                select.dispatchEvent(new Event('input', {{bubbles: true}}));
                select.dispatchEvent(new Event('change', {{bubbles: true}}));
                select.dispatchEvent(new Event('blur', {{bubbles: true}}));

                // Verify
                const finalValue = select.value;
                if (finalValue !== "{value_to_set}") {{
                    return {{success: false, error: "Value verification failed", expected: "{value_to_set}", actual: finalValue}};
                }}

                return {{
                    success: true,
                    set_value: "{value_to_set}",
                    ticket_name: row.querySelector('td:first-child')?.textContent.trim() || '',
                    verified: true
                }};
            }})();
        ''')

        result_parsed = util.parse_nodriver_result(result)

        if isinstance(result_parsed, dict):
            if result_parsed.get('success'):
                is_ticket_number_assigned = True
                ticket_name = result_parsed.get('ticket_name', '')
                set_value = result_parsed.get('set_value', '')
                if show_debug_message:
                    if value_to_set != ticket_number:
                        print(f"[TICKET] Set '{ticket_name}' to {set_value} (fallback, target {ticket_number} not available)")
                    else:
                        print(f"[TICKET] Set '{ticket_name}' to {set_value}")
            else:
                if show_debug_message:
                    print(f"[TICKET] Failed: {result_parsed.get('error')}")

    except Exception as exc:
        if show_debug_message:
            print(f"[TICKET ERROR] Exception: {exc}")
            import traceback
            traceback.print_exc()

    return is_ticket_number_assigned

async def nodriver_ibon_get_captcha_image_from_shadow_dom(tab, config_dict):
    """
    Use DOMSnapshot to find captcha image inside Shadow DOM and get base64 data
    Returns: img_base64 (bytes) or None
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Wait for page to stabilize before capturing
    import random
    await asyncio.sleep(random.uniform(0.5, 0.8))

    img_base64 = None

    try:
        # Get DOMSnapshot with Shadow DOM content
        documents, strings = await tab.send(cdp.dom_snapshot.capture_snapshot(
            computed_styles=[],
            include_dom_rects=True,
            include_paint_order=False
        ))

        # Find IMG element with captcha - get both URL and backend_node_id in one pass
        target_img_url = None
        img_backend_node_id = None

        for doc in documents:
            node_names = [strings[i] for i in doc.nodes.node_name]

            for idx, node_name in enumerate(node_names):
                if node_name.lower() == 'img':
                    if doc.nodes.attributes and idx < len(doc.nodes.attributes):
                        attrs = doc.nodes.attributes[idx]
                        attr_dict = {}
                        for i in range(0, len(attrs), 2):
                            if i + 1 < len(attrs):
                                attr_name = strings[attrs[i]]
                                attr_value = strings[attrs[i + 1]]
                                attr_dict[attr_name] = attr_value

                        if '/pic.aspx?TYPE=' in attr_dict.get('src', ''):
                            target_img_url = attr_dict.get('src', '')
                            if hasattr(doc.nodes, 'backend_node_id') and idx < len(doc.nodes.backend_node_id):
                                img_backend_node_id = doc.nodes.backend_node_id[idx]

                            if show_debug_message:
                                print(f"[CAPTCHA] Found IMG: {target_img_url}")
                            break

            if img_backend_node_id:
                break

        if not img_backend_node_id:
            # Try finding CANVAS element (new EventBuy format)
            if show_debug_message:
                print("[CAPTCHA] IMG not found, searching for CANVAS element...")
            
            for doc in documents:
                node_names = [strings[i] for i in doc.nodes.node_name]
                
                for idx, node_name in enumerate(node_names):
                    if node_name.lower() == 'canvas':
                        # Found CANVAS element, use it for captcha
                        if hasattr(doc.nodes, 'backend_node_id') and idx < len(doc.nodes.backend_node_id):
                            img_backend_node_id = doc.nodes.backend_node_id[idx]
                            
                            if show_debug_message:
                                print(f"[CAPTCHA] Found CANVAS element")
                            break
                
                if img_backend_node_id:
                    break
        
        if not img_backend_node_id:
            if show_debug_message:
                print("[CAPTCHA] Neither IMG nor CANVAS found")
            return None


        # Make URL absolute if needed
        if target_img_url and target_img_url.startswith('/'):
            current_url = tab.target.url
            domain = '/'.join(current_url.split('/')[:3])
            target_img_url = domain + target_img_url

        # Use CDP DOM API to get IMG element position and screenshot
        try:

            if img_backend_node_id:
                # Initialize DOM document first (required after page reload)
                try:
                    await tab.send(cdp.dom.get_document())
                except:
                    pass  # Document may already be initialized

                # Convert backend_node_id to node_id using DOM.pushNodesByBackendIdsToFrontend
                try:
                    result = await tab.send(cdp.dom.push_nodes_by_backend_ids_to_frontend([img_backend_node_id]))
                    if result and len(result) > 0:
                        img_node_id = result[0]

                        # Scroll element into view first to ensure it's rendered
                        try:
                            await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=img_node_id))
                            await asyncio.sleep(0.1)
                        except:
                            pass  # Element may already be visible

                        # Get box model for the IMG element
                        box_model = await tab.send(cdp.dom.get_box_model(node_id=img_node_id))

                        if box_model and hasattr(box_model, 'content'):
                            # content quad: [x1,y1, x2,y2, x3,y3, x4,y4]
                            quad = box_model.content
                            x = min(quad[0], quad[2], quad[4], quad[6])
                            y = min(quad[1], quad[3], quad[5], quad[7])
                            width = max(quad[0], quad[2], quad[4], quad[6]) - x
                            height = max(quad[1], quad[3], quad[5], quad[7]) - y


                            # Get device pixel ratio
                            device_pixel_ratio = await tab.evaluate('window.devicePixelRatio')

                            # WORKAROUND: Full page screenshot + PIL crop
                            # Region screenshot doesn't work with closed Shadow DOM
                            full_screenshot = await tab.send(cdp.page.capture_screenshot(format_='png'))

                            if full_screenshot:
                                import base64
                                from PIL import Image
                                import io

                                # Decode full screenshot
                                full_img_bytes = base64.b64decode(full_screenshot)
                                full_img = Image.open(io.BytesIO(full_img_bytes))


                                # Crop using PIL (coordinates need to account for device pixel ratio)
                                left = int(x * device_pixel_ratio)
                                top = int(y * device_pixel_ratio)
                                right = int((x + width) * device_pixel_ratio)
                                bottom = int((y + height) * device_pixel_ratio)

                                cropped_img = full_img.crop((left, top, right, bottom))

                                # Convert back to bytes
                                img_buffer = io.BytesIO()
                                cropped_img.save(img_buffer, format='PNG')
                                img_base64 = img_buffer.getvalue()

                                if show_debug_message:
                                    print(f"[CAPTCHA] Screenshot: {len(img_base64)} bytes")

                                # Save for debugging (only in verbose mode)
                                # if show_debug_message:
                                    # try:
                                        # import os
                                        # from datetime import datetime
                                        # temp_dir = os.path.join(os.path.dirname(__file__), '.temp')
                                        # os.makedirs(temp_dir, exist_ok=True)
                                        # timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                                        # img_path = os.path.join(temp_dir, f'captcha_{timestamp}.png')
                                        # with open(img_path, 'wb') as f:
                                            # f.write(img_base64)
                                        # print(f"[CAPTCHA] Saved: {img_path}")
                                    # except:
                                        # pass
                        else:
                            if show_debug_message:
                                print("[CAPTCHA] Failed to get box model")
                    else:
                        if show_debug_message:
                            print("[CAPTCHA] Failed to convert backend_node_id")
                except Exception as dom_exc:
                    if show_debug_message:
                        print(f"[CAPTCHA] DOM API error: {dom_exc}")
            else:
                if show_debug_message:
                    print("[CAPTCHA] No backend_node_id found for IMG")

        except Exception as exc:
            if show_debug_message:
                print(f"[CAPTCHA] Screenshot failed: {exc}")
                import traceback
                traceback.print_exc()

    except Exception as exc:
        if show_debug_message:
            print(f"[CAPTCHA ERROR] Exception: {exc}")
            import traceback
            traceback.print_exc()

    return img_base64

async def nodriver_ibon_keyin_captcha_code(tab, answer="", auto_submit=False, config_dict=None):
    """
    ibon captcha input handling
    Returns: (is_verifyCode_editing, is_form_submitted)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False) if config_dict else False

    is_verifyCode_editing = False
    is_form_submitted = False

    if show_debug_message:
        print(f"[CAPTCHA INPUT] answer: {answer}, auto_submit: {auto_submit}")

    try:
        # Find captcha input box
        # Selector 1: input[value="驗證碼"]
        # Selector 2: #ctl00_ContentPlaceHolder1_CHK
        form_verifyCode = None

        try:
            form_verifyCode = await tab.query_selector('input[placeholder*="驗證碼"]')
        except:
            pass

        if not form_verifyCode:
            try:
                form_verifyCode = await tab.query_selector('input[value="驗證碼"]')
            except:
                pass

        if not form_verifyCode:
            try:
                form_verifyCode = await tab.query_selector('#ctl00_ContentPlaceHolder1_CHK')
            except:
                pass

        if not form_verifyCode:
            if show_debug_message:
                print("[CAPTCHA INPUT] Input box not found")
            return is_verifyCode_editing, is_form_submitted

        # Check if input box is visible
        is_visible = False
        try:
            is_visible = await tab.evaluate('''
                (function() {
                    const selectors = [
                        'input[placeholder*="驗證碼"]',
                        'input[value="驗證碼"]',
                        '#ctl00_ContentPlaceHolder1_CHK'
                    ];
                    for (let selector of selectors) {
                        const element = document.querySelector(selector);
                        if (element && !element.disabled && element.offsetParent !== null) {
                            return true;
                        }
                    }
                    return false;
                })();
            ''')
        except:
            pass

        if not is_visible:
            if show_debug_message:
                print("[CAPTCHA INPUT] Input box not visible")
            return is_verifyCode_editing, is_form_submitted

        # If no answer provided, check if already has value for manual input mode
        if not answer:
            # Get current input value
            inputed_value = ""
            try:
                inputed_value = await form_verifyCode.apply('function (element) { return element.value; }') or ""
            except:
                pass

            # If already has value, skip (user manually inputed)
            if inputed_value and inputed_value != "驗證碼":
                if show_debug_message:
                    print(f"[CAPTCHA INPUT] Already has value: {inputed_value}")
                is_verifyCode_editing = True
                return is_verifyCode_editing, is_form_submitted

            # Focus for manual input
            try:
                await form_verifyCode.click()
                is_verifyCode_editing = True
                if show_debug_message:
                    print("[CAPTCHA INPUT] Focused for manual input")
            except:
                pass
            return is_verifyCode_editing, is_form_submitted

        # Fill in answer
        try:
            await form_verifyCode.click()

            # Clear placeholder value
            await form_verifyCode.apply('function (element) { element.value = ""; }')

            # Type answer
            await form_verifyCode.send_keys(answer)

            if show_debug_message:
                print(f"[CAPTCHA INPUT] Filled answer: {answer}")

            # Auto submit if enabled
            if auto_submit:
                # Check if ticket number is selected (any SELECT, not just first one)
                # Fix (2026-01-07): Multi-ticket types may have selected ticket at index > 0
                ticket_ok = await tab.evaluate('''
                    (function() {
                        // Try new EventBuy format first: table.rwdtable select.form-control-sm
                        let selects = document.querySelectorAll('table.rwdtable select.form-control-sm');
                        // Fallback to old .aspx format: table.table select[name*="AMOUNT_DDL"]
                        if (selects.length === 0) {
                            selects = document.querySelectorAll('table.table select[name*="AMOUNT_DDL"]');
                        }
                        if (selects.length === 0) return false;
                        // Check if ANY select has a non-zero value (ticket selected)
                        return Array.from(selects).some(select =>
                            select.value !== "0" && select.value !== ""
                        );
                    })();
                ''')

                if ticket_ok:
                    # Set up alert handler BEFORE clicking submit button
                    alert_handled = False

                    async def handle_submit_dialog(event):
                        nonlocal alert_handled
                        alert_handled = True
                        if show_debug_message:
                            print(f"[CAPTCHA INPUT] Alert detected: '{event.message}'")
                        # Auto-dismiss alert
                        try:
                            await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                            if show_debug_message:
                                print(f"[CAPTCHA INPUT] Alert dismissed")
                        except Exception as dismiss_exc:
                            if show_debug_message:
                                print(f"[CAPTCHA INPUT] Failed to dismiss alert: {dismiss_exc}")

                    # Register alert handler
                    try:
                        tab.add_handler(cdp.page.JavascriptDialogOpening, handle_submit_dialog)
                        if show_debug_message:
                            print(f"[CAPTCHA INPUT] Alert handler registered before submit")
                    except Exception as handler_exc:
                        if show_debug_message:
                            print(f"[CAPTCHA INPUT] Failed to register alert handler: {handler_exc}")

                    # Find and click submit button
                    # Multiple button patterns for different ibon page types:
                    # - UTK0201 (EventBuy): #ctl00_ContentPlaceHolder1_A2
                    # - UTK0202 (ticket selection): a[id*="AddShopingCart"] or a.btn.btn-primary.btn-block
                    # CRITICAL: iBon requires calling ImageCode_Verify2() before submit
                    submit_clicked = await tab.evaluate('''
                        (function() {
                            // Try multiple selectors in priority order
                            let submitBtn = document.querySelector('#ctl00_ContentPlaceHolder1_A2');

                            if (!submitBtn) {
                                // UTK0202 page: try AddShopingCart button
                                submitBtn = document.querySelector('a[id*="AddShopingCart"]');
                            }

                            if (!submitBtn) {
                                // Generic fallback: any visible "下一步" button
                                const buttons = document.querySelectorAll('a.btn.btn-primary.btn-block');
                                for (let btn of buttons) {
                                    if (btn.textContent.includes('下一步') &&
                                        btn.offsetParent !== null &&  // is visible
                                        btn.style.display !== 'none') {
                                        submitBtn = btn;
                                        break;
                                    }
                                }
                            }

                            if (!submitBtn || submitBtn.disabled) {
                                console.log('[CAPTCHA] Submit button not found or disabled');
                                return false;
                            }

                            console.log('[CAPTCHA] Found submit button:', submitBtn.id || submitBtn.className);

                            // Call iBon's frontend verification function if it exists
                            if (typeof ImageCode_Verify2 === 'function') {
                                try {
                                    ImageCode_Verify2();
                                    console.log('[CAPTCHA] Called ImageCode_Verify2()');
                                } catch (e) {
                                    console.log('[CAPTCHA] ImageCode_Verify2 failed:', e);
                                }
                            } else if (typeof ImageCode_Verify === 'function') {
                                try {
                                    ImageCode_Verify();
                                    console.log('[CAPTCHA] Called ImageCode_Verify()');
                                } catch (e) {
                                    console.log('[CAPTCHA] ImageCode_Verify failed:', e);
                                }
                            }

                            submitBtn.click();
                            console.log('[CAPTCHA] Submit button clicked');
                            return true;
                        })();
                    ''')

                    if submit_clicked:
                        is_form_submitted = True
                        if show_debug_message:
                            print("[CAPTCHA INPUT] Form submitted")

                        # Wait for potential alert to appear and be handled
                        await asyncio.sleep(random.uniform(0.2, 0.6))

                        if show_debug_message:
                            if alert_handled:
                                print(f"[CAPTCHA INPUT] Alert was handled during wait")
                            else:
                                print(f"[CAPTCHA INPUT] No alert appeared (captcha may be correct)")
                    else:
                        if show_debug_message:
                            print("[CAPTCHA INPUT] Submit button not found or disabled")

                    # Remove alert handler
                    try:
                        tab.remove_handler(cdp.page.JavascriptDialogOpening, handle_submit_dialog)
                    except:
                        pass
                else:
                    if show_debug_message:
                        print("[CAPTCHA INPUT] Ticket number not selected, skip submit")

        except Exception as exc:
            if show_debug_message:
                print(f"[CAPTCHA INPUT ERROR] {exc}")

    except Exception as exc:
        if show_debug_message:
            print(f"[CAPTCHA INPUT ERROR] Exception: {exc}")
            import traceback
            traceback.print_exc()

    return is_verifyCode_editing, is_form_submitted

async def nodriver_ibon_refresh_captcha(tab, config_dict):
    """
    Refresh ibon captcha image by calling JavaScript refreshCaptcha() function
    Returns: success (bool)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print("[CAPTCHA REFRESH] Refreshing captcha")

    ret = False
    try:
        # Call JavaScript refreshCaptcha() function
        result = await tab.evaluate('''
            (function() {
                if (typeof refreshCaptcha === 'function') {
                    refreshCaptcha();
                    return true;
                }
                return false;
            })();
        ''')

        ret = result if result else False

        if show_debug_message:
            print(f"[CAPTCHA REFRESH] Result: {ret}")

    except Exception as exc:
        if show_debug_message:
            print(f"[CAPTCHA REFRESH ERROR] {exc}")

    return ret

async def nodriver_ibon_auto_ocr(tab, config_dict, ocr, away_from_keyboard_enable, previous_answer):
    """
    ibon OCR auto recognition logic
    Returns: (is_need_redo_ocr, previous_answer, is_form_submitted)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_need_redo_ocr = False
    is_form_submitted = False

    # Check if input box exists
    is_input_box_exist = False
    try:
        input_box = await tab.query_selector('input[placeholder*="驗證碼"], input[value="驗證碼"], #ctl00_ContentPlaceHolder1_CHK')
        is_input_box_exist = input_box is not None
    except:
        pass

    if not is_input_box_exist:
        if show_debug_message:
            print("[CAPTCHA OCR] Captcha input box not found")
        return is_need_redo_ocr, previous_answer, is_form_submitted

    if not ocr:
        if show_debug_message:
            print("[CAPTCHA OCR] OCR module not available")
        return is_need_redo_ocr, previous_answer, is_form_submitted

    # iBon clears ticket number after captcha error - reselect if needed
    ticket_ok = await tab.evaluate('''
        (function() {
            // Try new EventBuy format first: table.rwdtable select.form-control-sm
            let selects = document.querySelectorAll('table.rwdtable select.form-control-sm');
            // Fallback to old .aspx format: table.table select[name*="AMOUNT_DDL"]
            if (selects.length === 0) {
                selects = document.querySelectorAll('table.table select[name*="AMOUNT_DDL"]');
            }
            if (selects.length === 0) return false;
            const select = selects[0];
            return select.value !== "0" && select.value !== "";
        })();
    ''')

    if not ticket_ok:
        # Retry with exponential backoff: 0.5s → 1.0s → 2.0s
        max_retries = 3
        is_ticket_number_assigned = False
        show_debug_message = config_dict["advanced"].get("verbose", False)

        for attempt in range(1, max_retries + 1):
            is_ticket_number_assigned = await nodriver_ibon_ticket_number_auto_select(tab, config_dict)

            if is_ticket_number_assigned:
                if show_debug_message and attempt > 1:
                    print(f"[TICKET RETRY] Success after {attempt} attempt(s)")
                break

            if attempt < max_retries:
                # Exponential backoff: delay = 0.5 * (2 ^ (attempt - 1))
                delay = 0.5 * (2 ** (attempt - 1))
                if show_debug_message:
                    print(f"[TICKET RETRY] Attempt {attempt}/{max_retries} failed, waiting {delay}s (exponential backoff)")
                await asyncio_sleep_with_pause_check(delay, config_dict)

        if is_ticket_number_assigned:
            # Wait for iBon to process ticket number change
            await asyncio.sleep(random.uniform(0.15, 0.25))

    # Get captcha image and do OCR
    ocr_start_time = time.time()

    img_base64 = await nodriver_ibon_get_captcha_image_from_shadow_dom(tab, config_dict)

    ocr_answer = None
    if img_base64:
        try:
            # Use global OCR instance (beta=True works best for iBon - 91.3% accuracy in tests)
            # Preprocessing actually reduces accuracy (73.9% vs 91.3%)
            ocr_answer = ocr.classification(img_base64)

            if show_debug_message:
                print(f"[CAPTCHA OCR] Using global OCR (beta=True), raw result: {ocr_answer}")

            # Filter to digits only (iBon captchas are 4 digits)
            if ocr_answer:
                filtered = ''.join(filter(str.isdigit, ocr_answer))
                if filtered != ocr_answer and show_debug_message:
                    print(f"[CAPTCHA OCR] Filtered '{ocr_answer}' -> '{filtered}'")
                ocr_answer = filtered
        except Exception as exc:
            if show_debug_message:
                print(f"[CAPTCHA OCR] OCR classification failed: {exc}")

    ocr_done_time = time.time()
    ocr_elapsed_time = ocr_done_time - ocr_start_time

    if show_debug_message:
        print(f"[CAPTCHA OCR] Processing time: {ocr_elapsed_time:.3f}s")

    # Process OCR result
    if ocr_answer is None:
        if away_from_keyboard_enable:
            # Page not ready, retry
            is_need_redo_ocr = True
            await asyncio.sleep(0.1)
        else:
            # Manual mode
            await nodriver_ibon_keyin_captcha_code(tab, config_dict=config_dict)
    else:
        ocr_answer = ocr_answer.strip()
        if show_debug_message:
            print(f"[CAPTCHA OCR] Result: {ocr_answer}")

        if len(ocr_answer) == 4:
            # Valid 4-digit answer
            current_url_before_submit, _ = await nodriver_current_url(tab)
            who_care_var, is_form_submitted = await nodriver_ibon_keyin_captcha_code(
                tab, answer=ocr_answer, auto_submit=away_from_keyboard_enable, config_dict=config_dict
            )

            # Check if captcha was correct by verifying URL change
            if is_form_submitted and away_from_keyboard_enable:
                # Alert is already handled inside nodriver_ibon_keyin_captcha_code()
                # Just check URL change to determine if captcha was correct
                if show_debug_message:
                    print(f"[CAPTCHA OCR] Checking URL for verification...")

                try:
                    current_url_after_submit, _ = await nodriver_current_url(tab)
                except Exception as url_exc:
                    if show_debug_message:
                        print(f"[CAPTCHA OCR] Failed to get URL: {url_exc}")
                    current_url_after_submit = current_url_before_submit  # Assume same page

                if current_url_before_submit == current_url_after_submit:
                    # Still on same page - captcha was incorrect (alert was shown and dismissed)
                    if show_debug_message:
                        print(f"[CAPTCHA OCR] Captcha '{ocr_answer}' was incorrect, URL unchanged")

                    # IMPORTANT: iBon automatically refreshes captcha after alert dismissal
                    # Manual refresh is NOT needed and causes timing issues:
                    # - Alert dismiss triggers iBon's auto-refresh
                    # - Manual refresh would create a new captcha
                    # - Next OCR might still fetch the old URL from DOM cache
                    # Solution: Wait longer for iBon's refresh to fully stabilize
                    if show_debug_message:
                        print("[CAPTCHA OCR] Waiting for iBon auto-refresh to complete...")

                    await asyncio.sleep(random.uniform(0.8, 1.2))  # Wait for iBon auto-refresh

                    is_need_redo_ocr = True
                    is_form_submitted = False
                else:
                    # URL changed - captcha was correct
                    if show_debug_message:
                        print(f"[CAPTCHA OCR] Captcha '{ocr_answer}' accepted, URL changed")
                        print(f"[CAPTCHA OCR] Before: {current_url_before_submit}")
                        print(f"[CAPTCHA OCR] After: {current_url_after_submit}")
        else:
            # Invalid length
            if show_debug_message:
                print(f"[CAPTCHA OCR] Invalid answer length: {len(ocr_answer)} (expected 4)")

            if not away_from_keyboard_enable:
                await nodriver_ibon_keyin_captcha_code(tab, config_dict=config_dict)
            else:
                is_need_redo_ocr = True
                if previous_answer != ocr_answer:
                    previous_answer = ocr_answer

    return is_need_redo_ocr, previous_answer, is_form_submitted

async def nodriver_ibon_captcha(tab, config_dict, ocr):
    """
    ibon captcha main function
    Returns: is_captcha_sent (bool)
    """
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    away_from_keyboard_enable = config_dict["ocr_captcha"]["force_submit"]
    if not config_dict["ocr_captcha"]["enable"]:
        away_from_keyboard_enable = False

    if show_debug_message:
        print(f"[IBON CAPTCHA] Starting captcha handling")
        print(f"[IBON CAPTCHA] OCR enabled: {config_dict['ocr_captcha']['enable']}")
        print(f"[IBON CAPTCHA] Auto submit: {away_from_keyboard_enable}")

    is_captcha_sent = False

    if not config_dict["ocr_captcha"]["enable"]:
        # Manual mode
        await nodriver_ibon_keyin_captcha_code(tab, config_dict=config_dict)
    else:
        # Auto OCR mode
        previous_answer = None
        current_url, _ = await nodriver_current_url(tab)
        fail_count = 0  # Track consecutive failures
        total_fail_count = 0  # Track total failures

        for redo_ocr in range(5):
            is_need_redo_ocr, previous_answer, is_form_submitted = await nodriver_ibon_auto_ocr(
                tab, config_dict, ocr, away_from_keyboard_enable, previous_answer
            )

            if not is_need_redo_ocr:
                is_captcha_sent = True

            if is_form_submitted:
                if show_debug_message:
                    print("[IBON CAPTCHA] Form submitted successfully")
                break

            if not away_from_keyboard_enable:
                if show_debug_message:
                    print("[IBON CAPTCHA] Switching to manual input mode")
                break

            if not is_need_redo_ocr:
                break

            # Track failures and refresh captcha after 3 consecutive failures
            if is_need_redo_ocr:
                fail_count += 1
                total_fail_count += 1
                if show_debug_message:
                    print(f"[IBON CAPTCHA] Fail count: {fail_count}, Total fails: {total_fail_count}")

                # Check if total failures reached 5, switch to manual input mode
                if total_fail_count >= 5:
                    print("[IBON CAPTCHA] OCR failed 5 times. Please enter captcha manually.")
                    away_from_keyboard_enable = False
                    await nodriver_ibon_keyin_captcha_code(tab, config_dict=config_dict)
                    break

                if fail_count >= 3:
                    if show_debug_message:
                        print("[IBON CAPTCHA] 3 consecutive failures reached")

                    # Try to dismiss any existing alert before continuing
                    try:
                        await tab.send(cdp.page.handle_java_script_dialog(accept=True))
                        if show_debug_message:
                            print("[IBON CAPTCHA] Dismissed existing alert")
                    except:
                        pass

                    # IMPORTANT: iBon auto-refreshes captcha after alert dismiss
                    # Manual refresh causes timing conflicts with auto-refresh
                    # await nodriver_ibon_refresh_captcha(tab, config_dict)  # REMOVED
                    await asyncio.sleep(random.uniform(0.8, 1.2))  # Wait for iBon's auto-refresh to complete
                    fail_count = 0  # Reset consecutive counter after refresh

            # Check if URL changed
            new_url, _ = await nodriver_current_url(tab)
            if new_url != current_url:
                if show_debug_message:
                    print("[IBON CAPTCHA] URL changed, exit OCR loop")
                break

            if show_debug_message:
                print(f"[IBON CAPTCHA] Retry {redo_ocr + 1}/5")

    return is_captcha_sent

async def nodriver_ibon_purchase_button_press(tab, config_dict):
    """
    Click the ibon purchase/next button after captcha is filled

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary for debug settings

    Returns:
        bool: True if button clicked successfully, False otherwise
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_button_clicked = False

    try:
        # Primary selector: #ticket-wrap > a.btn
        # Backup selectors from JavaScript extension analysis
        selectors = [
            '#ticket-wrap > a.btn',
            'div#ticket-wrap > a[onclick]',
            'div#ticket-wrap a.btn.btn-primary[href]'
        ]

        for selector in selectors:
            try:
                button = await tab.query_selector(selector)
                if button:
                    # Check if button is visible and enabled
                    is_visible = await tab.evaluate(f'''
                        (function() {{
                            const btn = document.querySelector('{selector}');
                            return btn && !btn.disabled && btn.offsetParent !== null;
                        }})();
                    ''')

                    if is_visible:
                        await button.click()
                        is_button_clicked = True
                        if show_debug_message:
                            print(f"[IBON PURCHASE] Successfully clicked button with selector: {selector}")
                        break
            except Exception as exc:
                if show_debug_message:
                    print(f"[IBON PURCHASE] Selector {selector} failed: {exc}")
                continue

        if not is_button_clicked and show_debug_message:
            print("[IBON PURCHASE] Purchase button not found or not clickable")

    except Exception as exc:
        if show_debug_message:
            print(f"[IBON PURCHASE ERROR] {exc}")
            import traceback
            traceback.print_exc()

    return is_button_clicked

async def nodriver_ibon_check_sold_out(tab, config_dict):
    """
    Check if the event/ticket is sold out on ibon

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary for debug settings

    Returns:
        bool: True if sold out, False otherwise
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_sold_out = False

    try:
        # Check if ticket-info div contains "已售完" text
        result = await tab.evaluate('''
            (function() {
                const ticketInfo = document.querySelector('#ticket-info');
                if (ticketInfo) {
                    const text = ticketInfo.textContent || ticketInfo.innerText;
                    return text.includes('已售完');
                }
                return false;
            })()
        ''')

        if result:
            is_sold_out = True
            if show_debug_message:
                print("[IBON] Event is sold out")

    except Exception as e:
        if show_debug_message:
            print(f"[IBON] Check sold out error: {e}")

    return is_sold_out


async def nodriver_ibon_wait_for_select_elements(tab, config_dict, max_wait_time=3.0):
    """
    Wait for ticket quantity select elements to appear on page.
    Prevents false sold-out detection when page hasn't fully loaded.

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary
        max_wait_time: Maximum wait time in seconds (default 3.0)

    Returns:
        int: Number of select elements found (0 if none found after timeout)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    wait_interval = 0.2
    start_time = time.time()

    while time.time() - start_time < max_wait_time:
        try:
            select_count = await tab.evaluate('''
                (function() {
                    let selects = document.querySelectorAll('table.rwdtable select.form-control-sm');
                    if (selects.length === 0) {
                        selects = document.querySelectorAll('table.table select[name*="AMOUNT_DDL"]');
                    }
                    if (selects.length === 0) {
                        selects = document.querySelectorAll('select.form-control-sm');
                    }
                    return selects.length;
                })()
            ''')
            if select_count and select_count > 0:
                if show_debug_message:
                    elapsed = time.time() - start_time
                    print(f"[IBON] Page loaded, found {select_count} select element(s) after {elapsed:.2f}s")
                return select_count
        except Exception:
            pass
        await asyncio.sleep(wait_interval)

    if show_debug_message:
        print(f"[IBON] Warning: No select elements found after {max_wait_time}s wait")
    return 0


async def nodriver_ibon_check_sold_out_on_ticket_page(tab, config_dict):
    """
    Check if tickets are sold out on ibon ticket selection page
    Applicable to UTK0201_001.aspx and similar ticket quantity selection pages

    Detection methods:
    1. Check if ticket quantity dropdowns only have "0" option
    2. Check if page contains sold out messages

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary for debug settings

    Returns:
        bool: True if sold out (needs page reload), False otherwise
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_sold_out = False

    try:
        result = await tab.evaluate('''
            (function() {
                // Sold out keywords (multi-language support)
                const soldOutKeywords = ['選購一空', '已售完', 'No tickets available', 'Sold out', 'Sold Out', '空席なし', '完売した', '完売', '尚無票'];

                // Method 1: Check AMOUNT_STR spans (purchase quantity field)
                const amountSpans = document.querySelectorAll('span[id*="AMOUNT_STR"]');
                let hasAmountSoldOut = false;
                let amountSoldOutCount = 0;

                for (let span of amountSpans) {
                    const text = span.textContent.trim();
                    // Check if text matches any sold out keyword
                    if (soldOutKeywords.some(keyword => text === keyword)) {
                        hasAmountSoldOut = true;
                        amountSoldOutCount++;
                    }
                }

                // Method 2: Check PRICE_STR spans (ticket area label)
                const priceSpans = document.querySelectorAll('span[id*="PRICE_STR"]');
                let hasPriceSoldOut = false;

                for (let span of priceSpans) {
                    const text = span.textContent;
                    // Check if text contains any sold out keyword in parentheses
                    if (soldOutKeywords.some(keyword => text.includes('(' + keyword + ')'))) {
                        hasPriceSoldOut = true;
                        break;
                    }
                }

                // Method 3: Check if ticket quantity selectors only have "0" option
                let selects = document.querySelectorAll('table.rwdtable select.form-control-sm');
                if (selects.length === 0) {
                    selects = document.querySelectorAll('table.table select[name*="AMOUNT_DDL"]');
                }
                if (selects.length === 0) {
                    selects = document.querySelectorAll('select.form-control-sm');
                }

                let hasValidOptions = false;
                let selectCount = selects.length;

                for (let select of selects) {
                    for (let option of select.options) {
                        // Valid option: value not "0" or empty, and not disabled
                        if (option.value !== "0" && option.value !== "" && !option.disabled) {
                            hasValidOptions = true;
                            break;
                        }
                    }
                    if (hasValidOptions) break;
                }

                // Method 4: Check if TICKET TABLE contains sold out messages (NOT entire page)
                // Fix (2026-01-07): Only check ticket table, not entire page.
                // The area dropdown may contain "(已售完)" for OTHER areas, causing false positives.
                let hasSoldOutMessage = false;
                const ticketTable = document.querySelector('table.rwdtable, table.table');
                if (ticketTable) {
                    const tableText = ticketTable.innerText || ticketTable.textContent;
                    hasSoldOutMessage = soldOutKeywords.some(keyword => tableText.includes(keyword));
                }

                // Final determination: sold out if any method detects it
                // IMPORTANT: Only consider "no valid options" as sold-out when select elements exist
                // If selectCount === 0, the page might still be loading (not sold out)
                const noValidOptionsButSelectsExist = selectCount > 0 && !hasValidOptions;
                const isSoldOut = hasAmountSoldOut || hasPriceSoldOut || noValidOptionsButSelectsExist || hasSoldOutMessage;

                return {
                    hasAmountSoldOut: hasAmountSoldOut,
                    amountSoldOutCount: amountSoldOutCount,
                    hasPriceSoldOut: hasPriceSoldOut,
                    selectCount: selectCount,
                    hasValidOptions: hasValidOptions,
                    hasSoldOutMessage: hasSoldOutMessage,
                    isSoldOut: isSoldOut,
                    pageNotLoaded: selectCount === 0
                };
            })()
        ''')

        result = util.parse_nodriver_result(result)
        if isinstance(result, dict):
            is_sold_out = result.get('isSoldOut', False)
            page_not_loaded = result.get('pageNotLoaded', False)
            if show_debug_message:
                select_count = result.get('selectCount', 0)
                has_valid = result.get('hasValidOptions', False)
                if page_not_loaded:
                    print("[IBON] Page not fully loaded, waiting...")
                elif is_sold_out:
                    print("[IBON] Sold out detected, will reload")
                else:
                    print(f"[IBON] Tickets available ({select_count} selects, valid={has_valid})")

    except Exception as e:
        if show_debug_message:
            print(f"[IBON SOLD OUT CHECK] Error: {e}")

    return is_sold_out


async def nodriver_ibon_navigate_on_sold_out(tab, config_dict):
    """
    Navigate to area selection page when tickets are sold out.
    Fix (2026-01-07): Instead of just reloading the same sold-out page (causes infinite loop),
    navigate back to the area selection page where other areas might be available.

    URL Formats:
    - New format: ticket.ibon.com.tw/EventBuy/{eventId}/{sessionId}/{areaId}
      -> Navigate to: ticket.ibon.com.tw/Event/{eventId}/{sessionId}
    - Old format: orders.ibon.com.tw/application/UTK02/UTK0202_.aspx?PERFORMANCE_PRICE_AREA_ID=xxx
      -> Navigate to: orders.ibon.com.tw/application/UTK02/UTK0201_000.aspx?PERFORMANCE_ID=xxx

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary

    Returns:
        bool: True if navigation successful, False otherwise
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    navigation_success = False

    try:
        url = tab.url if hasattr(tab, 'url') else str(tab.target.url)
        url_lower = url.lower()

        # New format: ticket.ibon.com.tw/EventBuy/{eventId}/{sessionId}/{areaId}
        if '/eventbuy/' in url_lower and 'ticket.ibon.com.tw' in url_lower:
            parts = url.split('/')
            # URL: https://ticket.ibon.com.tw/EventBuy/xxx/yyy/zzz
            # parts: ['https:', '', 'ticket.ibon.com.tw', 'EventBuy', 'eventId', 'sessionId', 'areaId']
            if len(parts) >= 7:
                # Navigate to Event page (area selection)
                event_url = '/'.join(parts[:3] + ['Event', parts[4], parts[5]])
                if show_debug_message:
                    print(f"[IBON] Sold out - navigating to area selection: {event_url}")
                await tab.get(event_url)
                navigation_success = True

        # Old format: orders.ibon.com.tw/application/UTK02/UTK0202_.aspx?PERFORMANCE_PRICE_AREA_ID=xxx
        # Note: Old .aspx pages require PRODUCT_ID and other parameters that are hard to reconstruct.
        # Using tab.back() is safer to return to the previous area selection page.
        elif '/utk02/utk0202_' in url_lower and 'PERFORMANCE_PRICE_AREA_ID=' in url.upper():
            if show_debug_message:
                print("[IBON] Sold out - using tab.back() to return to area selection")
            await tab.back()
            navigation_success = True

        # Fallback: use tab.back() if URL pattern not recognized
        if not navigation_success:
            if show_debug_message:
                print("[IBON] Sold out - using tab.back() as fallback")
            await tab.back()
            navigation_success = True

    except Exception as e:
        if show_debug_message:
            print(f"[IBON] Navigation error: {e}")
        # Fallback to reload if navigation fails
        try:
            await tab.reload()
        except Exception:
            pass

    return navigation_success


async def nodriver_ibon_fill_verify_form(tab, config_dict, answer_list, fail_list,
                                          input_text_css, next_step_button_css):
    """
    ibon verification form filling (supports single/multiple input fields)

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary
        answer_list: List of answers to try
        fail_list: List of previously failed answers
        input_text_css: CSS selector for input fields
        next_step_button_css: CSS selector for submit button

    Returns:
        tuple[bool, list]: (is_answer_sent, updated fail_list)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_answer_sent = False

    try:
        # Get all input fields and their values
        input_info_raw = await tab.evaluate(f'''
            (function() {{
                var inputs = document.querySelectorAll("{input_text_css}");
                var result = [];
                inputs.forEach(function(input) {{
                    result.push({{
                        value: input.value || ""
                    }});
                }});
                return {{
                    count: inputs.length,
                    inputs: result
                }};
            }})()
        ''')

        # Handle NoDriver result format - may return tuple (result, exception)
        input_info = input_info_raw
        if isinstance(input_info_raw, tuple) and len(input_info_raw) >= 1:
            input_info = input_info_raw[0]

        input_info = util.parse_nodriver_result(input_info)

        # Handle NoDriver error result (ExceptionDetails object or non-dict)
        if not input_info or not isinstance(input_info, dict):
            if show_debug_message:
                print(f"[IBON VERIFY] Failed to get input info: {type(input_info)}")
            return is_answer_sent, fail_list

        form_input_count = input_info.get('count', 0)
        if show_debug_message:
            print(f"[IBON VERIFY] Found {form_input_count} input field(s)")

        if form_input_count == 0:
            return is_answer_sent, fail_list

        # Determine multi-question mode
        is_multi_question_mode = False
        if form_input_count == 2 and len(answer_list) >= 2:
            if len(answer_list[0]) > 0 and len(answer_list[1]) > 0:
                is_multi_question_mode = True

        if show_debug_message:
            print(f"[IBON VERIFY] Multi-question mode: {is_multi_question_mode}")
            print(f"[IBON VERIFY] Answer list: {answer_list}")
            print(f"[IBON VERIFY] Fail list: {fail_list}")

        if is_multi_question_mode:
            # Multi-field mode: fill answer_list[0] to first field, answer_list[1] to second
            answer_1 = answer_list[0]
            answer_2 = answer_list[1]
            # JSON encode for safe JavaScript string insertion
            answer_1_js = json.dumps(answer_1)
            answer_2_js = json.dumps(answer_2)

            # Fill both fields using JavaScript
            fill_result_raw = await tab.evaluate(f'''
                (function() {{
                    var inputs = document.querySelectorAll("{input_text_css}");
                    if (inputs.length >= 2) {{
                        var answer1 = {answer_1_js};
                        var answer2 = {answer_2_js};

                        if (inputs[0].value !== answer1) {{
                            inputs[0].value = "";
                            inputs[0].value = answer1;
                            inputs[0].dispatchEvent(new Event('input', {{ bubbles: true }}));
                            inputs[0].dispatchEvent(new Event('change', {{ bubbles: true }}));
                        }}

                        if (inputs[1].value !== answer2) {{
                            inputs[1].value = "";
                            inputs[1].value = answer2;
                            inputs[1].dispatchEvent(new Event('input', {{ bubbles: true }}));
                            inputs[1].dispatchEvent(new Event('change', {{ bubbles: true }}));
                        }}

                        return true;
                    }}
                    return false;
                }})()
            ''')

            # Handle tuple result from NoDriver
            fill_result = fill_result_raw
            if isinstance(fill_result_raw, tuple) and len(fill_result_raw) >= 1:
                fill_result = fill_result_raw[0]

            if fill_result:
                if show_debug_message:
                    print(f"[IBON VERIFY] Filled multi-field: '{answer_1}' and '{answer_2}'")

                # Click submit button
                try:
                    btn = await tab.query_selector(next_step_button_css)
                    if btn:
                        await btn.click()
                        is_answer_sent = True
                        fail_list.append(answer_1)
                        fail_list.append(answer_2)
                        if show_debug_message:
                            print(f"[IBON VERIFY] Submitted multi-field answers")
                except Exception as btn_exc:
                    if show_debug_message:
                        print(f"[IBON VERIFY] Click button error: {btn_exc}")

        else:
            # Single-field mode: find first answer not in fail_list
            inferred_answer = ""
            for answer in answer_list:
                if answer not in fail_list:
                    inferred_answer = answer
                    break

            if len(inferred_answer) > 0:
                # JSON encode for safe JavaScript string insertion
                inferred_answer_js = json.dumps(inferred_answer)
                # Fill the answer
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector("{input_text_css}");
                        if (input) {{
                            input.value = "";
                            input.value = {inferred_answer_js};
                            input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                            input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        }}
                    }})()
                ''')

                if show_debug_message:
                    print(f"[IBON VERIFY] Filled single-field: '{inferred_answer}'")

                # Click submit button
                try:
                    btn = await tab.query_selector(next_step_button_css)
                    if btn:
                        await btn.click()
                        is_answer_sent = True
                        fail_list.append(inferred_answer)
                        if show_debug_message:
                            print(f"[IBON VERIFY] Submitted, attempt #{len(fail_list)}")
                except Exception as btn_exc:
                    if show_debug_message:
                        print(f"[IBON VERIFY] Click button error: {btn_exc}")
            else:
                # No answer to fill, focus the input
                if show_debug_message:
                    print("[IBON VERIFY] No answer available, focusing input")
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector("{input_text_css}");
                        if (input && document.activeElement !== input) {{
                            input.focus();
                        }}
                    }})()
                ''')

        if is_answer_sent:
            await asyncio.sleep(0.3)

    except Exception as exc:
        if show_debug_message:
            print(f"[IBON VERIFY] Error: {exc}")

    return is_answer_sent, fail_list


async def nodriver_ibon_verification_question(tab, fail_list, config_dict):
    """
    Handle verification question on ibon with auto-fill support

    Features:
    - Reads answers from user_guess_string (user dictionary)
    - Supports first/last N chars extraction (e.g., "phone last 3 digits")
    - Auto-guess from question text (if auto_guess_options enabled)
    - Multi-field support

    Args:
        tab: NoDriver tab object
        fail_list: List of previously failed answers
        config_dict: Configuration dictionary

    Returns:
        list: Updated fail_list
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # CSS selectors for ibon verification page
    # Note: use single quotes in CSS selector to avoid breaking JavaScript string
    INPUT_CSS = "#content div.form-group input[type='text'], #content div.form-group input:not([type]), div.editor-box input[type='text'], div.editor-box input:not([type])"
    SUBMIT_BTN_CSS = '#content a.btn, div.editor-box a.btn'

    try:
        # Get question texts from all form-groups (returns array)
        question_texts_raw = await tab.evaluate('''
            (function() {
                var questions = [];
                var content = document.querySelector('#content');
                if (content) {
                    // Get all form-groups with input fields
                    var formGroups = content.querySelectorAll('div.form-group');
                    formGroups.forEach(function(formGroup) {
                        // Only process form-groups that have input fields
                        if (formGroup.querySelector('input')) {
                            var span = formGroup.querySelector('span');
                            if (span) {
                                questions.push(span.textContent || span.innerText || '');
                            }
                        }
                    });
                }
                return questions;
            })()
        ''')

        # Handle NoDriver result format - may return tuple (result, exception) or array
        question_texts = []
        raw_data = question_texts_raw

        # If it's a tuple (result, exception), extract the result
        if isinstance(raw_data, tuple) and len(raw_data) >= 1:
            raw_data = raw_data[0]

        # Parse the result into a list of strings
        if isinstance(raw_data, list):
            for q in raw_data:
                if isinstance(q, dict) and 'value' in q:
                    # NoDriver format: {'type': 'string', 'value': '...'}
                    question_texts.append(str(q['value']))
                elif isinstance(q, str) and q:
                    question_texts.append(q)
        elif isinstance(raw_data, str) and raw_data:
            question_texts = [raw_data]

        # For backward compatibility, create combined question_text
        question_text = ' '.join(question_texts).strip()

        if len(question_text) > 0:
            if show_debug_message:
                print(f"[IBON VERIFY] Question found: {question_text}")
                print(f"[IBON VERIFY] Question count: {len(question_texts)}")

            # Write question to file for debugging
            write_question_to_file(question_text)

            # Step 1: Get answers from user dictionary
            answer_list = util.get_answer_list_from_user_guess_string(config_dict, CONST_MAXBOT_ANSWER_ONLINE_FILE)

            if show_debug_message:
                print(f"[IBON VERIFY] User dictionary answers: {answer_list}")

            # Step 2: Smart extraction for multi-field forms
            # For each question, try to extract from its corresponding answer
            if len(answer_list) > 0 and len(question_texts) > 1:
                # Multi-field mode: extract answer for each question
                extracted_answers = []
                for idx, q_text in enumerate(question_texts):
                    if idx < len(answer_list):
                        # Only try to extract from THIS position's answer
                        extracted = util.extract_answer_by_question_pattern([answer_list[idx]], q_text)
                        if extracted:
                            extracted_answers.append(extracted)
                            if show_debug_message:
                                print(f"[IBON VERIFY] Q{idx+1} extracted from answer[{idx}]: {extracted}")
                        else:
                            # No pattern match, use original answer at this position
                            extracted_answers.append(answer_list[idx])
                            if show_debug_message:
                                print(f"[IBON VERIFY] Q{idx+1} using original: {answer_list[idx]}")

                # Replace answer_list with extracted answers if we got results
                if len(extracted_answers) >= len(question_texts):
                    answer_list = extracted_answers
                    if show_debug_message:
                        print(f"[IBON VERIFY] Final answers for multi-field: {answer_list}")

            elif len(answer_list) > 0:
                # Single-field mode: original logic
                extracted_answer = util.extract_answer_by_question_pattern(answer_list, question_text)
                if extracted_answer:
                    if show_debug_message:
                        print(f"[IBON VERIFY] Extracted answer by pattern: {extracted_answer}")
                    # Prepend extracted answer to the list for priority
                    if extracted_answer not in answer_list:
                        answer_list = [extracted_answer] + answer_list

            # Step 3: If no user dictionary and auto_guess enabled, try auto-guess
            if len(answer_list) == 0:
                if config_dict["advanced"].get("auto_guess_options", False):
                    answer_list = util.get_answer_list_from_question_string(None, question_text)
                    if show_debug_message:
                        print(f"[IBON VERIFY] Auto-guessed answers: {answer_list}")

            # Step 4: Fill the form if we have answers
            if len(answer_list) > 0:
                is_answer_sent, fail_list = await nodriver_ibon_fill_verify_form(
                    tab, config_dict, answer_list, fail_list,
                    INPUT_CSS, SUBMIT_BTN_CSS
                )
                if show_debug_message:
                    print(f"[IBON VERIFY] Answer sent: {is_answer_sent}")
            else:
                if show_debug_message:
                    print("[IBON VERIFY] No answers available, waiting for user input")
                # Focus the input field
                await tab.evaluate(f'''
                    (function() {{
                        var input = document.querySelector("{INPUT_CSS}");
                        if (input && document.activeElement !== input) {{
                            input.focus();
                        }}
                    }})()
                ''')

    except Exception as e:
        if show_debug_message:
            print(f"[IBON] Verification question error: {e}")

    return fail_list


async def nodriver_tour_ibon_event_detail(tab, config_dict):
    """
    Handle tour.ibon.com.tw event detail page (/event/{eventId})
    Click the purchase button to proceed to options page

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary

    Returns:
        bool: True if button clicked successfully
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_button_clicked = False

    try:
        if show_debug_message:
            print("[TOUR IBON] Event detail page detected")

        # Find and click purchase button (multiple text variations)
        button_text_list = ["立即購票", "搶票", "購票", "Buy"]

        for button_text in button_text_list:
            try:
                # Use text-based selector to find button
                result = await tab.evaluate(f'''
                    (function() {{
                        var buttons = Array.from(document.querySelectorAll('button'));
                        var targetBtn = buttons.find(btn => btn.textContent.includes("{button_text}"));
                        if (targetBtn) {{
                            targetBtn.click();
                            return true;
                        }}
                        return false;
                    }})()
                ''')

                if result:
                    is_button_clicked = True
                    if show_debug_message:
                        print(f"[TOUR IBON] Clicked button: {button_text}")
                    break
            except Exception as e:
                if show_debug_message:
                    print(f"[TOUR IBON] Button click error ({button_text}): {e}")

        if not is_button_clicked and show_debug_message:
            print("[TOUR IBON] Purchase button not found")

    except Exception as e:
        if show_debug_message:
            print(f"[TOUR IBON] Event detail error: {e}")

    return is_button_clicked


async def nodriver_tour_ibon_options(tab, config_dict):
    """
    Handle tour.ibon.com.tw options page (/event/{eventId}/options)
    Select ticket quantity -> Add to cart -> Confirm payment method

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary

    Returns:
        bool: True if all steps completed successfully
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_all_completed = False

    try:
        if show_debug_message:
            print("[TOUR IBON] Options page detected")

        # Step 1: Select ticket quantity from <select> element
        # Support multiple ticket types with area_keyword matching
        ticket_number = config_dict.get("ticket_number", 2)

        # Get area keyword for ticket type matching
        area_keyword = ""
        area_auto_select_enable = config_dict.get("area_auto_select", {}).get("enable", False)
        if area_auto_select_enable:
            area_keyword = config_dict.get("area_auto_select", {}).get("area_keyword", "")
            area_keyword = util.format_keyword_string(area_keyword)

        try:
            # Step 1a: Get all ticket types from page
            ticket_types = await tab.evaluate('''
                (function() {
                    var headings = document.querySelectorAll('h4');
                    return Array.from(headings).map(h => h.textContent.trim());
                })()
            ''')

            # Step 1b: Find matching ticket type using Python util function
            target_index = 0  # Default to first ticket type
            if area_keyword and ticket_types:
                for i, ticket_name in enumerate(ticket_types):
                    if util.is_text_match_keyword(area_keyword, ticket_name):
                        target_index = i
                        if show_debug_message:
                            print(f"[TOUR IBON] Keyword '{area_keyword}' matched ticket: {ticket_name}")
                        break

            # Step 1c: Select quantity for the matched ticket type
            select_result = await tab.evaluate(f'''
                (function() {{
                    var targetIndex = {target_index};
                    var ticketNumber = "{ticket_number}";
                    var selects = document.querySelectorAll('select#input-qty, select[id*="qty"]');
                    var headings = document.querySelectorAll('h4');

                    if (selects.length > targetIndex) {{
                        var select = selects[targetIndex];
                        select.value = ticketNumber;
                        select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        return {{
                            success: true,
                            index: targetIndex,
                            ticketName: headings[targetIndex] ? headings[targetIndex].textContent.trim() : '',
                            value: select.value
                        }};
                    }}
                    return {{ success: false, reason: 'no select found', selectCount: selects.length }};
                }})()
            ''')

            if select_result and isinstance(select_result, dict) and select_result.get('success') and show_debug_message:
                print(f"[TOUR IBON] Selected ticket: {select_result.get('ticketName', 'unknown')}, quantity: {ticket_number}")

        except Exception as e:
            if show_debug_message:
                print(f"[TOUR IBON] Quantity selection error: {e}")

        # Step 2: Click the ENABLED "加入訂購" button (only enabled after quantity selected)
        await asyncio.sleep(0.3)

        try:
            result = await tab.evaluate('''
                (function() {
                    var buttons = Array.from(document.querySelectorAll('button'));
                    // Find enabled "加入訂購" button (disabled buttons have disabled attribute)
                    var addBtn = buttons.find(btn =>
                        btn.textContent.includes("加入訂購") && !btn.disabled
                    );
                    if (addBtn) {
                        addBtn.click();
                        return { success: true };
                    }
                    // If no enabled button found, report all button states
                    var allAddBtns = buttons.filter(btn => btn.textContent.includes("加入訂購"));
                    return {
                        success: false,
                        reason: 'no enabled button',
                        buttonCount: allAddBtns.length,
                        allDisabled: allAddBtns.every(btn => btn.disabled)
                    };
                })()
            ''')

            if result and isinstance(result, dict) and result.get('success') and show_debug_message:
                print("[TOUR IBON] Clicked: 加入訂購")
            elif result and isinstance(result, dict) and not result.get('success') and show_debug_message:
                print(f"[TOUR IBON] Add button not ready: {result.get('reason')}")
        except Exception as e:
            if show_debug_message:
                print(f"[TOUR IBON] Add to cart error: {e}")

        # Step 3: Wait and click "確認付款方式" button
        await asyncio.sleep(0.5)

        try:
            result = await tab.evaluate('''
                (function() {
                    var buttons = Array.from(document.querySelectorAll('button'));
                    var confirmBtn = buttons.find(btn => btn.textContent.includes("確認付款方式"));
                    if (confirmBtn) {
                        confirmBtn.click();
                        return true;
                    }
                    return false;
                })()
            ''')

            if result:
                is_all_completed = True
                if show_debug_message:
                    print("[TOUR IBON] Clicked: 確認付款方式")
        except Exception as e:
            if show_debug_message:
                print(f"[TOUR IBON] Confirm payment error: {e}")

    except Exception as e:
        if show_debug_message:
            print(f"[TOUR IBON] Options page error: {e}")

    return is_all_completed


async def nodriver_tour_ibon_checkout(tab, config_dict):
    """
    Handle tour.ibon.com.tw checkout page (/event/{eventId}/checkout)
    Fill form (name, phone) -> Check agreement -> Submit

    Args:
        tab: NoDriver tab object
        config_dict: Configuration dictionary

    Returns:
        bool: True if form submitted successfully
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_form_submitted = False

    try:
        if show_debug_message:
            print("[TOUR IBON] Checkout page detected")

        # Get personal data from config
        real_name = config_dict.get("contact", {}).get("real_name", "")
        phone = config_dict.get("contact", {}).get("phone", "")

        if not real_name or not phone:
            if show_debug_message:
                print("[TOUR IBON] Missing contact data in settings")
            return False

        # JSON encode for safe JavaScript string insertion
        real_name_js = json.dumps(real_name)
        phone_js = json.dumps(phone)

        # Step 1: Fill real name and phone using fieldset structure
        try:
            result = await tab.evaluate(f'''
                (function() {{
                    var fieldsets = document.querySelectorAll('fieldset');
                    var nameInput = null;
                    var phoneInput = null;

                    fieldsets.forEach(function(fs) {{
                        var legend = fs.querySelector('legend');
                        var input = fs.querySelector('input');
                        if (legend && input && !input.readOnly) {{
                            if (legend.textContent.includes('真實姓名')) nameInput = input;
                            if (legend.textContent.includes('手機號碼')) phoneInput = input;
                        }}
                    }});

                    var results = {{ name: false, phone: false }};

                    if (nameInput) {{
                        nameInput.focus();
                        nameInput.value = {real_name_js};
                        nameInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        nameInput.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        nameInput.blur();
                        results.name = true;
                    }}

                    if (phoneInput) {{
                        phoneInput.focus();
                        phoneInput.value = {phone_js};
                        phoneInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        phoneInput.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        phoneInput.blur();
                        results.phone = true;
                    }}

                    return results;
                }})()
            ''')

            if result and isinstance(result, dict) and show_debug_message:
                if result.get('name'):
                    print(f"[TOUR IBON] Filled name: {real_name}")
                if result.get('phone'):
                    print(f"[TOUR IBON] Filled phone: {phone}")
        except Exception as e:
            if show_debug_message:
                print(f"[TOUR IBON] Form fill error: {e}")

        # Step 2: Check agreement checkbox (wait for form validation first)
        await asyncio.sleep(0.5)

        try:
            result = await tab.evaluate('''
                (function() {
                    // Try by id first, then fallback to search
                    var agreeCheckbox = document.getElementById('agreeCheck');
                    if (!agreeCheckbox) {
                        var checkboxes = Array.from(document.querySelectorAll('input[type="checkbox"]'));
                        agreeCheckbox = checkboxes.find(cb => {
                            var parent = cb.closest('div');
                            return parent && parent.textContent.includes("我已詳閱");
                        });
                    }
                    if (agreeCheckbox && !agreeCheckbox.checked) {
                        agreeCheckbox.click();
                        return { clicked: true, checked: agreeCheckbox.checked };
                    }
                    return { clicked: false, checked: agreeCheckbox ? agreeCheckbox.checked : false };
                })()
            ''')

            if result and show_debug_message:
                print(f"[TOUR IBON] Agreement checkbox: {result}")
        except Exception as e:
            if show_debug_message:
                print(f"[TOUR IBON] Checkbox error: {e}")

        # Step 3: Click submit button (下一步) - wait for validation to complete
        await asyncio.sleep(0.5)

        try:
            result = await tab.evaluate('''
                (function() {
                    var buttons = Array.from(document.querySelectorAll('button'));
                    var submitBtn = buttons.find(btn => btn.textContent.includes("下一步") && !btn.disabled);
                    if (submitBtn) {
                        submitBtn.click();
                        return true;
                    }
                    return false;
                })()
            ''')

            if result:
                is_form_submitted = True
                if show_debug_message:
                    print("[TOUR IBON] Clicked: 下一步")
        except Exception as e:
            if show_debug_message:
                print(f"[TOUR IBON] Submit error: {e}")

    except Exception as e:
        if show_debug_message:
            print(f"[TOUR IBON] Checkout error: {e}")

    return is_form_submitted


async def nodriver_ibon_main(tab, url, config_dict, ocr, Captcha_Browser):
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    global ibon_dict
    if not 'ibon_dict' in globals():
        ibon_dict = {}
        ibon_dict["fail_list"]=[]
        ibon_dict["start_time"]=None
        ibon_dict["done_time"]=None
        ibon_dict["elapsed_time"]=None
        ibon_dict["is_popup_checkout"] = False
        ibon_dict["played_sound_order"] = False
        ibon_dict["triggered_idle"] = False
        ibon_dict["shown_checkout_message"] = False

    # Check if kicked to login page (Cookie/Session expired)
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_login_page = False
    target_url = None

    # Detect login page patterns
    # Support both patterns: /huiwan/loginhuiwan and /huiwan//loginhuiwan (with double slash)
    url_lower = url.lower()
    if 'huiwan.ibon.com.tw' in url_lower and 'loginhuiwan' in url_lower:
        is_login_page = True
        # Extract target URL from query parameter
        if 'targeturl=' in url.lower():
            try:
                import urllib.parse
                parsed = urllib.parse.urlparse(url)
                params = urllib.parse.parse_qs(parsed.query)
                if 'targeturl' in params:
                    target_url = params['targeturl'][0]
            except:
                pass
        if show_debug_message:
            print(f"[IBON LOGIN] Detected login page redirect")
            if target_url:
                print(f"[IBON LOGIN] Target URL: {target_url}")

    # If kicked to login page, re-login and redirect back
    if is_login_page:
        if show_debug_message:
            print("[IBON LOGIN] Re-authenticating with cookie...")

        # Re-execute login process (get driver from tab.browser)
        driver = getattr(tab, 'browser', None)
        login_result = await nodriver_ibon_login(tab, config_dict, driver)

        if show_debug_message:
            if login_result['success']:
                print("[IBON LOGIN] Re-authentication successful")
            else:
                print(f"[IBON LOGIN] Re-authentication failed: {login_result.get('error', 'Unknown error')}")

        # Redirect back to target URL or homepage
        if target_url and target_url.startswith('http'):
            if show_debug_message:
                print(f"[IBON LOGIN] Redirecting to target: {target_url}")
            try:
                await tab.get(target_url)
                await asyncio.sleep(2)
            except Exception as e:
                if show_debug_message:
                    print(f"[IBON LOGIN] Redirect failed: {e}")
        else:
            # No target URL, go to homepage
            config_homepage = config_dict["homepage"]
            if show_debug_message:
                print(f"[IBON LOGIN] No target URL, redirecting to homepage: {config_homepage}")
            try:
                await tab.get(config_homepage)
                await asyncio.sleep(2)
            except Exception as e:
                if show_debug_message:
                    print(f"[IBON LOGIN] Homepage redirect failed: {e}")

        return False  # Don't quit bot, continue monitoring

    home_url_list = ['https://ticket.ibon.com.tw/'
    ,'https://ticket.ibon.com.tw/index/entertainment'
    ]
    for each_url in home_url_list:
        if each_url == url.lower():
            if config_dict["ocr_captcha"]["enable"]:
                # TODO:
                #set_non_browser_cookies(driver, url, Captcha_Browser)
                pass
            break

    # Auto-redirect if kicked back to homepage (防止被踢回首頁)
    # Pattern: Homepage → Target page redirection
    # - If homepage config is set to a specific page (ActivityInfo/orders/Event), redirect back when kicked to homepage
    # - If homepage config is homepage itself, skip redirect (normal behavior)
    is_kicked_to_homepage = False
    normalized_url = url.lower().rstrip('/')
    if normalized_url == 'https://ticket.ibon.com.tw' or normalized_url == 'https://ticket.ibon.com.tw/index/entertainment':
        is_kicked_to_homepage = True

    if is_kicked_to_homepage:
        config_homepage = config_dict["homepage"]
        # Only redirect if user wants to be on a specific page (not homepage itself)
        # Support all ibon page types: ActivityInfo, orders.ibon.com.tw, Event, EventBuy, etc.
        normalized_homepage = config_homepage.lower().rstrip('/')
        is_homepage_same_as_current = (
            normalized_homepage == 'https://ticket.ibon.com.tw' or
            normalized_homepage == 'https://ticket.ibon.com.tw/index/entertainment'
        )
        should_redirect = not is_homepage_same_as_current

        if should_redirect:
            show_debug_message = config_dict["advanced"].get("verbose", False)

            if show_debug_message:
                print(f"[IBON] Detected kicked back to homepage: {url}")
                print(f"[IBON] Redirecting to config homepage: {config_homepage}")

            try:
                await tab.get(config_homepage)
                # Wait for page load
                await asyncio.sleep(2)

                if show_debug_message:
                    print(f"[IBON] Successfully redirected to: {config_homepage}")
            except Exception as redirect_exc:
                if show_debug_message:
                    print(f"[IBON] Redirect failed: {redirect_exc}")


    # tour.ibon.com.tw URL routing
    # https://tour.ibon.com.tw/event/{eventId}
    # https://tour.ibon.com.tw/event/{eventId}/options
    # https://tour.ibon.com.tw/event/{eventId}/checkout
    if 'tour.ibon.com.tw' in url.lower() and '/event/' in url.lower():
        url_parts = url.split('/')

        # Event detail page: /event/{eventId}
        if len(url_parts) == 5:
            await nodriver_tour_ibon_event_detail(tab, config_dict)

        # Options or checkout page: /event/{eventId}/options or /event/{eventId}/checkout
        elif len(url_parts) == 6:
            if '/options' in url.lower():
                await nodriver_tour_ibon_options(tab, config_dict)
            elif '/checkout' in url.lower():
                await nodriver_tour_ibon_checkout(tab, config_dict)

    is_match_target_feature = False

    #PS: ibon some utk is upper case, some is lower.
    if not is_match_target_feature:
        #https://ticket.ibon.com.tw/ActivityInfo/Details/0000?pattern=entertainment
        if '/activityinfo/details/' in url.lower():
            is_event_page = False
            if len(url.split('/'))==6:
                is_event_page = True

            if is_event_page:
                if config_dict["date_auto_select"]["enable"]:
                    is_match_target_feature = True
                    is_date_assign_by_bot = await nodriver_ibon_date_auto_select(tab, config_dict)

                    # If date selection failed, reload page
                    if not is_date_assign_by_bot:
                        show_debug_message = config_dict["advanced"].get("verbose", False)
                        if show_debug_message:
                            print("[IBON DATE] Date selection failed, reloading page...")

                        try:
                            await tab.reload()
                        except:
                            pass

                        auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                        if auto_reload_interval > 0:
                            await asyncio.sleep(auto_reload_interval)

    if 'ibon.com.tw/error.html?' in url.lower():
        try:
            tab.back()
        except Exception as exc:
            pass

    is_enter_verify_mode = False
    if not is_match_target_feature:
        # validation question url:
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_0.aspx?rn=1180872370&PERFORMANCE_ID=B04M7XZT&PRODUCT_ID=B04KS88E&SHOW_PLACE_MAP=True
        is_event_page = False
        if '/UTK02/UTK0201_0.' in url.upper():
            if '.aspx?' in url.lower():
                if 'rn=' in url.lower():
                    if 'PERFORMANCE_ID=' in url.upper():
                        if "PRODUCT_ID=" in url.upper():
                            is_event_page = True

        if is_event_page:
            is_enter_verify_mode = True
            ibon_dict["fail_list"] = await nodriver_ibon_verification_question(tab, ibon_dict["fail_list"], config_dict)
            is_match_target_feature = True

    if not is_enter_verify_mode:
        ibon_dict["fail_list"] = []

    if not is_match_target_feature:
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_000.aspx?PERFORMANCE_ID=0000
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_000.aspx?rn=1111&PERFORMANCE_ID=2222&PRODUCT_ID=BBBB
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_001.aspx?PERFORMANCE_ID=2222&GROUP_ID=4&PERFORMANCE_PRICE_AREA_ID=3333

        is_event_page = False
        if '/UTK02/UTK0201_' in url.upper():
            if '.aspx?' in url.lower():
                if 'PERFORMANCE_ID=' in url.upper():
                    if len(url.split('/'))==6:
                        is_event_page = True

        if '/UTK02/UTK0202_' in url.upper():
            if '.aspx?' in url.lower():
                if 'PERFORMANCE_ID=' in url.upper():
                    if len(url.split('/'))==6:
                        is_event_page = True

        if is_event_page:
            # Check if area is already selected (avoid duplicate selection causing double tickets)
            is_area_already_selected = 'PERFORMANCE_PRICE_AREA_ID=' in url.upper()

            if config_dict["area_auto_select"]["enable"] and not is_area_already_selected:
                is_match_target_feature = True
                area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()

                is_need_refresh = False
                is_price_assign_by_bot = False

                if len(area_keyword) > 0:
                    area_keyword_array = []
                    try:
                        import json
                        area_keyword_array = json.loads("["+ area_keyword +"]")
                    except Exception as exc:
                        area_keyword_array = []

                    for area_keyword_item in area_keyword_array:
                        is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_area_auto_select(tab, config_dict, area_keyword_item)
                        if not is_need_refresh:
                            break

                    # Fallback: If all keyword groups failed, check area_auto_fallback setting
                    if not is_price_assign_by_bot:
                        if is_need_refresh:
                            area_auto_fallback = config_dict.get("area_auto_fallback", False)
                            if area_auto_fallback:
                                # Feature 003: Fallback enabled - use auto_select_mode without keyword
                                show_debug_message = config_dict["advanced"].get("verbose", False)
                                auto_select_mode = config_dict["area_auto_select"]["mode"]
                                if show_debug_message:
                                    print(f"[IBON AREA] All keyword groups failed, area_auto_fallback=true")
                                    print(f"[IBON AREA] Falling back to auto_select_mode: {auto_select_mode}")
                                is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_area_auto_select(tab, config_dict, "")
                            else:
                                # Feature 003: Fallback disabled - strict mode (no selection, will reload)
                                show_debug_message = config_dict["advanced"].get("verbose", False)
                                if show_debug_message:
                                    print(f"[IBON AREA] All keyword groups failed, area_auto_fallback=false")
                                    print(f"[IBON AREA] No area selected, will reload page and retry")
                                # Keep is_price_assign_by_bot=False and is_need_refresh=True
                                # This will trigger page reload in the outer loop
                else:
                    # empty keyword, match all.
                    is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_area_auto_select(tab, config_dict, area_keyword)

                if is_need_refresh:
                    show_debug_message = config_dict["advanced"].get("verbose", False)
                    if show_debug_message:
                        print("[IBON ORDERS] No available areas found, page reload required")

                    try:
                        await tab.reload()
                    except Exception as exc:
                        pass

                    auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                    if auto_reload_interval > 0:
                        await asyncio.sleep(auto_reload_interval)

                # Check if we need to handle ticket number and captcha (UTK0201_001 page)
                is_do_ibon_performance_with_ticket_number = False

                # UTK0201_001 page: has PERFORMANCE_PRICE_AREA_ID parameter
                if 'PERFORMANCE_PRICE_AREA_ID=' in url.upper():
                    is_do_ibon_performance_with_ticket_number = True

                # UTK0201_000 page: check if ticket selection appears on same page
                if 'PRODUCT_ID=' in url.upper():
                    if not is_price_assign_by_bot:
                        # This case shows captcha and ticket-number on the same page
                        # Check if ticket number dropdown exists
                        try:
                            selector = 'table.table > tbody > tr > td > select'
                            form_select = await tab.query_selector(selector)
                            if form_select:
                                is_do_ibon_performance_with_ticket_number = True
                        except Exception as exc:
                            pass

                if is_do_ibon_performance_with_ticket_number:
                    # Wait for page to load before checking sold-out (prevents false detection)
                    show_debug_message = config_dict["advanced"].get("verbose", False)
                    await nodriver_ibon_wait_for_select_elements(tab, config_dict)

                    # Step 0: Check if tickets are sold out FIRST (before OCR)
                    is_sold_out_detected = await nodriver_ibon_check_sold_out_on_ticket_page(tab, config_dict)

                    if is_sold_out_detected:
                        if show_debug_message:
                            print("[IBON] All tickets sold out, navigating to area selection...")

                        # Fix (2026-01-07): Navigate to area selection instead of reload (prevents infinite loop)
                        await nodriver_ibon_navigate_on_sold_out(tab, config_dict)

                        # Wait before next check (FR-061: auto_reload_page_interval)
                        auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                        if auto_reload_interval > 0:
                            if show_debug_message:
                                print(f"[AUTO RELOAD] Waiting {auto_reload_interval} seconds before next check...")
                            await asyncio.sleep(auto_reload_interval)

                        return False  # Return to main loop to continue monitoring

                    # Step 1: Handle non-adjacent seat checkbox
                    if config_dict["advanced"]["disable_adjacent_seat"]:
                        try:
                            await nodriver_ibon_allow_not_adjacent_seat(tab, config_dict)
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[IBON] Checkbox error: {exc}")

                    # Step 2: Assign ticket number FIRST (before captcha)
                    # Fix (2026-01-07): Captcha auto_submit checks if ticket number is selected.
                    # Must select ticket number first, then process captcha.
                    is_ticket_number_assigned = False
                    max_retries = 3

                    try:
                        for attempt in range(1, max_retries + 1):
                            is_ticket_number_assigned = await nodriver_ibon_ticket_number_auto_select(tab, config_dict)

                            if is_ticket_number_assigned:
                                if show_debug_message and attempt > 1:
                                    print(f"[TICKET RETRY] Success after {attempt} attempt(s)")
                                break

                            if attempt < max_retries:
                                delay = 0.5 * (2 ** (attempt - 1))
                                if show_debug_message:
                                    print(f"[TICKET RETRY] Attempt {attempt}/{max_retries} failed, waiting {delay}s (exponential backoff)")
                                await asyncio_sleep_with_pause_check(delay, config_dict)

                        if is_ticket_number_assigned:
                            # Wait for iBon to process ticket number change
                            await asyncio.sleep(random.uniform(0.15, 0.25))
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[IBON] Ticket number error: {exc}")

                    # Step 3: Handle captcha (after ticket number is selected)
                    is_captcha_sent = False
                    if config_dict["ocr_captcha"]["enable"]:
                        try:
                            # Initialize OCR instance
                            import ddddocr
                            ocr = ddddocr.DdddOcr(show_ad=False, beta=config_dict["ocr_captcha"]["beta"])
                            ocr.set_ranges(0)  # Restrict to digits only for ibon

                            is_captcha_sent = await nodriver_ibon_captcha(tab, config_dict, ocr)
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[IBON] Captcha error: {exc}")

                    # Step 3.5: Final check if tickets are sold out (backup check)
                    if not is_ticket_number_assigned:
                        is_sold_out_detected = await nodriver_ibon_check_sold_out_on_ticket_page(tab, config_dict)

                        if is_sold_out_detected:
                            if show_debug_message:
                                print("[IBON] All tickets sold out, navigating to area selection...")

                            # Fix (2026-01-07): Navigate to area selection instead of reload (prevents infinite loop)
                            await nodriver_ibon_navigate_on_sold_out(tab, config_dict)

                            # Wait before next check (FR-061: auto_reload_page_interval)
                            auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                            if auto_reload_interval > 0:
                                if show_debug_message:
                                    print(f"[AUTO RELOAD] Waiting {auto_reload_interval} seconds before next check...")
                                await asyncio.sleep(auto_reload_interval)

                            return False  # Return to main loop to continue monitoring

                    # Step 4: Submit purchase
                    if is_ticket_number_assigned and is_captcha_sent:
                        try:
                            click_ret = await nodriver_ibon_purchase_button_press(tab, config_dict)
                            if click_ret:
                                # Play "ticket" sound when attempting to enter checkout (found ticket)
                                if not ibon_dict.get("played_sound_ticket", False):
                                    if config_dict["advanced"]["play_sound"]["ticket"]:
                                        play_sound_while_ordering(config_dict)
                                    ibon_dict["played_sound_ticket"] = True
                        except Exception as exc:
                            show_debug_message = config_dict["advanced"].get("verbose", False)
                            if show_debug_message:
                                print(f"[IBON] Submit button error: {exc}")

            # Handle case when area is already selected (direct access to UTK0201_001 page)
            elif is_area_already_selected:
                is_match_target_feature = True
                show_debug_message = config_dict["advanced"].get("verbose", False)

                if show_debug_message:
                    print("[IBON] Area already selected, checking ticket availability...")

                # Check if we need to handle ticket number and captcha (UTK0201_001 page)
                is_do_ibon_performance_with_ticket_number = False

                # UTK0201_001 page: has PERFORMANCE_PRICE_AREA_ID parameter
                if 'PERFORMANCE_PRICE_AREA_ID=' in url.upper():
                    is_do_ibon_performance_with_ticket_number = True

                if is_do_ibon_performance_with_ticket_number:
                    # Wait for page to load before checking sold-out (prevents false detection)
                    await nodriver_ibon_wait_for_select_elements(tab, config_dict)

                    # Step 0: Check if tickets are sold out FIRST (before OCR)
                    is_sold_out_detected = await nodriver_ibon_check_sold_out_on_ticket_page(tab, config_dict)

                    if is_sold_out_detected:
                        if show_debug_message:
                            print("[IBON] All tickets sold out, navigating to area selection...")

                        # Fix (2026-01-07): Navigate to area selection instead of reload (prevents infinite loop)
                        await nodriver_ibon_navigate_on_sold_out(tab, config_dict)

                        # Wait before next check (FR-061: auto_reload_page_interval)
                        auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                        if auto_reload_interval > 0:
                            if show_debug_message:
                                print(f"[AUTO RELOAD] Waiting {auto_reload_interval} seconds before next check...")
                            await asyncio.sleep(auto_reload_interval)

                        return False  # Return to main loop to continue monitoring

                    # Step 1: Handle non-adjacent seat checkbox
                    if config_dict["advanced"]["disable_adjacent_seat"]:
                        try:
                            await nodriver_ibon_allow_not_adjacent_seat(tab, config_dict)
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[IBON] Checkbox error: {exc}")

                    # Step 2: Handle captcha (only executed when tickets are available)
                    is_captcha_sent = False
                    if config_dict["ocr_captcha"]["enable"]:
                        try:
                            # Initialize OCR instance
                            import ddddocr
                            ocr = ddddocr.DdddOcr(show_ad=False, beta=config_dict["ocr_captcha"]["beta"])
                            ocr.set_ranges(0)  # Restrict to digits only for ibon

                            is_captcha_sent = await nodriver_ibon_captcha(tab, config_dict, ocr)
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[IBON] Captcha error: {exc}")

                    # Step 3: Assign ticket number with retry
                    is_ticket_number_assigned = False
                    max_retries = 3

                    try:
                        for attempt in range(1, max_retries + 1):
                            is_ticket_number_assigned = await nodriver_ibon_ticket_number_auto_select(tab, config_dict)

                            if is_ticket_number_assigned:
                                if show_debug_message and attempt > 1:
                                    print(f"[TICKET RETRY] Success after {attempt} attempt(s)")
                                break

                            if attempt < max_retries:
                                delay = 0.5 * (2 ** (attempt - 1))
                                if show_debug_message:
                                    print(f"[TICKET RETRY] Attempt {attempt}/{max_retries} failed, waiting {delay}s")
                                await asyncio_sleep_with_pause_check(delay, config_dict)

                        if is_ticket_number_assigned:
                            # Wait for iBon to process ticket number change
                            await asyncio.sleep(random.uniform(0.15, 0.25))
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[IBON] Ticket number error: {exc}")

                    # Step 3.5: Final check if tickets are sold out (backup check)
                    if not is_ticket_number_assigned:
                        is_sold_out_detected = await nodriver_ibon_check_sold_out_on_ticket_page(tab, config_dict)

                        if is_sold_out_detected:
                            if show_debug_message:
                                print("[IBON] All tickets sold out, navigating to area selection...")

                            # Fix (2026-01-07): Navigate to area selection instead of reload (prevents infinite loop)
                            await nodriver_ibon_navigate_on_sold_out(tab, config_dict)

                            # Wait before next check (FR-061: auto_reload_page_interval)
                            auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                            if auto_reload_interval > 0:
                                if show_debug_message:
                                    print(f"[AUTO RELOAD] Waiting {auto_reload_interval} seconds before next check...")
                                await asyncio.sleep(auto_reload_interval)

                            return False  # Return to main loop to continue monitoring

                    # Step 4: Submit purchase
                    if is_ticket_number_assigned and is_captcha_sent:
                        try:
                            click_ret = await nodriver_ibon_purchase_button_press(tab, config_dict)
                            if click_ret:
                                # Play "ticket" sound when attempting to enter checkout (found ticket)
                                if not ibon_dict.get("played_sound_ticket", False):
                                    if config_dict["advanced"]["play_sound"]["ticket"]:
                                        play_sound_while_ordering(config_dict)
                                    ibon_dict["played_sound_ticket"] = True
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[IBON] Submit button error: {exc}")

    # New ibon Event page format (Angular SPA): https://ticket.ibon.com.tw/Event/{eventId}/{sessionId}[/{activityId}]
    if not is_match_target_feature:
        is_new_event_page = False
        if 'ticket.ibon.com.tw' in url.lower() and '/event/' in url.lower():
            url_parts = url.split('/')
            # URL format: https://ticket.ibon.com.tw/Event/B09QY340/B09VO5KQ
            # Split result: ['https:', '', 'ticket.ibon.com.tw', 'Event', 'B09QY340', 'B09VO5KQ']
            # URL format (with activity ID): https://ticket.ibon.com.tw/Event/B09QY340/B09VO5KQ/39142
            # Split result: ['https:', '', 'ticket.ibon.com.tw', 'Event', 'B09QY340', 'B09VO5KQ', '39142']
            if len(url_parts) >= 6:
                is_new_event_page = True

        if is_new_event_page:
            if config_dict["area_auto_select"]["enable"]:
                is_match_target_feature = True
                area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()

                is_need_refresh = False
                is_price_assign_by_bot = False

                if len(area_keyword) > 0:
                    area_keyword_array = []
                    try:
                        import json
                        area_keyword_array = json.loads("["+ area_keyword +"]")
                    except Exception as exc:
                        area_keyword_array = []

                    for area_keyword_item in area_keyword_array:
                        is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_event_area_auto_select(tab, config_dict, area_keyword_item)
                        if not is_need_refresh:
                            break

                    # Fallback: If all keyword groups failed, check area_auto_fallback setting
                    if not is_price_assign_by_bot:
                        if is_need_refresh:
                            area_auto_fallback = config_dict.get("area_auto_fallback", False)
                            if area_auto_fallback:
                                # Feature 003: Fallback enabled - use auto_select_mode without keyword
                                show_debug_message = config_dict["advanced"].get("verbose", False)
                                auto_select_mode = config_dict["area_auto_select"]["mode"]
                                if show_debug_message:
                                    print(f"[IBON EVENT] All keyword groups failed, area_auto_fallback=true")
                                    print(f"[IBON EVENT] Falling back to auto_select_mode: {auto_select_mode}")
                                is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_event_area_auto_select(tab, config_dict, "")
                            else:
                                # Feature 003: Fallback disabled - strict mode (no selection, will reload)
                                show_debug_message = config_dict["advanced"].get("verbose", False)
                                if show_debug_message:
                                    print(f"[IBON EVENT] All keyword groups failed, area_auto_fallback=false")
                                    print(f"[IBON EVENT] No area selected, will reload page and retry")
                                # Keep is_price_assign_by_bot=False and is_need_refresh=True
                                # This will trigger page reload in the outer loop
                else:
                    # empty keyword, match all.
                    is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_event_area_auto_select(tab, config_dict, area_keyword)

                show_debug_message = config_dict["advanced"].get("verbose", False)
                if show_debug_message:
                    print(f"[NEW EVENT] Area selection result - is_price_assign_by_bot: {is_price_assign_by_bot}, is_need_refresh: {is_need_refresh}")

                # Auto-reload if no available ticket areas found
                if is_need_refresh:
                    if show_debug_message:
                        print("[NEW EVENT] No available ticket areas found, page reload required")

                    try:
                        await tab.reload()
                        if show_debug_message:
                            print("[NEW EVENT] Page reloaded successfully")
                    except Exception as reload_exc:
                        if show_debug_message:
                            print(f"[NEW EVENT] Page reload failed: {reload_exc}")

                    # Use auto_reload_page_interval setting
                    auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                    if auto_reload_interval > 0:
                        await asyncio.sleep(auto_reload_interval)

            is_match_target_feature = True

    # New ibon EventBuy page format: https://ticket.ibon.com.tw/EventBuy/{eventId}/{sessionId}/{areaId}[/{activityId}]
    if not is_match_target_feature:
        is_new_eventbuy_page = False
        if 'ticket.ibon.com.tw' in url.lower() and '/eventbuy/' in url.lower():
            url_parts = url.split('/')
            # URL format: https://ticket.ibon.com.tw/EventBuy/B09QY340/B09VO5KQ/B09VO6K0
            # Split result: ['https:', '', 'ticket.ibon.com.tw', 'EventBuy', 'eventId', 'sessionId', 'areaId']
            # URL format (with activity ID): https://ticket.ibon.com.tw/EventBuy/B09QY340/B09VO5KQ/B09VSQGL/39142
            # Split result: ['https:', '', 'ticket.ibon.com.tw', 'EventBuy', 'B09QY340', 'B09VO5KQ', 'B09VSQGL', '39142']
            if len(url_parts) >= 7:
                is_new_eventbuy_page = True

        if is_new_eventbuy_page:
            is_match_target_feature = True
            show_debug_message = config_dict["advanced"].get("verbose", False)

            if show_debug_message:
                print("[NEW EVENTBUY] Processing EventBuy page")

            # Check disable_adjacent_seat
            if config_dict["advanced"]["disable_adjacent_seat"]:
                is_finish_checkbox_click = await nodriver_check_checkbox(tab, '.asp-checkbox > input[type="checkbox"]:not(:checked)')

            # Step 1: Assign ticket number first with retry (exponential backoff)
            is_ticket_number_assigned = False
            max_retries = 3
            show_debug_message = config_dict["advanced"].get("verbose", False)

            for attempt in range(1, max_retries + 1):
                is_ticket_number_assigned = await nodriver_ibon_ticket_number_auto_select(tab, config_dict)

                if is_ticket_number_assigned:
                    if show_debug_message and attempt > 1:
                        print(f"[TICKET RETRY] Success after {attempt} attempt(s)")
                    break

                if attempt < max_retries:
                    delay = 0.5 * (2 ** (attempt - 1))
                    if show_debug_message:
                        print(f"[TICKET RETRY] Attempt {attempt}/{max_retries} failed, waiting {delay}s (exponential backoff)")
                    await asyncio_sleep_with_pause_check(delay, config_dict)

            if is_ticket_number_assigned:
                # Wait for iBon to process ticket number change
                await asyncio.sleep(random.uniform(0.15, 0.25))

            # Step 2: Handle captcha after ticket number is selected
            is_captcha_sent = False
            if is_ticket_number_assigned:
                if show_debug_message:
                    print("[NEW EVENTBUY] Ticket number assigned, proceeding to captcha")

                # Extract model name from URL for captcha
                domain_name = url.split('/')[2]
                # For EventBuy, use sessionId as model name
                model_name = url.split('/')[5] if len(url.split('/')) > 5 else 'EventBuy'
                if len(model_name) > 7:
                    model_name = model_name[:7]
                captcha_url = '/pic.aspx?TYPE=%s' % (model_name)

                # Set cookies for Captcha_Browser if needed
                if not Captcha_Browser is None:
                    Captcha_Browser.set_domain(domain_name, captcha_url=captcha_url)

                # Call ibon captcha handler (handles both OCR and manual mode)
                is_captcha_sent = await nodriver_ibon_captcha(tab, config_dict, ocr)

            # Step 3: Click purchase button if everything is ready
            if is_ticket_number_assigned:
                if is_captcha_sent:
                    if show_debug_message:
                        print("[NEW EVENTBUY] Clicking purchase button")

                    click_ret = await nodriver_ibon_purchase_button_press(tab, config_dict)

                    # Play sound if button clicked successfully
                    if click_ret:
                        # Play "ticket" sound when attempting to enter checkout (found ticket)
                        if not ibon_dict.get("played_sound_ticket", False):
                            if config_dict["advanced"]["play_sound"]["ticket"]:
                                play_sound_while_ordering(config_dict)
                            ibon_dict["played_sound_ticket"] = True
                        if show_debug_message:
                            print("[NEW EVENTBUY] Purchase button clicked successfully")
            else:
                # Check if sold out
                is_sold_out = await nodriver_ibon_check_sold_out(tab, config_dict)
                if is_sold_out:
                    if show_debug_message:
                        print("[NEW EVENTBUY] Sold out detected, going back and refreshing")
                    try:
                        await tab.back()
                        await tab.reload()
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[NEW EVENTBUY] Back/reload failed: {exc}")

    if not is_match_target_feature:
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_000.aspx?PERFORMANCE_ID=0000
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_000.aspx?rn=1111&PERFORMANCE_ID=2222&PRODUCT_ID=BBBB
        # https://orders.ibon.com.tw/application/UTK02/UTK0201_001.aspx?PERFORMANCE_ID=2222&GROUP_ID=4&PERFORMANCE_PRICE_AREA_ID=3333

        is_event_page = False
        if '/UTK02/UTK0201_' in url.upper():
            if '.aspx?' in url.lower():
                if 'PERFORMANCE_ID=' in url.upper():
                    if len(url.split('/'))==6:
                        is_event_page = True

        if '/UTK02/UTK0202_' in url.upper():
            if '.aspx?' in url.lower():
                if 'PERFORMANCE_ID=' in url.upper():
                    if len(url.split('/'))==6:
                        is_event_page = True

        if is_event_page:
            if config_dict["area_auto_select"]["enable"]:
                select_query = "tr.disbled"
                # TODO:
                #clean_tag_by_selector(driver,select_query)
                
                select_query = "tr.sold-out"
                # TODO:
                #clean_tag_by_selector(driver,select_query)

                is_do_ibon_performance_with_ticket_number = False

                # Check if area is already selected (avoid duplicate selection causing double tickets)
                is_area_already_selected = 'PERFORMANCE_PRICE_AREA_ID=' in url.upper()

                if 'PRODUCT_ID=' in url.upper() and not is_area_already_selected:
                    # step 1: select area.
                    is_price_assign_by_bot = False
                    show_debug_message = config_dict["advanced"].get("verbose", False)

                    # Call area selection function (simplified version for testing)
                    # TODO: Implement nodriver_ibon_performance() wrapper with OR logic
                    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
                    is_need_refresh, is_price_assign_by_bot = await nodriver_ibon_area_auto_select(tab, config_dict, area_keyword)

                    if show_debug_message:
                        print(f"Area selection result - is_price_assign_by_bot: {is_price_assign_by_bot}, is_need_refresh: {is_need_refresh}")

                    # Auto-reload if no available ticket areas found
                    if is_need_refresh:
                        if show_debug_message:
                            print("[IBON AREA] No available ticket areas found, page reload required")

                        try:
                            await tab.reload()
                            if show_debug_message:
                                print("[IBON AREA] Page reloaded successfully")
                        except Exception as reload_exc:
                            if show_debug_message:
                                print(f"[IBON AREA] Page reload failed: {reload_exc}")

                        # Use auto_reload_page_interval setting
                        auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0)
                        if auto_reload_interval > 0:
                            await asyncio.sleep(auto_reload_interval)

                    if not is_price_assign_by_bot:
                        # this case show captcha and ticket-number in this page.
                        # TODO:
                        #if ibon_ticket_number_appear(driver, config_dict):
                        #    is_do_ibon_performance_with_ticket_number = True
                        pass

                # Old ibon format handling
                if 'PERFORMANCE_PRICE_AREA_ID=' in url.upper():
                    is_do_ibon_performance_with_ticket_number = True

                if is_do_ibon_performance_with_ticket_number:
                    if config_dict["advanced"]["disable_adjacent_seat"]:
                        # TODO:
                        is_finish_checkbox_click = await nodriver_check_checkbox(tab, '.asp-checkbox > input[type="checkbox"]:not(:checked)')

                    # Step 1: Assign ticket number first with retry (exponential backoff)
                    is_match_target_feature = True
                    is_ticket_number_assigned = False
                    max_retries = 3
                    show_debug_message = config_dict["advanced"].get("verbose", False)

                    for attempt in range(1, max_retries + 1):
                        is_ticket_number_assigned = await nodriver_ibon_ticket_number_auto_select(tab, config_dict)

                        if is_ticket_number_assigned:
                            if show_debug_message and attempt > 1:
                                print(f"[TICKET RETRY] Success after {attempt} attempt(s)")
                            break

                        if attempt < max_retries:
                            delay = 0.5 * (2 ** (attempt - 1))
                            if show_debug_message:
                                print(f"[TICKET RETRY] Attempt {attempt}/{max_retries} failed, waiting {delay}s (exponential backoff)")
                            await asyncio_sleep_with_pause_check(delay, config_dict)

                    if is_ticket_number_assigned:
                        # Wait for iBon to process ticket number change
                        await asyncio.sleep(random.uniform(0.15, 0.25))

                    # Step 2: Handle captcha after ticket number is selected
                    is_captcha_sent = False
                    if is_ticket_number_assigned:
                        domain_name = url.split('/')[2]
                        model_name = url.split('/')[5]
                        if len(model_name) > 7:
                            model_name=model_name[:7]
                        captcha_url = '/pic.aspx?TYPE=%s' % (model_name)

                        # Set cookies for Captcha_Browser if needed
                        if not Captcha_Browser is None:
                            Captcha_Browser.set_domain(domain_name, captcha_url=captcha_url)

                        # Call ibon captcha handler (handles both OCR and manual mode)
                        is_captcha_sent = await nodriver_ibon_captcha(tab, config_dict, ocr)
                    
                    #print("is_ticket_number_assigned:", is_ticket_number_assigned)
                    if is_ticket_number_assigned:
                        if is_captcha_sent:
                            click_ret = await nodriver_ibon_purchase_button_press(tab, config_dict)

                            # only this case: "ticket number CHANGED by bot" and "cpatcha sent" to play sound!
                            if click_ret:
                                # Play "ticket" sound when attempting to enter checkout (found ticket)
                                if not ibon_dict.get("played_sound_ticket", False):
                                    if config_dict["advanced"]["play_sound"]["ticket"]:
                                        play_sound_while_ordering(config_dict)
                                    ibon_dict["played_sound_ticket"] = True
                    else:
                        is_sold_out = await nodriver_ibon_check_sold_out(tab, config_dict)
                        if is_sold_out:
                            print("is_sold_out, go back , and refresh.")
                            # plan-A
                            #is_button_clicked = press_button(tab, By.CSS_SELECTOR, 'a.btn.btn-primary')
                            # plan-B, easy and better than plan-A
                            try:
                                tab.back()
                                tab.reload()
                            except Exception as exc:
                                pass


    if not is_match_target_feature:
        #https://orders.ibon.com.tw/application/UTK02/UTK0206_.aspx
        is_event_page = False
        if '/UTK02/UTK020' in url.upper():
            if '.aspx' in url.lower():
                if len(url.split('/'))==6:
                    is_event_page = True

        # ignore "pay money" step.
        if '/UTK02/UTK0207_.ASPX' in url.upper():
            is_event_page = False

        if is_event_page:
            if is_event_page:
                is_match_target_feature = True
                is_finish_checkbox_click = await nodriver_ibon_ticket_agree(tab)
                if is_finish_checkbox_click:
                    is_name_based = False
                    try:
                        html_body = await tab.get_content()
                        #print("html_body:",len(html_body))
                        if html_body:
                            if len(html_body) > 1024:
                                if '實名制' in html_body:
                                    is_name_based = True
                    except Exception as exc:
                        #print(exc)
                        pass

                    if not is_name_based:
                        is_button_clicked = await nodriver_press_button(tab, 'a.btn.btn-pink.continue')

    # Check if reached checkout page (ticket purchase successful)
    # https://orders.ibon.com.tw/application/UTK02/UTK0206_.aspx
    if '/utk02/utk0206_.aspx' in url.lower():
        # Show debug message (only once)
        if config_dict["advanced"].get("verbose", False):
            if not ibon_dict["shown_checkout_message"]:
                print("Reached checkout page - ticket purchase successful!")
            ibon_dict["shown_checkout_message"] = True

        # Play sound notification (only once)
        if not ibon_dict["played_sound_order"]:
            if config_dict["advanced"]["play_sound"]["order"]:
                play_sound_while_ordering(config_dict)
            send_discord_notification(config_dict, "order", "iBon")
        ibon_dict["played_sound_order"] = True

        # If headless mode, open browser to show checkout page (only once)
        if config_dict["advanced"]["headless"]:
            if not ibon_dict["is_popup_checkout"]:
                checkout_url = url
                print("搶票成功, 請前往該帳號訂單查看: %s" % (checkout_url))
                webbrowser.open_new(checkout_url)
                ibon_dict["is_popup_checkout"] = True
    else:
        # Reset status when leaving checkout page
        ibon_dict["is_popup_checkout"] = False
        ibon_dict["played_sound_order"] = False
        ibon_dict["shown_checkout_message"] = False


async def nodriver_cityline_auto_retry_access(tab, url, config_dict):
    try:
        js = "goEvent();"
        await tab.evaluate(js)
    except Exception as exc:
        print(exc)
        pass

    # 刷太快, 會被封IP?
    # must wait...? no need to wait.
    auto_reload_page_interval = config_dict["advanced"]["auto_reload_page_interval"]
    if auto_reload_page_interval > 0:
        await asyncio.sleep(auto_reload_page_interval)

async def nodriver_cityline_login(tab, cityline_account):
    """
    Cityline login with auto-click when button becomes enabled
    Strategy: Input email → Monitor login button → Auto-click when enabled
    Reference: button.login-btn.submit-btn (becomes enabled after password + verification)
    """
    global is_cityline_account_assigned
    if not 'is_cityline_account_assigned' in globals():
        is_cityline_account_assigned = False

    if not is_cityline_account_assigned:
        try:
            # Step 1: Input email/account
            el_account = await tab.query_selector('input[type="text"]')
            if el_account:
                await el_account.click()
                await el_account.apply('function (element) {element.value = ""; }')
                await el_account.send_keys(cityline_account)
                await asyncio.sleep(random.uniform(0.4, 0.7))
                is_cityline_account_assigned = True
                print(f"[CITYLINE LOGIN] Email entered: {cityline_account[:3]}***")
                print("[CITYLINE LOGIN] Please manually enter password and verification code")
                print("[CITYLINE LOGIN] Monitoring login button... will auto-click when enabled")
        except Exception as exc:
            print(f"[ERROR] Failed to input email: {exc}")
            pass
    else:
        # Step 2: Monitor login button and auto-click when enabled
        try:
            # Check if login button is enabled (no disabled attribute)
            button_enabled = await tab.evaluate('''
                (function() {
                    const loginBtn = document.querySelector('button.login-btn.submit-btn');
                    if (loginBtn) {
                        return !loginBtn.hasAttribute('disabled') && !loginBtn.disabled;
                    }
                    return false;
                })()
            ''')

            if button_enabled:
                # Auto-click the login button
                click_result = await tab.evaluate('''
                    (function() {
                        const loginBtn = document.querySelector('button.login-btn.submit-btn');
                        if (loginBtn) {
                            loginBtn.click();
                            return true;
                        }
                        return false;
                    })()
                ''')

                if click_result:
                    print("[CITYLINE LOGIN] Login button auto-clicked!")
                    await asyncio.sleep(random.uniform(1.0, 2.0))
        except Exception as exc:
            pass  # Silent fail, will retry on next loop

async def nodriver_cityline_date_auto_select(tab, config_dict):
    """
    Cityline date selection with conditional fallback mechanism
    Reference: spec.md FR-003, FR-003a, FR-003b, fallback-mechanism.md
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get("date_auto_fallback", False)  # Read from top level
    auto_reload_coming_soon_page = config_dict.get("auto_reload_coming_soon_page", False)

    ret = False

    # Stage 1: Query all date buttons
    area_list = None
    try:
        my_css_selector = "button.date-time-position"
        area_list = await tab.query_selector_all(my_css_selector)
    except Exception as exc:
        if show_debug_message:
            print(f"[ERROR] find date list fail: {exc}")

    # Stage 2: Format and filter enabled dates
    formated_area_list = []
    if area_list:
        area_list_count = len(area_list)
        if show_debug_message:
            print(f"[CITYLINE DATE] Found {area_list_count} date buttons")

        if area_list_count > 0:
            formated_area_list = area_list  # NoDriver elements are already enabled

    # Stage 3: Keyword matching
    matched_blocks = []
    if len(date_keyword) == 0:
        # Empty keyword matches all available dates
        matched_blocks = formated_area_list
    else:
        # Match keyword
        if show_debug_message:
            print(f"[DATE KEYWORD] Matching keyword: {date_keyword}")

        for row in formated_area_list:
            row_text = ""
            try:
                row_html = await row.get_html()
                row_text = util.remove_html_tags(row_html)
            except Exception as exc:
                if show_debug_message:
                    print(f"[DEBUG] get row html error: {exc}")
                break

            if len(row_text) > 0:
                if show_debug_message:
                    print(f"[DEBUG] row_text: {row_text}")
                is_match_area = util.is_row_match_keyword(date_keyword, row_text)
                if is_match_area:
                    matched_blocks.append(row)
                    if auto_select_mode == CONST_FROM_TOP_TO_BOTTOM:
                        break

    if show_debug_message:
        print(f"[DATE KEYWORD] Matched {len(matched_blocks)} dates")

    # Stage 4: Conditional fallback mechanism
    if len(matched_blocks) == 0:
        if date_auto_fallback:
            # Fallback mode: select from all available dates
            matched_blocks = formated_area_list
            print(f"[DATE FALLBACK] date_auto_fallback=true, selecting from all available dates (total: {len(formated_area_list)})")
        else:
            # Strict mode
            print("[DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
            if auto_reload_coming_soon_page and len(formated_area_list) == 0:
                # Auto reload if no dates available
                print("[DATE FALLBACK] Auto-reloading page...")
                try:
                    await tab.reload()
                    await asyncio.sleep(config_dict.get("auto_reload_page_interval", 1.5))
                except:
                    pass
            else:
                print("[DATE FALLBACK] Waiting for manual intervention...")
            return False

    # Stage 5: Select target date
    target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)
    if target_area:
        try:
            await target_area.scroll_into_view()
            await target_area.click()
            if show_debug_message:
                print("[CITYLINE DATE] Purchase button clicked")

            # Wait for Cloudflare Turnstile (FR-012)
            print("[CITYLINE DATE] Waiting 3 seconds for Cloudflare Turnstile...")
            await asyncio.sleep(3)

            ret = True
        except Exception as exc:
            print(f"[ERROR] click date button fail: {exc}")

    return ret

async def nodriver_cityline_check_login_modal(tab, config_dict):
    """
    Check and handle login modal on eventDetail page
    Reference: .temp/cityline/54510/1.html - div.modal-content with login form
    Uses global flag to prevent duplicate clicks on same modal
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_modal_handled = False

    # Global flag to track if modal has been handled
    global cityline_modal_handled
    if not 'cityline_modal_handled' in globals():
        cityline_modal_handled = False

    try:
        # Wait for modal to appear (if it will)
        await asyncio.sleep(random.uniform(1.0, 1.5))

        # Check if login modal exists and is visible
        modal_visible = await tab.evaluate('''
            (function() {
                const modal = document.querySelector('div.modal-content');
                const loginBtn = document.querySelector('button.btn-login');
                if (modal && loginBtn) {
                    // Check if modal is actually visible (display != none, opacity > 0)
                    const style = window.getComputedStyle(modal);
                    return style.display !== 'none' && style.opacity !== '0';
                }
                return false;
            })()
        ''')

        if modal_visible and not cityline_modal_handled:
            print("[CITYLINE LOGIN MODAL] Login modal detected, waiting for button to be enabled...")

            # Wait for login button to be enabled (opacity: 1 after Turnstile)
            button_enabled = False
            max_wait = 10  # Maximum 10 seconds
            for i in range(max_wait):
                button_enabled = await tab.evaluate('''
                    (function() {
                        const loginBtn = document.querySelector('button.btn-login');
                        if (loginBtn) {
                            const style = window.getComputedStyle(loginBtn);
                            return parseFloat(style.opacity) === 1;
                        }
                        return false;
                    })()
                ''')

                if button_enabled:
                    if show_debug_message:
                        print(f"[CITYLINE LOGIN MODAL] Button enabled after {i}s")
                    break

                await asyncio.sleep(1)

            if button_enabled:
                # Use CDP to click the login button (to properly trigger onclick event)
                try:
                    login_btn = await tab.find('button.btn-login', timeout=3)
                    if login_btn:
                        await login_btn.click()
                        print("[CITYLINE LOGIN MODAL] Login button clicked successfully (CDP)")
                        is_modal_handled = True
                        cityline_modal_handled = True  # Mark as handled to prevent duplicate clicks

                        # Wait longer for modal to fully close and process
                        await asyncio.sleep(random.uniform(4.0, 5.0))
                    else:
                        print("[CITYLINE LOGIN MODAL] Login button not found")
                except Exception as e:
                    print(f"[CITYLINE LOGIN MODAL] Failed to click login button: {e}")
            else:
                print("[CITYLINE LOGIN MODAL] Button not enabled after timeout")
        elif cityline_modal_handled:
            # Modal already handled, skip silently
            pass
        else:
            if show_debug_message:
                print("[CITYLINE LOGIN MODAL] No login modal detected")

    except Exception as exc:
        print(f"[ERROR] Login modal check failed: {exc}")

    return is_modal_handled

async def nodriver_cityline_continue_button_press(tab, config_dict):
    """
    Click the 'Continue' button on eventDetail page to proceed to performance page
    Reference: .temp/cityline/54510/1.html - button.btn-outline-primary.purchase-btn
    Note: Login modal is already handled in parent function, no need to check again
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_button_clicked = False

    try:
        # Wait a moment for page to stabilize
        await asyncio.sleep(random.uniform(0.5, 1.0))

        # Check if continue button exists
        button_exists = await tab.evaluate('''
            (function() {
                const btn = document.querySelector('button.btn-outline-primary.purchase-btn');
                return btn !== null && btn.offsetParent !== null;
            })()
        ''')

        if button_exists:
            if show_debug_message:
                print("[CITYLINE CONTINUE] Continue button found, attempting to click...")

            # Click the continue button
            click_result = await tab.evaluate('''
                (function() {
                    const btn = document.querySelector('button.btn-outline-primary.purchase-btn');
                    if (btn) {
                        btn.click();
                        return true;
                    }
                    return false;
                })()
            ''')

            if click_result:
                print("[CITYLINE CONTINUE] Continue button clicked successfully")
                is_button_clicked = True

                # Wait for navigation to performance page
                await asyncio.sleep(random.uniform(2.0, 3.0))
            else:
                print("[CITYLINE CONTINUE] Failed to click continue button via JS")
        else:
            if show_debug_message:
                print("[CITYLINE CONTINUE] Continue button not found")

    except Exception as exc:
        print(f"[ERROR] Continue button press failed: {exc}")

    return is_button_clicked

async def nodriver_cityline_area_auto_select(tab, config_dict):
    """
    Cityline area selection with conditional fallback mechanism
    Reference: spec.md FR-004, FR-004a, FR-004b, fallback-mechanism.md
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
    area_auto_fallback = config_dict.get("area_auto_fallback", False)  # Read from top level

    is_price_assigned = False

    # Stage 1: Query all area options
    area_list = None
    try:
        my_css_selector = "div.form-check"
        area_list = await tab.query_selector_all(my_css_selector)
    except Exception as exc:
        if show_debug_message:
            print(f"[ERROR] find area list fail: {exc}")

    # Stage 2: Filter soldout areas
    available_areas = []
    if area_list:
        area_list_count = len(area_list)
        if show_debug_message:
            print(f"[CITYLINE AREA] Found {area_list_count} area options")

        for row in area_list:
            is_available = True
            try:
                # Check soldout status
                soldout_span = await row.query_selector('span.price-limited > span[data-i18n*="soldout"]')
                if soldout_span:
                    is_available = False
            except:
                pass

            if is_available:
                available_areas.append(row)

        if show_debug_message:
            soldout_count = area_list_count - len(available_areas)
            print(f"[CITYLINE AREA] Filtered {soldout_count} soldout areas, {len(available_areas)} available")

    # Stage 3: Keyword matching
    matched_areas = []
    if len(area_keyword) == 0:
        # Empty keyword matches all available areas
        matched_areas = available_areas
    else:
        # Match keyword
        for row in available_areas:
            row_text = ""
            try:
                row_html = await row.get_html()
                row_text = util.remove_html_tags(row_html)
            except Exception as exc:
                if show_debug_message:
                    print(f"[DEBUG] get row html error: {exc}")
                break

            if len(row_text) > 0:
                # Check keyword exclude
                if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                    row_text = ""

            if len(row_text) > 0:
                row_text = util.format_keyword_string(row_text)
                if show_debug_message:
                    print(f"[DEBUG] row_text: {row_text}")

                # AND logic keyword matching
                is_match_area = True
                area_keyword_array = area_keyword.split(' ')
                for keyword in area_keyword_array:
                    keyword = util.format_keyword_string(keyword)
                    if keyword not in row_text:
                        is_match_area = False
                        break

                if is_match_area:
                    matched_areas.append(row)
                    if auto_select_mode == CONST_FROM_TOP_TO_BOTTOM:
                        break

    if show_debug_message:
        print(f"[AREA KEYWORD] Matched {len(matched_areas)} areas")

    # Stage 4: Conditional fallback mechanism
    if len(matched_areas) == 0:
        if area_auto_fallback:
            # Fallback mode: select from all available areas
            matched_areas = available_areas
            print(f"[AREA FALLBACK] area_auto_fallback=true, selecting from all available areas (total: {len(available_areas)})")
        else:
            # Strict mode: wait for manual intervention
            print("[AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
            print("[AREA FALLBACK] Waiting for manual intervention to avoid selecting unwanted area...")
            return False

    # Stage 5: Select target area
    target_area = util.get_target_item_from_matched_list(matched_areas, auto_select_mode)
    if target_area:
        try:
            # Find radio button within target area
            radio_btn = await target_area.query_selector('input[type=radio]')
            if radio_btn:
                await radio_btn.scroll_into_view()
                await radio_btn.click()
                is_price_assigned = True
                if show_debug_message:
                    print("[CITYLINE AREA] Radio button checked")
        except Exception as exc:
            print(f"[ERROR] click radio button fail: {exc}")

    return is_price_assigned

async def nodriver_cityline_ticket_number_auto_select(tab, config_dict):
    """
    Cityline ticket number selection
    Reference: spec.md FR-005, cityline-interface.md
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict.get("ticket_number", 1)

    is_ticket_number_assigned = False

    try:
        my_css_selector = "select.select-num"
        select_obj = await tab.query_selector(my_css_selector)

        if select_obj:
            if show_debug_message:
                print(f"[CITYLINE TICKET] Ticket number selector found")

            # Use JavaScript to set the select value
            is_ticket_number_assigned = await tab.evaluate(f'''
                (function() {{
                    const select = document.querySelector('{my_css_selector}');
                    if (select) {{
                        const options = select.options;
                        for (let i = 0; i < options.length; i++) {{
                            if (options[i].value == {ticket_number}) {{
                                select.selectedIndex = i;
                                select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                return true;
                            }}
                        }}
                    }}
                    return false;
                }})();
            ''')

            if is_ticket_number_assigned and show_debug_message:
                print(f"[CITYLINE TICKET] Ticket number set to {ticket_number}")
    except Exception as exc:
        print(f"[ERROR] Ticket number selection fail: {exc}")

    return is_ticket_number_assigned

async def nodriver_cityline_next_button_press(tab):
    """
    Cityline next button press
    Reference: spec.md FR-006, cityline-interface.md
    """
    is_button_clicked = False

    try:
        # Cityline express purchase button selectors (based on HTML analysis)
        # Reference: .temp/cityline/54510/2.html - button#expressPurchaseBtn
        selectors = [
            'button#expressPurchaseBtn',                      # ID selector (primary)
            'button.btn-express-purchase',                    # Class selector
            'button.purchase-btn.btn-express-purchase',      # Compound selector
            'button[onclick*="expressPurchaseCallBack"]',    # onclick attribute
            'button[type="submit"]',                          # Generic fallback
            'button.btn-next',                                # Legacy fallback
            'input[type="submit"]'                            # Last resort fallback
        ]

        for selector in selectors:
            try:
                next_btn = await tab.query_selector(selector)
                if next_btn:
                    await next_btn.scroll_into_view()
                    await next_btn.click()
                    is_button_clicked = True
                    print(f"[CITYLINE] Next button clicked: {selector}")
                    break
            except:
                continue
    except Exception as exc:
        print(f"[ERROR] Next button press fail: {exc}")

    return is_button_clicked

async def nodriver_cityline_performance(tab, config_dict):
    """
    Cityline performance page (date + area + ticket number + next button)
    Reference: .temp/cityline/54510/2.html - 選擇日期與票價的頁面
    Returns True only if the entire flow completes (including next button click)
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    is_date_assigned = False
    is_price_assigned = False
    is_button_clicked = False

    # Step 1: Date selection (if date buttons exist on this page)
    is_date_assigned = await nodriver_cityline_date_auto_select(tab, config_dict)

    if is_date_assigned:
        # Step 2: Area selection
        is_price_assigned = await nodriver_cityline_area_auto_select(tab, config_dict)

        if is_price_assigned:
            # Step 3: Ticket number selection
            is_ticket_number_assigned = await nodriver_cityline_ticket_number_auto_select(tab, config_dict)

            if is_ticket_number_assigned:
                # Step 4: Press next button
                await asyncio.sleep(random.uniform(0.3, 0.7))
                is_button_clicked = await nodriver_cityline_next_button_press(tab)

    # Return True only if next button was successfully clicked
    return is_button_clicked

async def nodriver_cityline_check_shopping_basket(tab, config_dict):
    """
    Check if ticket successfully added to shopping basket and play notification sound (once only)
    Reference: .temp/cityline/54510/3.html - shoppingBasket page
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    global cityline_dict

    try:
        current_url = await tab.evaluate('window.location.href')

        if '/shoppingBasket' in current_url:
            # Only play sound once
            if not cityline_dict.get("played_sound_order", False):
                print("[CITYLINE SUCCESS] Ticket added to shopping basket!")

                # Play success sound and send Discord notification
                if config_dict["advanced"]["play_sound"]["order"]:
                    try:
                        play_sound_while_ordering(config_dict)
                    except Exception as sound_exc:
                        if show_debug_message:
                            print(f"[CITYLINE] Sound error: {sound_exc}")
                send_discord_notification(config_dict, "order", "Cityline")
                cityline_dict["played_sound_order"] = True

            # Return True to indicate we're on checkout page
            return True

    except Exception as e:
        if show_debug_message:
            print(f"[CITYLINE] Checkout check error: {e}")

    return False

async def nodriver_check_modal_dialog_popup(tab):
    ret = False
    try:
        el_div = await tab.query_selector('div.modal-dialog > div.modal-content')
        if el_div:
            ret = True
    except Exception as exc:
        print(exc)
        pass
    return ret

async def nodriver_cityline_purchase_button_press(tab, config_dict):
    """
    Cityline eventDetail page processing (NO DATE SELECTION HERE)

    eventDetail page flow:
    1. Click 'Continue' button to proceed to performance page

    Note:
    - Login modal is checked in main loop (outside this function)
    - Date/Area selection happens on performance page, NOT here
    Reference: .temp/cityline/54510/1.html
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    is_button_clicked = False

    # Click 'Continue' button to go to performance page
    if show_debug_message:
        print("[CITYLINE EVENTDETAIL] Clicking continue button...")
    is_button_clicked = await nodriver_cityline_continue_button_press(tab, config_dict)

    return is_button_clicked

async def nodriver_cityline_close_second_tab(tab, url):
    new_tab = tab
    #print("tab count:", len(tab.browser.tabs))
    if len(tab.browser.tabs) > 1:
        # wait page ready.
        await asyncio.sleep(0.3)
        for tmp_tab in tab.browser.tabs:
            if tmp_tab != tab:
                tmp_url, is_quit_bot = await nodriver_current_url(tmp_tab)
                if len(tmp_url) > 0:
                    if tmp_url[:5] == "https":
                        await new_tab.activate()
                        await tab.close()
                        await asyncio.sleep(0.3)
                        new_tab = tmp_tab
                        break
    return new_tab

async def nodriver_cityline_cookie_accept(tab):
    """
    Cityline cookie consent acceptance
    Reference: spec.md FR-010
    """
    is_accepted = False

    try:
        # Try to find and click cookie accept button
        cookie_selectors = [
            'button.cookie-accept',
            'button[id*="cookie"]',
            'button[class*="cookie"]',
            '.cookie-consent button',
            '#cookie-consent button'
        ]

        for selector in cookie_selectors:
            try:
                cookie_btn = await tab.query_selector(selector)
                if cookie_btn:
                    await cookie_btn.click()
                    is_accepted = True
                    print(f"[CITYLINE] Cookie consent accepted: {selector}")
                    break
            except:
                continue
    except Exception as exc:
        pass

    return is_accepted

async def nodriver_cityline_press_buy_button(tab, config_dict):
    """
    Wait for and click the "Buy Ticket" button on shows.cityline.com event detail page
    Handles JavaScript loading issues and waits for button to appear
    Reference: shows.cityline.com event pages
    """
    # Check pause state
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print("[CITYLINE] Waiting for buy ticket button to appear...")

    # Polling parameters
    max_wait = 10  # Maximum 10 seconds wait
    check_interval = 0.5  # Check every 0.5 seconds
    max_attempts = int(max_wait / check_interval)
    button_found = False

    for attempt in range(max_attempts):
        try:
            # Check if button exists using JavaScript
            button_exists = await tab.evaluate('''
                (function() {
                    const btn = document.querySelector('button#buyTicketBtn');
                    return btn !== null && btn.offsetParent !== null;
                })()
            ''')

            if button_exists:
                button_found = True
                if show_debug_message:
                    print(f"[CITYLINE] Buy ticket button found after {attempt * check_interval:.1f}s")
                break

            # Progress indicator
            if show_debug_message and attempt > 0 and attempt % 4 == 0:
                print(f"[CITYLINE] Still waiting for button... ({attempt * check_interval:.1f}s elapsed)")

        except Exception as exc:
            if show_debug_message:
                print(f"[CITYLINE] Error checking button: {exc}")

        if attempt < max_attempts - 1:
            await asyncio.sleep(check_interval)

    if not button_found:
        print("[CITYLINE] Warning: Buy ticket button not found after timeout")
        print("[CITYLINE] This may be caused by:")
        print("  1. Ad blocker blocking JavaScript files (others.min.js)")
        print("  2. DevTools request blocking rules")
        print("  3. Page not fully loaded")
        print("[CITYLINE] Please manually click the buy ticket button")
        return False

    # Button found, try to click it
    try:
        # Use JavaScript click to avoid issues with visibility
        click_result = await tab.evaluate('''
            (function() {
                const btn = document.querySelector('button#buyTicketBtn');
                if (btn) {
                    btn.click();
                    return true;
                }
                return false;
            })()
        ''')

        if click_result:
            print("[CITYLINE] Buy ticket button clicked successfully")
            await asyncio.sleep(random.uniform(1.0, 2.0))
            return True
        else:
            print("[CITYLINE] Failed to click buy ticket button")
            return False

    except Exception as exc:
        print(f"[CITYLINE] Error clicking button: {exc}")
        return False

async def nodriver_cityline_clean_ads(tab):
    """
    Cityline advertisement removal (refined selectors to prevent removing purchase button)
    Reference: spec.md FR-008
    IMPORTANT: Use precise selectors to avoid removing .buyTicketBox or button#buyTicketBtn
    """
    is_ads_removed = False

    try:
        # Use JavaScript to remove ad elements with precise selectors
        is_ads_removed = await tab.evaluate('''
            (function() {
                let removed_count = 0;
                // Use precise selectors to avoid removing purchase-related elements
                const ad_selectors = [
                    'div.advertisement',           // Explicit div.advertisement
                    'div.ad-banner',               // Explicit div.ad-banner
                    'iframe[id*="google_ads"]',    // Google Ads iframes only
                    'div[id^="ATS_"]',             // ATS ad system (Cityline specific)
                    'div.popup-ad',
                    'div.modal-ad'
                    // Removed generic '[id*="ad-"]' and '[class*="ad-"]' to prevent removing button elements
                ];

                ad_selectors.forEach(selector => {
                    const ads = document.querySelectorAll(selector);
                    ads.forEach(ad => {
                        // Verify not removing purchase button or its container
                        const hasButton = ad.querySelector('button#buyTicketBtn');
                        const isBuyBox = ad.classList.contains('buyTicketBox');

                        if (!hasButton && !isBuyBox) {
                            ad.remove();
                            removed_count++;
                        }
                    });
                });

                if (removed_count > 0) {
                    console.log("Removed " + removed_count + " ad elements");
                }

                return removed_count > 0;
            })();
        ''')

        if is_ads_removed:
            print("[CITYLINE] Advertisements removed")
    except Exception as exc:
        pass

    return is_ads_removed

async def nodriver_cityline_main(tab, url, config_dict):
    global cityline_dict
    if not 'cityline_dict' in globals():
        cityline_dict = {}
        cityline_dict["played_sound_ticket"] = False
        cityline_dict["played_sound_order"] = False

    if 'msg.cityline.com' in url or 'event.cityline.com' in url:
        is_dom_ready = False
        try:
            html_body = await tab.get_content()
            if html_body:
                if len(html_body) > 10240:
                    is_dom_ready = True
        except Exception as exc:
            pass
        if is_dom_ready:
            #await nodriver_cityline_auto_retry_access(tab, url, config_dict)
            pass

    # Cookie acceptance (FR-010)
    if '.cityline.com/Events.html' in url:
        await nodriver_cityline_cookie_accept(tab)

    # Advertisement removal (FR-008)
    # Note: Only clean ads on Events.html (homepage), not on event detail pages
    # to prevent removing purchase button
    if '/Events.html' in url:
        await nodriver_cityline_clean_ads(tab)

        # Auto-redirect to target event page after successful login
        target_url = config_dict["homepage"]
        if target_url and 'shows.cityline.com' in target_url:
            show_debug_message = config_dict["advanced"].get("verbose", False)
            if show_debug_message:
                print(f"[CITYLINE LOGIN] Redirecting to target page: {target_url}")
            try:
                await tab.get(target_url)
                await asyncio.sleep(random.uniform(1.5, 2.5))
                # Update URL after redirect
                url = await tab.evaluate('window.location.href')
            except Exception as exc:
                if show_debug_message:
                    print(f"[ERROR] Redirect failed: {exc}")

    # Login page
    if 'cityline.com/Login.html' in url:
        cityline_account = config_dict["accounts"]["cityline_account"]
        if len(cityline_account) > 4:
            # Auto-fill email and monitor login button (will auto-click when enabled)
            await nodriver_cityline_login(tab, cityline_account)

    # Multi-tab handling (FR-009)
    tab = await nodriver_cityline_close_second_tab(tab, url)

    # Event detail page on shows.cityline.com
    # https://shows.cityline.com/tc/2026/jordanchan.html
    global cityline_buy_button_pressed
    if not 'cityline_buy_button_pressed' in globals():
        cityline_buy_button_pressed = False

    if 'shows.cityline.com' in url:
        if not cityline_buy_button_pressed:
            # Wait for and click buy ticket button
            button_clicked = await nodriver_cityline_press_buy_button(tab, config_dict)
            if button_clicked:
                cityline_buy_button_pressed = True
                # Wait for navigation to eventDetail page
                await asyncio.sleep(random.uniform(1.0, 2.0))
                # Update URL after button click
                try:
                    url = await tab.evaluate('window.location.href')
                except:
                    pass
    else:
        # Reset flag when leaving shows.cityline.com domain
        cityline_buy_button_pressed = False

    # date page.
    #https://venue.cityline.com/utsvInternet/EVENT_NAME/eventDetail?event=EVENT_CODE
    global cityline_purchase_button_pressed
    if not 'cityline_purchase_button_pressed' in globals():
        cityline_purchase_button_pressed = False

    if 'venue.cityline.com' in url and '/eventDetail?' in url:
        # Always check for login modal (independent of flag, for cookie capture)
        await nodriver_cityline_check_login_modal(tab, config_dict)

        # Then proceed with purchase button if not already processed
        if not cityline_purchase_button_pressed:
            if config_dict["date_auto_select"]["enable"]:
                is_button_clicked = await nodriver_cityline_purchase_button_press(tab, config_dict)
                if is_button_clicked:
                    cityline_purchase_button_pressed = True
    elif 'venue.cityline.com' not in url:
        # Only reset when completely leaving venue.cityline.com domain
        cityline_purchase_button_pressed = False


    # area page:
    # https://venue.cityline.com/utsvInternet/EVENT_NAME/performance?event=EVENT_CODE&perfId=PROFORMANCE_ID
    global cityline_performance_processed
    if not 'cityline_performance_processed' in globals():
        cityline_performance_processed = False

    global cityline_modal_handled
    if not 'cityline_modal_handled' in globals():
        cityline_modal_handled = False

    if 'venue.cityline.com' in url and '/performance?' in url:
        # Reset modal flag when successfully navigated to performance page
        cityline_modal_handled = False
        # Play sound when entering performance page
        if not cityline_dict["played_sound_ticket"]:
            if config_dict["advanced"]["play_sound"]["ticket"]:
                play_sound_while_ordering(config_dict)
        cityline_dict["played_sound_ticket"] = True

        # Integrated performance page processing (area + ticket number + next button)
        if not cityline_performance_processed:
            if config_dict["area_auto_select"]["enable"]:
                is_area_processed = await nodriver_cityline_performance(tab, config_dict)
                if is_area_processed:
                    cityline_performance_processed = True
    elif 'venue.cityline.com' not in url:
        # Reset flag when leaving venue.cityline.com domain
        cityline_performance_processed = False
        cityline_dict["played_sound_ticket"] = False
    else:
        cityline_dict["played_sound_ticket"] = False

    # Shopping basket page (success detection)
    # https://venue.cityline.com/utsvInternet/internet/shoppingBasket
    if 'venue.cityline.com' in url and '/shoppingBasket' in url:
        await nodriver_cityline_check_shopping_basket(tab, config_dict)
    else:
        # Reset order sound flag when not on shopping basket page (allow replay for next purchase)
        cityline_dict["played_sound_order"] = False

    return tab


async def nodriver_facebook_main(tab, config_dict):
    facebook_account = config_dict["accounts"]["facebook_account"].strip()
    facebook_password = config_dict["accounts"]["facebook_password"].strip()
    if len(facebook_account) > 4:
        await nodriver_facebook_login(tab, facebook_account, facebook_password)

# ====================================================================================
# Kham Platform (kham.com.tw / ticket.com.tw / udnfunlife.com)
# ====================================================================================

async def nodriver_kham_login(tab, account, password, ocr=None):
    """
    Kham platform login with OCR captcha support
    Reference: chrome_tixcraft.py kham_login (line 5492-5540)
    """
    import base64
    import time

    ret = False
    show_debug_message = True

    # Find email/account input
    el_email = None
    try:
        el_email = await tab.query_selector('#ACCOUNT')
    except Exception as exc:
        if show_debug_message:
            print("Find #ACCOUNT fail:", exc)

    # Input account
    is_email_sent = False
    if el_email:
        try:
            inputed_text = await tab.evaluate('document.querySelector("#ACCOUNT").value')
            if not inputed_text or len(inputed_text) == 0:
                await el_email.send_keys(account)
                is_email_sent = True
            else:
                if inputed_text == account:
                    is_email_sent = True
        except Exception as exc:
            if show_debug_message:
                print("Input account fail:", exc)

    # Find password input
    el_pass = None
    if is_email_sent:
        try:
            el_pass = await tab.query_selector('table.login > tbody > tr > td > input[type="password"]')
        except Exception as exc:
            if show_debug_message:
                print("Find password input fail:", exc)

    # Input password
    is_password_sent = False
    if el_pass:
        try:
            inputed_text = await tab.evaluate('document.querySelector("table.login > tbody > tr > td > input[type=password]").value')
            if not inputed_text or len(inputed_text) == 0:
                await el_pass.click()
                if len(password) > 0:
                    await el_pass.send_keys(password)
                    is_password_sent = True
        except Exception as exc:
            if show_debug_message:
                print("Input password fail:", exc)

    # Handle captcha with OCR
    is_captcha_sent = False
    if is_password_sent and ocr:
        try:
            if show_debug_message:
                print("[KHAM LOGIN] Starting OCR captcha processing...")

            ocr_start_time = time.time()

            # Get captcha image using canvas
            img_base64 = None
            try:
                form_verifyCode_base64 = await tab.evaluate('''
                    (function() {
                        var canvas = document.createElement('canvas');
                        var context = canvas.getContext('2d');
                        var img = document.getElementById('chk_pic');
                        if (img != null) {
                            canvas.height = img.naturalHeight;
                            canvas.width = img.naturalWidth;
                            context.drawImage(img, 0, 0);
                            return canvas.toDataURL();
                        }
                        return null;
                    })();
                ''')

                if form_verifyCode_base64:
                    img_base64 = base64.b64decode(form_verifyCode_base64.split(',')[1])
            except Exception as exc:
                if show_debug_message:
                    print("[KHAM LOGIN] Canvas exception:", str(exc))

            # OCR recognition
            ocr_answer = None
            if img_base64:
                try:
                    ocr_answer = ocr.classification(img_base64)
                    ocr_done_time = time.time()
                    ocr_elapsed_time = ocr_done_time - ocr_start_time
                    if show_debug_message:
                        print(f"[KHAM LOGIN] OCR elapsed time: {ocr_elapsed_time:.3f}s")
                except Exception as exc:
                    if show_debug_message:
                        print("[KHAM LOGIN] OCR classification fail:", exc)

            # Input captcha answer
            if ocr_answer:
                ocr_answer = ocr_answer.strip()
                if show_debug_message:
                    print(f"[KHAM LOGIN] OCR answer: {ocr_answer}")

                if len(ocr_answer) == 4:
                    try:
                        # Find captcha input field
                        el_captcha = await tab.query_selector('#CHK')
                        if el_captcha:
                            await el_captcha.click()
                            await el_captcha.send_keys(ocr_answer)
                            is_captcha_sent = True
                            if show_debug_message:
                                print("[KHAM LOGIN] Captcha filled successfully")
                    except Exception as exc:
                        if show_debug_message:
                            print("[KHAM LOGIN] Fill captcha fail:", exc)
                else:
                    if show_debug_message:
                        print(f"[KHAM LOGIN] Invalid captcha length: {len(ocr_answer)}, expected 4")
            else:
                if show_debug_message:
                    print("[KHAM LOGIN] OCR answer is None")

        except Exception as exc:
            if show_debug_message:
                print("[KHAM LOGIN] Captcha processing exception:", exc)

    # Click login button
    if is_password_sent:
        try:
            # Wait a bit for captcha to be filled
            if is_captcha_sent:
                await tab.sleep(0.3)

            el_btn = await tab.query_selector('div.memberContent > p > a > button.red')
            if el_btn:
                await el_btn.click()
                ret = True
                if show_debug_message:
                    print("[KHAM LOGIN] Login button clicked")
        except Exception as exc:
            if show_debug_message:
                print("Click login button fail:", exc)

    return ret

async def nodriver_kham_go_buy_redirect(tab, domain_name):
    """
    Click the "Go Buy" button on product page
    Reference: chrome_tixcraft.py kham_go_buy_redirect (line 8449-8461)
    """
    is_button_clicked = False

    if 'kham.com' in domain_name:
        my_css_selector = 'div#content > p > a > button[onclick].red'
    elif 'ticket.com' in domain_name:
        my_css_selector = 'div.row > div > a.btn.btn-order.btn-block'
    elif 'udnfunlife.com' in domain_name:
        # UDN fast buy button uses nexturl attribute instead of onclick
        # Navigate directly to the nexturl for quick purchase (UTK0222_02)
        try:
            next_url = await tab.evaluate('''
                (() => {
                    const btn = document.querySelector('button[name="fastBuy"]');
                    if (btn) {
                        const nexturl = btn.getAttribute('nexturl');
                        if (nexturl) {
                            // Convert relative URL to absolute
                            if (nexturl.startsWith('../')) {
                                return window.location.origin + '/application/' + nexturl.replace('../', '');
                            } else if (nexturl.startsWith('/')) {
                                return window.location.origin + nexturl;
                            }
                            return nexturl;
                        }
                    }
                    return null;
                })()
            ''')

            if next_url:
                await tab.get(next_url)
                return True
        except:
            pass

        # Fallback to traditional buy button if fast buy not available
        my_css_selector = '#buttonBuy'
    else:
        return False

    try:
        el_btn = await tab.query_selector(my_css_selector)
        if el_btn:
            await el_btn.click()
            is_button_clicked = True
    except Exception as exc:
        pass

    return is_button_clicked

async def nodriver_kham_check_realname_dialog(tab, config_dict):
    """
    Check and handle realname notification dialog
    Reference: chrome_tixcraft.py kham_check_realname_dialog (line 9592-9621)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_realname_dialog_found = False

    try:
        el_message_text = await tab.evaluate('''
            (function() {
                const el = document.querySelector('div.ui-dialog > div#dialog-message.ui-dialog-content');
                return el ? el.textContent : null;
            })();
        ''')

        if el_message_text:
            if show_debug_message:
                print("Dialog message:", el_message_text)

            # Check if it's realname notification
            if "個人實名制入場" in el_message_text or "實名制" in el_message_text:
                if show_debug_message:
                    print("Found realname dialog, clicking OK button...")

                # Click OK button using JavaScript for reliable jQuery UI event triggering
                click_result = await tab.evaluate('''
                    (function() {
                        const btn = document.querySelector('div.ui-dialog-buttonset > button.ui-button');
                        if (btn) {
                            btn.click();
                            return true;
                        }
                        return false;
                    })();
                ''')

                if click_result:
                    is_realname_dialog_found = True

                    # Wait for dialog to close (jQuery UI dialog animation)
                    await tab.sleep(0.5)

                    # Verify dialog is closed to prevent infinite loop
                    try:
                        for _ in range(10):
                            dialog_visible = await tab.evaluate('''
                                (function() {
                                    const dialog = document.querySelector('div.ui-dialog');
                                    if (!dialog) return false;
                                    const style = window.getComputedStyle(dialog);
                                    return style.display !== 'none';
                                })();
                            ''')
                            if not dialog_visible:
                                break
                            await tab.sleep(0.1)
                    except:
                        pass
    except Exception as exc:
        if show_debug_message:
            print("Check realname dialog exception:", exc)

    return is_realname_dialog_found

async def nodriver_kham_allow_not_adjacent_seat(tab, config_dict):
    """
    Check the "allow not adjacent seat" checkbox
    Reference: chrome_tixcraft.py kham_allow_not_adjacent_seat (line 9623-9642)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    agree_checkbox = None
    try:
        agree_checkbox = await tab.query_selector('table.eventTABLE > tbody > tr > td > input[type="checkbox"]')
    except Exception as exc:
        if show_debug_message:
            print("Find kham adjacent_seat checkbox exception:", exc)

    is_finish_checkbox_click = await nodriver_force_check_checkbox(tab, agree_checkbox)

    return is_finish_checkbox_click

async def nodriver_kham_switch_to_auto_seat(tab):
    """
    Switch to auto seat selection mode
    Reference: chrome_tixcraft.py kham_switch_to_auto_seat (line 9230-9266)
    """
    is_switch_to_auto_seat = False

    try:
        # Check if auto seat radio button exists
        btn_switch_result = await tab.evaluate('''
            (function() {
                const btn = document.querySelector('#BUY_TYPE_2');
                if (!btn) return { exists: false };

                const buttonClass = btn.getAttribute('class') || '';
                return {
                    exists: true,
                    isActive: buttonClass === 'red',
                    button: btn
                };
            })();
        ''')

        if btn_switch_result and btn_switch_result.get('exists'):
            if btn_switch_result.get('isActive'):
                is_switch_to_auto_seat = True
            else:
                # Click to switch to auto seat
                el_btn = await tab.query_selector('#BUY_TYPE_2')
                if el_btn:
                    await el_btn.click()
                    is_switch_to_auto_seat = True
    except Exception as exc:
        pass

    return is_switch_to_auto_seat

async def nodriver_kham_check_captcha_text_error(tab, config_dict):
    """
    Check captcha error message dialog
    Reference: chrome_tixcraft.py kham_check_captcha_text_error (line 9565-9590)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_reset_password_text = False

    try:
        el_message_text = await tab.evaluate('''
            (function() {
                const el = document.querySelector('div.ui-dialog > div#dialog-message.ui-dialog-content');
                return el ? el.textContent : null;
            })();
        ''')

        if el_message_text:
            if show_debug_message:
                print("Dialog message:", el_message_text)

            if "驗證碼輸入錯誤" in el_message_text or "【驗證碼】輸入錯誤" in el_message_text:
                # Click OK button to dismiss dialog
                el_btn = await tab.query_selector('div.ui-dialog-buttonset > button.ui-button')
                if el_btn:
                    await el_btn.click()
                    is_reset_password_text = True

                # Clear captcha input and wait for re-input
                await nodriver_kham_keyin_captcha_code(tab, "")
    except Exception as exc:
        if show_debug_message:
            print("Check captcha error exception:", exc)

    return is_reset_password_text

async def nodriver_kham_product(tab, domain_name, config_dict):
    """
    Product page processing - call date auto select
    Reference: chrome_tixcraft.py kham_product (line 8646-8660)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_date_assign_by_bot = await nodriver_kham_date_auto_select(tab, domain_name, config_dict)

    if not is_date_assign_by_bot:
        # Click "not on sale now" dialog button if exists
        try:
            el_btn = await tab.query_selector('div.ui-dialog-buttonset > button.ui-button')
            if el_btn:
                await el_btn.click()
        except:
            pass

    return is_date_assign_by_bot

async def nodriver_kham_date_auto_select(tab, domain_name, config_dict):
    """
    Date auto selection with keyword matching and mode fallback
    Reference: chrome_tixcraft.py hkam_date_auto_select (line 8463-8644)
    Supports: kham.com.tw, ticket.com.tw, udnfunlife.com
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Wait for page to load
    await tab.sleep(0.6)

    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    auto_reload_coming_soon_page_enable = config_dict["tixcraft"]["auto_reload_coming_soon_page"]

    # Feature 003: Safe access for conditional fallback switch
    date_auto_fallback = config_dict.get('date_auto_fallback', False)

    if show_debug_message:
        print("date_keyword:", date_keyword)
        print("auto_reload_coming_soon_page_enable:", auto_reload_coming_soon_page_enable)

    # Get all date rows using query_selector_all (similar to TixCraft)
    selector = "table.eventTABLE > tbody > tr"
    if 'ticket.com' in domain_name:
        selector = "div.description > table.table.table-striped.itable > tbody > tr"
    elif 'udnfunlife.com' in domain_name:
        selector = "div.yd_session-block"

    area_list = None
    try:
        area_list = await tab.query_selector_all(selector)
    except Exception as exc:
        if show_debug_message:
            print(f"query_selector_all error: {exc}")

    # Format area list with keyword filtering
    formated_area_list = []
    formated_area_list_text = []

    if area_list and len(area_list) > 0:
        for row in area_list:
            try:
                row_html = await row.get_html()
                row_text = util.remove_html_tags(row_html)
                row_text = row_text.strip()
            except Exception as exc:
                if show_debug_message:
                    print(f"get_html error: {exc}")
                break

            if not row_text or util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                continue

            # Filter: exclude disabled buttons
            # Issue #188: Allow "尚未開賣" (coming soon) buttons even with CSS disabled class
            if ' disabled">' in row_html:
                if '尚未開賣' not in row_html:
                    continue

            # Filter: check if button exists (for kham/ticket)
            if 'udnfunlife' not in domain_name:
                if '<button' in row_html:
                    # Issue #188: Support "尚未開賣" (coming soon) button for ERA TICKET
                    valid_button_texts = ['立即訂購', '點此購票', '尚未開賣']
                    if not any(text in row_html for text in valid_button_texts):
                        continue
                else:
                    continue  # No button, skip

            # Filter: check if tickets available (udn)
            if 'udnfunlife' in domain_name:
                if '前往購票' not in row_html:
                    continue

            # Filter: check price availability (for kham/ticket)
            # Reference: chrome_tixcraft.py line 8558-8568
            if 'udnfunlife' not in domain_name:
                if '<td' in row_html:
                    disabled_marker = '<del>' if 'ticket.com' in domain_name else '"lightblue"'
                    # Split by <td to get each column
                    td_array = row_html.split('<td')
                    if len(td_array) > 3:
                        # 4th td is the price column (date, location, price, order)
                        td_target = td_array[3]
                        # Split prices by Chinese comma
                        price_array = td_target.split('、')
                        is_all_price_disabled = True
                        for each_price in price_array:
                            if disabled_marker not in each_price:
                                is_all_price_disabled = False
                                break
                        if is_all_price_disabled:
                            if show_debug_message:
                                print(f"Skipping row: all prices are disabled")
                            continue

            formated_area_list.append(row)
            formated_area_list_text.append(row_text)

    if show_debug_message:
        print(f"Valid date rows count: {len(formated_area_list)}")
        if formated_area_list and len(formated_area_list) > 0:
            # Clean up whitespace for display
            import re
            display_text = re.sub(r'\s+', ' ', formated_area_list_text[0]).strip()
            print(f"First row text sample: {display_text[:80]}")

    # Apply keyword matching (similar to TixCraft)
    matched_blocks = None
    if formated_area_list and len(formated_area_list) > 0:
        if len(date_keyword) == 0:
            matched_blocks = formated_area_list
            if show_debug_message:
                print(f"No keyword specified, using all {len(matched_blocks)} rows")
        else:
            # Match by keyword
            matched_blocks = []
            try:
                import json
                import re
                keyword_array = json.loads("[" + date_keyword + "]")
                if show_debug_message:
                    print(f"date_keyword array: {keyword_array}")

                # Feature 003: Early return pattern - iterate keywords in priority order
                target_row_found = False
                keyword_matched_index = -1

                for keyword_index, keyword_item_set in enumerate(keyword_array):
                    if show_debug_message:
                        print(f"[KHAM DATE KEYWORD] Checking keyword #{keyword_index + 1}: {keyword_item_set}")

                    # Check all rows for this keyword
                    for i, row_text in enumerate(formated_area_list_text):
                        normalized_row_text = re.sub(r'\s+', ' ', row_text)
                        is_match = False

                        if isinstance(keyword_item_set, str):
                            # OR logic: single keyword
                            normalized_keyword = re.sub(r'\s+', ' ', keyword_item_set)
                            is_match = normalized_keyword in normalized_row_text
                        elif isinstance(keyword_item_set, list):
                            # AND logic: all keywords must match
                            normalized_keywords = [re.sub(r'\s+', ' ', kw) for kw in keyword_item_set]
                            match_results = [kw in normalized_row_text for kw in normalized_keywords]
                            is_match = all(match_results)

                        if is_match:
                            # Keyword matched - IMMEDIATELY select and stop
                            matched_blocks = [formated_area_list[i]]
                            target_row_found = True
                            keyword_matched_index = keyword_index
                            if show_debug_message:
                                print(f"[KHAM DATE KEYWORD] Keyword #{keyword_index + 1} matched: '{keyword_item_set}'")
                                # Clean up whitespace for display
                                display_row_text = re.sub(r'\s+', ' ', row_text).strip()
                                print(f"[KHAM DATE SELECT] Selected date: {display_row_text[:80]} (keyword match)")
                            break

                    if target_row_found:
                        # EARLY RETURN: Stop checking further keywords
                        break

                # All keywords failed log
                if not target_row_found and show_debug_message:
                    print(f"[KHAM DATE KEYWORD] All keywords failed to match")

            except Exception as e:
                if show_debug_message:
                    print(f"keyword parsing error: {e}")
                matched_blocks = formated_area_list

            if show_debug_message:
                if matched_blocks:
                    print("After keyword match, found count:", len(matched_blocks))
                else:
                    print("No matches found for keyword:", date_keyword)
    else:
        if show_debug_message:
            print("No valid date rows found")

    # Feature 003: Conditional fallback based on date_auto_fallback switch
    if matched_blocks is not None and len(matched_blocks) == 0 and len(date_keyword) > 0:
        if formated_area_list and len(formated_area_list) > 0:
            if date_auto_fallback:
                # Fallback enabled - use auto_select_mode
                if show_debug_message:
                    print(f"[KHAM DATE FALLBACK] date_auto_fallback=true, triggering auto fallback")
                    print(f"[KHAM DATE FALLBACK] Selecting available date based on date_select_order='{auto_select_mode}'")
                matched_blocks = formated_area_list
            else:
                # Fallback disabled - strict mode (no selection, will reload)
                if show_debug_message:
                    print(f"[KHAM DATE FALLBACK] date_auto_fallback=false, fallback is disabled")
                    print(f"[KHAM DATE SELECT] No date selected, will reload page and retry")
                return False  # Return False to trigger reload logic in caller

    # Handle case when formated_area_list is empty or None (all options excluded)
    if formated_area_list is None or len(formated_area_list) == 0:
        if show_debug_message:
            print(f"[KHAM DATE FALLBACK] No available options after exclusion")
        return False

    # Get target date using mode
    target_row = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

    if show_debug_message:
        if target_row:
            # Get text for debug
            try:
                target_row_html = await target_row.get_html()
                target_row_text = util.remove_html_tags(target_row_html)
                # Clean up whitespace for display
                import re
                display_row_text = re.sub(r'\s+', ' ', target_row_text).strip()
                print(f"Target row selected (mode: {auto_select_mode}): {display_row_text[:80]}")
            except:
                print(f"Target row selected (mode: {auto_select_mode})")
        else:
            print(f"No target row selected from {len(matched_blocks) if matched_blocks else 0} matched blocks")

    is_date_assign_by_bot = False
    is_coming_soon = False

    if target_row:
        # Issue #188: Check if target is "coming soon" button before clicking
        try:
            target_row_html = await target_row.get_html()
            if '尚未開賣' in target_row_html:
                is_coming_soon = True
                if show_debug_message:
                    print("[TICKET.COM] Coming soon button detected, skip clicking")
        except:
            pass

        if not is_coming_soon:
            # Click the button in target row (similar to TixCraft)
            try:
                button_selector = 'button'
                if 'udnfunlife.com' in domain_name:
                    button_selector = 'div.goNext'

                btn = await target_row.query_selector(button_selector)
                if btn:
                    await btn.click()
                    is_date_assign_by_bot = True
                    if show_debug_message:
                        print("Date buy button clicked successfully")
            except Exception as exc:
                if show_debug_message:
                    print(f"Click button error: {exc}")

    # Auto reload if: no target found OR target is coming soon button
    if not is_date_assign_by_bot and auto_reload_coming_soon_page_enable:
        if is_coming_soon or formated_area_list is None or len(formated_area_list) == 0:
            try:
                if show_debug_message:
                    if is_coming_soon:
                        print("[TICKET.COM] Waiting for sale time, will reload after delay...")
                    else:
                        print("Date list empty, will auto reload after delay...")

                # Wait before reload (use config interval)
                reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 0.0)
                if reload_interval > 0:
                    await tab.sleep(reload_interval)
                else:
                    await tab.sleep(1.0)  # Default 1 second delay

                await tab.reload()
                await tab.sleep(0.5)  # Wait for page to start loading

                if show_debug_message:
                    print("Page reloaded, waiting for content...")
            except Exception as exc:
                if show_debug_message:
                    print("Auto reload exception:", exc)

    return is_date_assign_by_bot

async def nodriver_kham_keyin_captcha_code(tab, answer="", auto_submit=False):
    """
    Input captcha code manually or auto-submit
    Reference: chrome_tixcraft.py kham_keyin_captcha_code (line 9359-9424)
    """
    is_verifyCode_editing = False

    # Find captcha input with multiple selectors
    form_verifyCode = None
    selectors = [
        'input#CHK',
        '#ctl00_ContentPlaceHolder1_CHK',
        'input[value="驗證碼"]',
        'input[placeholder="驗證碼"]',
        'input[placeholder="請輸入圖片上符號"]',
        'input[type="text"][maxlength="4"]'
    ]

    for selector in selectors:
        try:
            form_verifyCode = await tab.query_selector(selector)
            if form_verifyCode:
                break
        except:
            continue

    is_start_to_input_answer = False
    if form_verifyCode:
        if len(answer) > 0:
            # Check current input value
            try:
                inputed_value = await tab.evaluate(f'''
                    (function() {{
                        const input = document.querySelector('{selectors[0]}') ||
                                    document.querySelector('{selectors[1]}') ||
                                    document.querySelector('{selectors[2]}') ||
                                    document.querySelector('{selectors[3]}') ||
                                    document.querySelector('{selectors[4]}') ||
                                    document.querySelector('{selectors[5]}');
                        return input ? input.value : null;
                    }})();
                ''')

                if inputed_value is None:
                    inputed_value = ""

                # Clear if placeholder text
                if inputed_value == "驗證碼":
                    try:
                        await form_verifyCode.apply('function(el) { el.value = ""; }')
                    except:
                        pass
                else:
                    if len(inputed_value) > 0:
                        print("Captcha text already inputed:", inputed_value, "target answer:", answer)
                        is_verifyCode_editing = True
                    else:
                        is_start_to_input_answer = True
            except Exception as exc:
                print("Check verify code value fail:", exc)
        else:
            # Clear input
            try:
                await form_verifyCode.apply('function(el) { el.value = ""; }')
            except:
                pass

    if is_start_to_input_answer:
        try:
            await form_verifyCode.click()
            await form_verifyCode.apply('function(el) { el.value = ""; }')
            await form_verifyCode.send_keys(answer)
        except Exception as exc:
            print("Send keys OCR answer fail:", answer, exc)

    # Auto submit if enabled (for away_from_keyboard mode)
    if auto_submit:
        try:
            # Find and click submit button using NoDriver CDP
            # Year Ticket (ticket.com.tw): AddShopingCart button
            print("[AUTO SUBMIT] Searching for submit button...")
            submit_button = await tab.query_selector('input[id$="AddShopingCart"]')

            if submit_button:
                print("[AUTO SUBMIT] Submit button found, checking if enabled...")
                # Check if button is enabled
                is_enabled = await submit_button.apply('function(el) { return !el.disabled; }')

                if is_enabled:
                    print("[AUTO SUBMIT] Button enabled, scrolling into view...")
                    # Scroll button into view first (important for CDP click)
                    try:
                        await submit_button.scroll_into_view()
                        await tab.sleep(0.3)
                    except:
                        pass

                    print("[AUTO SUBMIT] Clicking submit button using CDP native click...")
                    # Use NoDriver CDP native click
                    await submit_button.click()
                    print("[AUTO SUBMIT] Submit button clicked successfully!")
                else:
                    print("[AUTO SUBMIT] Submit button is disabled")
            else:
                print("[AUTO SUBMIT] Submit button not found (selector: input[id$=\"AddShopingCart\"])")
        except Exception as exc:
            print(f"[AUTO SUBMIT] Error: {exc}")
            import traceback
            traceback.print_exc()

    return is_verifyCode_editing

async def nodriver_kham_area_auto_select(tab, domain_name, config_dict, area_keyword_item):
    """
    Area/ticket type auto selection with table and dropdown support
    Reference: chrome_tixcraft.py kham_area_auto_select (line 8662-8925)
    """
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False, False, False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]

    # Feature 003: Safe access for conditional fallback switch
    area_auto_fallback = config_dict.get('area_auto_fallback', False)

    # NOTE: area_keyword_item is already a SINGLE keyword string from upper layer JSON parsing (line 13180)
    # Upper layer at line 13180: area_keyword_array = json.loads("[" + area_keyword + "]")
    # Then loops through and passes each keyword individually to this function (line 13185-13187)
    # Therefore, we should NOT split by comma again here - just clean the quotes
    if area_keyword_item and len(area_keyword_item) > 0:
        try:
            area_keyword_clean = area_keyword_item.strip()
            if area_keyword_clean.startswith('"') and area_keyword_clean.endswith('"'):
                area_keyword_clean = area_keyword_clean[1:-1]

            # Use the cleaned keyword directly (no comma split)
            area_keyword_item = area_keyword_clean
        except Exception as e:
            if show_debug_message:
                print(f"[KHAM AREA] Keyword parse error: {e}")

    is_price_assign_by_bot = False
    is_need_refresh = False
    is_keyword_matched = False  # Track whether keyword actually matched (vs fallback)

    # Try dropdown mode first using CDP DOM operations
    # Supports both ibon (id="PRICE") and ticket.com.tw (id="ctl00_ContentPlaceHolder1_PRICE")
    price_select = None
    try:
        # Try standard id="PRICE" first (ibon)
        price_select = await tab.query_selector('select#PRICE')
        if not price_select:
            # Try ticket.com.tw selector
            selects = await tab.query_selector_all('select[id$="_PRICE"]')
            if selects and len(selects) > 0:
                price_select = selects[0]
    except Exception as exc:
        if show_debug_message:
            print(f"Error finding PRICE select: {exc}")

    # Handle dropdown mode using CDP
    if price_select:
        try:
            # Get all option elements using CDP
            option_elements = await price_select.query_selector_all('option:not([value="-1"])')

            if show_debug_message:
                print(f"Found dropdown with {len(option_elements)} options")

            # Extract option data using CDP
            options_data = []
            for i, opt_elem in enumerate(option_elements):
                try:
                    # Get text content
                    opt_text = await opt_elem.get_html()
                    opt_text = util.remove_html_tags(opt_text).strip()

                    # Get value attribute using JavaScript (more reliable)
                    opt_value = await opt_elem.apply('function(el) { return el.value; }')

                    # Check if disabled
                    is_disabled = await opt_elem.apply('function(el) { return el.disabled; }')

                    if opt_text and not is_disabled:
                        options_data.append({
                            'index': i,
                            'text': opt_text,
                            'value': opt_value,
                            'element': opt_elem
                        })
                except Exception as exc:
                    if show_debug_message:
                        print(f"Error processing option {i}: {exc}")

            # Feature 003: Filter by keyword with early return pattern
            matched_options = []
            available_options = []  # Track all non-excluded options for fallback

            for opt in options_data:
                option_text = opt['text']

                # Apply exclude keyword filter first
                if util.reset_row_text_if_match_keyword_exclude(config_dict, option_text):
                    if show_debug_message:
                        print(f"[KHAM AREA] Option excluded: '{option_text}'")
                    continue

                # Track available options for fallback
                available_options.append(opt)

                # Apply positive keyword matching with early return
                if len(area_keyword_item) > 0:
                    area_keyword_array = area_keyword_item.split(' ')
                    row_text = util.format_keyword_string(option_text)
                    is_match = True
                    for keyword in area_keyword_array:
                        formatted_keyword = util.format_keyword_string(keyword)
                        if formatted_keyword not in row_text:
                            is_match = False
                            break
                    if is_match:
                        # EARLY RETURN: First match found
                        matched_options.append(opt)
                        is_keyword_matched = True  # True keyword match (not fallback)
                        if show_debug_message:
                            print(f"[KHAM AREA KEYWORD] Keyword matched (dropdown): '{option_text}'")
                        break  # Stop checking further options
                else:
                    # No positive keyword - match all (except excluded)
                    matched_options.append(opt)
                    if show_debug_message:
                        print(f"[KHAM AREA SELECT] No keyword filter (dropdown): '{option_text}'")

            # Feature 003: Conditional fallback logic
            if len(matched_options) == 0 and len(area_keyword_item) > 0:
                if len(available_options) > 0:
                    if area_auto_fallback:
                        # Fallback enabled - use auto_select_mode
                        if show_debug_message:
                            print(f"[KHAM AREA FALLBACK] area_auto_fallback=true, triggering auto fallback (dropdown)")
                            print(f"[KHAM AREA FALLBACK] Selecting from {len(available_options)} available options using mode='{auto_select_mode}'")
                        matched_options = available_options
                    else:
                        # Fallback disabled - strict mode (no selection, will reload)
                        if show_debug_message:
                            print(f"[KHAM AREA FALLBACK] area_auto_fallback=false, fallback is disabled (dropdown)")
                            print(f"[KHAM AREA SELECT] No area selected, will reload page and retry")
                        return False, False, False  # Return to trigger reload logic
                else:
                    # No available options (all excluded)
                    if show_debug_message:
                        print(f"[KHAM AREA FALLBACK] No available options after exclusion (dropdown)")
                    return False, False, False

            # Select target option by simulating user interaction
            if matched_options:
                target_option = matched_options[0]  # Take first match
                target_value = target_option['value']
                target_text = target_option['text']

                if show_debug_message:
                    print(f"Selecting option: {target_text} (value: {target_value})")

                # Step 1: Click Bootstrap Select button using CDP + JavaScript
                try:
                    # First, check if Bootstrap Select button exists
                    bs_button = await tab.query_selector('button.dropdown-toggle[data-id$="_PRICE"]')

                    if bs_button:
                        if show_debug_message:
                            print("Found Bootstrap Select button, clicking to open dropdown...")

                        # Use JavaScript to click the button (avoid CDP click error)
                        await tab.evaluate('''
                            (function() {
                                const button = document.querySelector('button.dropdown-toggle[data-id$="_PRICE"]');
                                if (button) {
                                    button.click();
                                }
                            })();
                        ''')

                        # Wait for dropdown to open
                        await tab.sleep(0.5)

                        if show_debug_message:
                            print(f"Dropdown opened, looking for option: {target_text}")

                        # Step 2: Use CDP to find all <a> elements in the dropdown
                        menu_items = await tab.query_selector_all('ul.dropdown-menu.inner li[data-original-index] a')

                        if show_debug_message:
                            print(f"Found {len(menu_items)} menu items via CDP")

                        # Check each menu item
                        click_success = False
                        for link in menu_items:
                            try:
                                # Get the text from span.text using CDP
                                text_span = await link.query_selector('span.text')
                                if text_span:
                                    # Get text content
                                    span_html = await text_span.get_html()
                                    option_text = util.remove_html_tags(span_html).strip()

                                    if show_debug_message:
                                        print(f"  Checking option: '{option_text}'")

                                    if option_text == target_text:
                                        if show_debug_message:
                                            print(f"  Match found! Clicking...")

                                        # Use JavaScript to click the link (avoid CDP click error)
                                        await link.apply('function(el) { el.click(); }')
                                        click_success = True
                                        break
                            except Exception as exc:
                                if show_debug_message:
                                    print(f"  Error checking menu item: {exc}")

                        if click_success:
                            is_price_assign_by_bot = True
                            if show_debug_message:
                                print(f"Successfully clicked Bootstrap Select option: {target_text}")
                        else:
                            if show_debug_message:
                                print(f"Failed to find/click option: {target_text}")

                    else:
                        # No Bootstrap Select button found, try direct select value setting
                        if show_debug_message:
                            print("Bootstrap Select button not found, using direct value setting...")

                        # Use CDP to directly set select value (avoid parameter serialization)
                        select_result = False
                        try:
                            select_elem = await tab.query_selector('select#PRICE, select[id$="_PRICE"]')
                            if select_elem:
                                # Set value directly using CDP
                                await select_elem.apply(f'function(el) {{ el.value = "{target_value}"; }}')
                                # Trigger change event
                                await tab.evaluate('''
                                    (function() {
                                        const select = document.querySelector('select#PRICE, select[id$="_PRICE"]');
                                        if (select) {
                                            select.dispatchEvent(new Event('change', { bubbles: true }));
                                        }
                                    })();
                                ''')
                                select_result = True
                        except Exception as fallback_exc:
                            if show_debug_message:
                                print(f"Direct select value setting error: {fallback_exc}")

                        is_price_assign_by_bot = select_result

                except Exception as exc:
                    if show_debug_message:
                        print(f"Bootstrap Select interaction error: {exc}")

        except Exception as exc:
            if show_debug_message:
                print(f"Dropdown processing error: {exc}")

    else:
        # Handle table mode - use DOM element operations (similar to date_auto_select)
        # Reference: chrome_tixcraft.py kham_area_auto_select (line 8781-8925)

        # Determine selector
        selector = "table#salesTable > tbody > tr[class='status_tr']"
        if 'ticket.com.tw' in domain_name:
            selector = "li.main"
        elif 'udnfunlife' in domain_name:
            # UDN UTK0204: table.status > tr.status_tr (verified via MCP)
            # Soldout items have class="status_tr Soldout"
            selector = "table.status > tbody > tr.status_tr"

        # Get all area rows using query_selector_all
        area_list = None
        try:
            area_list = await tab.query_selector_all(selector)
        except Exception as exc:
            if show_debug_message:
                print(f"query_selector_all error: {exc}")

        # Format area list with filtering
        formated_area_list = []
        formated_area_list_text = []

        if area_list and len(area_list) > 0:
            for row in area_list:
                try:
                    row_html = await row.get_html()
                    row_text = util.remove_html_tags(row_html)
                    row_text = row_text.strip()
                except Exception as exc:
                    if show_debug_message:
                        print(f"get_html error: {exc}")
                    break

                if not row_text:
                    continue

                # Filter: check if sold out
                if '售完' in row_text or ' Soldout' in row_html:
                    continue

                # Filter: udn specific check
                if 'udnfunlife' in domain_name:
                    if 'style="color:gray;border:solid 1px gray;cursor:default"' in row_html:
                        continue

                formated_area_list.append(row)
                formated_area_list_text.append(row_text)

        if show_debug_message:
            print(f"Valid area rows count: {len(formated_area_list)}")
            if formated_area_list and len(formated_area_list) > 0:
                # Clean up whitespace for display
                import re
                display_text = re.sub(r'\s+', ' ', formated_area_list_text[0]).strip()
                print(f"First row text sample: {display_text[:60]}")

        # Apply keyword matching
        matched_blocks = None
        if formated_area_list and len(formated_area_list) > 0:
            # Apply exclude keywords first
            filtered_rows = []
            filtered_rows_text = []
            for i, row_text in enumerate(formated_area_list_text):
                if not util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                    filtered_rows.append(formated_area_list[i])
                    filtered_rows_text.append(row_text)

            # Check ticket number availability
            final_rows = []
            final_rows_text = []
            ticket_number = config_dict["ticket_number"]
            for i, row_text in enumerate(filtered_rows_text):
                if 'udnfunlife' not in domain_name:
                    if ticket_number > 1:
                        # Check remaining tickets from last character
                        maybe_count = row_text[-1:] if row_text else ''
                        if maybe_count.isdigit():
                            available_count = int(maybe_count)
                            if available_count < ticket_number:
                                continue
                final_rows.append(filtered_rows[i])
                final_rows_text.append(row_text)

            # Feature 003: Match by keyword with early return pattern
            matched_blocks = []
            if len(area_keyword_item) > 0:
                # Use keyword matching on text, but keep DOM elements
                area_keyword_array = area_keyword_item.split(' ')
                area_found = False

                for i, row_text in enumerate(final_rows_text):
                    formatted_row_text = util.format_keyword_string(row_text)
                    is_match = True
                    for keyword in area_keyword_array:
                        formatted_keyword = util.format_keyword_string(keyword)
                        if formatted_keyword not in formatted_row_text:
                            is_match = False
                            break
                    if is_match:
                        # EARLY RETURN: First match found
                        matched_blocks.append(final_rows[i])
                        area_found = True
                        is_keyword_matched = True  # True keyword match (not fallback)
                        if show_debug_message:
                            # Clean up whitespace for display
                            import re
                            display_row_text = re.sub(r'\s+', ' ', row_text).strip()
                            print(f"[KHAM AREA KEYWORD] Keyword matched (table): {display_row_text[:60]}")
                        break  # Stop checking further rows

                # All keywords failed log
                if not area_found and show_debug_message:
                    print(f"[KHAM AREA KEYWORD] All keywords failed to match (table)")
            else:
                # No keyword filter - use all available rows
                matched_blocks = final_rows
                if show_debug_message:
                    print(f"[KHAM AREA SELECT] No keyword filter (table): using {len(final_rows)} available rows")

            if show_debug_message and matched_blocks:
                print("Matched area blocks:", len(matched_blocks))

            # Feature 003: Conditional fallback logic (Table Mode)
            if len(matched_blocks) == 0 and len(area_keyword_item) > 0:
                if len(final_rows) > 0:
                    if area_auto_fallback:
                        # Fallback enabled - use auto_select_mode
                        if show_debug_message:
                            print(f"[KHAM AREA FALLBACK] area_auto_fallback=true, triggering auto fallback (table)")
                            print(f"[KHAM AREA FALLBACK] Selecting from {len(final_rows)} available rows using mode='{auto_select_mode}'")
                        matched_blocks = final_rows
                    else:
                        # Fallback disabled - strict mode (no selection, will reload)
                        if show_debug_message:
                            print(f"[KHAM AREA FALLBACK] area_auto_fallback=false, fallback is disabled (table)")
                            print(f"[KHAM AREA SELECT] No area selected, will reload page and retry")
                        return False, False, False  # Return to trigger reload logic
                else:
                    # No available rows (all filtered out or sold out)
                    if show_debug_message:
                        print(f"[KHAM AREA FALLBACK] No available rows after filtering (table)")
                    return False, False, False

        # Get target and click
        target_row = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)

        if show_debug_message:
            if target_row:
                print(f"Target area row selected (mode: {auto_select_mode})")
            else:
                print(f"No target area row selected from {len(matched_blocks) if matched_blocks else 0} matched blocks")

        if target_row:
            # Click target row directly (like Chrome version line 8891)
            # For Kham, the entire row is clickable
            try:
                if show_debug_message:
                    print(f"Clicking target area row...")
                await target_row.click()
                is_price_assign_by_bot = True
                if show_debug_message:
                    print("Area row clicked successfully")
            except Exception as exc:
                if show_debug_message:
                    print(f"Click area row error: {exc}")
        else:
            is_need_refresh = True

    return is_need_refresh, is_price_assign_by_bot, is_keyword_matched

async def nodriver_kham_auto_ocr(tab, config_dict, ocr, away_from_keyboard_enable, previous_answer, model_name):
    """
    Auto OCR captcha recognition
    Reference: chrome_tixcraft.py kham_auto_ocr (line 9426-9530)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print("Starting Kham OCR processing...")
        print("away_from_keyboard_enable:", away_from_keyboard_enable)
        print("previous_answer:", previous_answer)

    is_need_redo_ocr = False
    is_form_submitted = False

    ocr_answer = None
    if ocr:
        import time
        ocr_start_time = time.time()

        # Get captcha image using DOMSnapshot (same method as ibon)
        img_base64 = await nodriver_ibon_get_captcha_image_from_shadow_dom(tab, config_dict)

        if img_base64:
            try:
                ocr_answer = ocr.classification(img_base64)
            except Exception as exc:
                if show_debug_message:
                    print("OCR classification error:", exc)

        ocr_done_time = time.time()
        ocr_elapsed_time = ocr_done_time - ocr_start_time
        if show_debug_message:
            print(f"OCR elapsed time: {ocr_elapsed_time:.3f}s")
    else:
        print("OCR engine is None")

    if ocr_answer:
        ocr_answer = ocr_answer.strip()
        print("OCR answer:", ocr_answer)

        if len(ocr_answer) == 4:
            # Valid 4-character answer
            previous_answer = ocr_answer  # Update previous_answer to mark as sent
            who_care_var = await nodriver_kham_keyin_captcha_code(tab, answer=ocr_answer, auto_submit=away_from_keyboard_enable)
        else:
            # Invalid length - retry
            if not away_from_keyboard_enable:
                await nodriver_kham_keyin_captcha_code(tab, "")
            else:
                is_need_redo_ocr = True
                if previous_answer != ocr_answer:
                    previous_answer = ocr_answer
                    print("Click captcha to refresh")
                    # Refresh captcha image
                    try:
                        await tab.evaluate(f'''
                            (function() {{
                                const img = document.querySelector('#chk_pic');
                                if (img) {{
                                    img.src = '/pic.aspx?TYPE={model_name}&ts=' + new Date().getTime();
                                }}
                            }})();
                        ''')
                        await tab.sleep(0.3)
                    except:
                        pass
    else:
        print("OCR answer is None")
        print("previous_answer:", previous_answer)
        if previous_answer is None:
            await nodriver_kham_keyin_captcha_code(tab, "")
        else:
            is_need_redo_ocr = True

    return is_need_redo_ocr, previous_answer, is_form_submitted

async def nodriver_kham_captcha(tab, config_dict, ocr, model_name):
    """
    Captcha main control with retry logic
    Reference: chrome_tixcraft.py kham_captcha (line 9532-9563)
    """
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    away_from_keyboard_enable = config_dict["ocr_captcha"]["force_submit"]
    if not config_dict["ocr_captcha"]["enable"]:
        away_from_keyboard_enable = False

    # PS: need 'auto assign seat' feature to enable away_from_keyboard
    away_from_keyboard_enable = False

    is_captcha_sent = False
    previous_answer = None
    last_url = tab.target.url

    for redo_ocr in range(999):
        is_need_redo_ocr, previous_answer, is_form_submitted = await nodriver_kham_auto_ocr(
            tab, config_dict, ocr, away_from_keyboard_enable, previous_answer, model_name
        )

        # If captcha found and processed, set flag to True
        if previous_answer is not None:
            is_captcha_sent = True

        if is_form_submitted:
            break

        if not away_from_keyboard_enable:
            break

        if not is_need_redo_ocr:
            break

        current_url = tab.target.url
        if current_url != last_url:
            break

    return is_captcha_sent

async def nodriver_kham_performance(tab, config_dict, ocr, domain_name, model_name):
    """
    Performance page processing - integrate area selection, captcha, and ticket number
    Reference: chrome_tixcraft.py kham_performance (line 9307-9356)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_price_assign_by_bot = False
    is_captcha_sent = False

    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()

    if show_debug_message:
        print("area_keyword:", area_keyword)

    is_need_refresh = False

    if len(area_keyword) > 0:
        # Parse JSON array keyword
        area_keyword_array = util.parse_keyword_string_to_array(area_keyword)

        # Feature 003: Enhanced fallback logic with early return
        for keyword_index, area_keyword_item in enumerate(area_keyword_array):
            is_need_refresh, is_price_assign_by_bot, is_keyword_matched = await nodriver_kham_area_auto_select(
                tab, domain_name, config_dict, area_keyword_item
            )

            # Check if this is the last keyword
            is_last_keyword = (keyword_index == len(area_keyword_array) - 1)

            # Case 1: True keyword match - stop trying
            if is_keyword_matched:
                if show_debug_message:
                    print(f"[KHAM PERFORMANCE] Keyword matched: '{area_keyword_item}'")
                break

            # Case 2: Strict mode (area_auto_fallback=false) - only stop if last keyword
            # is_need_refresh=False, is_price_assign_by_bot=False, is_keyword_matched=False
            if not is_need_refresh and not is_price_assign_by_bot:
                if is_last_keyword:
                    # Last keyword failed in strict mode - will reload
                    if show_debug_message:
                        print(f"[KHAM PERFORMANCE] All keywords exhausted, strict mode stops")
                        print(f"[KHAM PERFORMANCE] Will reload page and retry")
                    break
                else:
                    # Not last keyword - continue trying
                    if show_debug_message:
                        print(f"[KHAM PERFORMANCE] Keyword #{keyword_index + 1} failed (strict mode), trying next...")
                    continue

            # Case 3: Fallback selection - continue trying next keyword
            # is_price_assign_by_bot=True, is_keyword_matched=False
            if is_price_assign_by_bot and not is_keyword_matched:
                if show_debug_message:
                    print(f"[KHAM PERFORMANCE] Fallback selection, trying next keyword...")
                # Continue to next keyword

            # Case 4: Refresh needed - continue trying next keyword
            # is_need_refresh=True (other scenarios)
            if is_need_refresh:
                if show_debug_message:
                    print(f"[KHAM PERFORMANCE] Need refresh for keyword: {area_keyword_item}")
                # Continue to next keyword
    else:
        # Empty keyword - match all
        is_need_refresh, is_price_assign_by_bot, is_keyword_matched = await nodriver_kham_area_auto_select(
            tab, domain_name, config_dict, ""
        )

    if is_need_refresh:
        if show_debug_message:
            print("is_need_refresh:", is_need_refresh)
        try:
            await tab.reload()
        except:
            pass

    # udn uses reCaptcha, skip for now
    if 'udnfunlife' not in domain_name:
        is_captcha_sent = await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

    return is_price_assign_by_bot, is_captcha_sent

async def nodriver_kham_main(tab, url, config_dict, ocr):
    """
    Main control flow for Kham platform with URL routing
    Reference: chrome_tixcraft.py kham_main (line 9644-9900)
    """
    # 函數開始時檢查暫停
    if await check_and_handle_pause(config_dict):
        return False

    global kham_dict
    if 'kham_dict' not in globals():
        kham_dict = {}
        kham_dict["is_popup_checkout"] = False
        kham_dict["played_sound_order"] = False
        kham_dict["shown_checkout_message"] = False  # Track if checkout message was shown
        kham_dict["udn_quick_buy_submitted"] = False  # Track if quick buy was submitted

    domain_name = url.split('/')[2]
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Home page handling
    home_url_list = [
        'https://kham.com.tw/',
        'https://kham.com.tw/application/utk01/utk0101_.aspx',
        'https://kham.com.tw/application/utk01/utk0101_03.aspx',
        'https://ticket.com.tw/application/utk01/utk0101_.aspx',
        'https://tickets.udnfunlife.com/application/utk01/utk0101_.aspx'
    ]

    for each_url in home_url_list:
        if each_url == url.lower():
            # Clean popup banners
            try:
                await tab.evaluate('''
                    (function() {
                        const popup = document.querySelector('.popoutBG');
                        if (popup) popup.remove();
                    })();
                ''')
            except:
                pass

            # For UDN login page: execute login first, then redirect after login completes
            # This prevents the infinite redirect loop between login page and event page
            if 'udnfunlife.com' in url.lower():
                udn_account = config_dict["accounts"]["udn_account"]
                udn_password = config_dict["accounts"]["udn_password"].strip()

                if len(udn_account) > 4:
                    # Check if already logged in by looking for logout button or user menu
                    is_logged_in = False
                    try:
                        login_state_raw = await tab.evaluate('''
                            (() => {
                                // Method 1: Check member area login item visibility
                                const memberArea = document.querySelector('.yd_mainNav-member');
                                if (memberArea) {
                                    const subList = memberArea.querySelector('.yd_mainNav-subList');
                                    if (subList) {
                                        const listItems = subList.querySelectorAll('li');
                                        const loginItem = listItems[0];
                                        if (loginItem && window.getComputedStyle(loginItem).display === 'none') {
                                            return { isLoggedIn: true };
                                        }
                                    }
                                }
                                // Method 2: Check for welcome message or user name display
                                const welcomeText = document.body.innerText;
                                if (welcomeText.includes('您好') || welcomeText.includes('登出')) {
                                    return { isLoggedIn: true };
                                }
                                return { isLoggedIn: false };
                            })()
                        ''')
                        login_state = util.parse_nodriver_result(login_state_raw)
                        if isinstance(login_state, dict):
                            is_logged_in = login_state.get('isLoggedIn', False)
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[UDN LOGIN] Login state check error: {exc}")

                    if is_logged_in:
                        if show_debug_message:
                            print("[UDN LOGIN] Already logged in, proceeding to redirect...")
                    else:
                        # Not logged in yet - execute login and DON'T redirect
                        # Let the login process complete first
                        if show_debug_message:
                            print(f"[UDN LOGIN] Not logged in, executing login with account: {udn_account[:3]}***")

                        # Trigger login dialog
                        await tab.evaluate('if(typeof doLoginRWD === "function") doLoginRWD();')
                        await tab.sleep(0.5)

                        # Fill account
                        try:
                            await tab.evaluate(f'''
                                (() => {{
                                    const emailInput = document.getElementById('ID');
                                    if (emailInput && !emailInput.value) {{
                                        emailInput.value = "{udn_account}";
                                        emailInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                    }}
                                }})()
                            ''')
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[UDN LOGIN] Fill account error: {exc}")

                        # Fill password
                        try:
                            await tab.evaluate(f'''
                                (() => {{
                                    const passInput = document.getElementById('password');
                                    if (passInput && !passInput.value) {{
                                        passInput.value = "{udn_password}";
                                        passInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                    }}
                                }})()
                            ''')
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[UDN LOGIN] Fill password error: {exc}")

                        # Click reCAPTCHA checkbox
                        try:
                            recaptcha_clicked = False
                            try:
                                checkboxes = await tab.select_all('.recaptcha-checkbox-border', include_frames=True)
                                if checkboxes and len(checkboxes) > 0:
                                    await checkboxes[0].click()
                                    recaptcha_clicked = True
                                    if show_debug_message:
                                        print("[UDN LOGIN] reCAPTCHA clicked via include_frames")
                            except Exception as e1:
                                if show_debug_message:
                                    print(f"[UDN LOGIN] include_frames method failed: {e1}")

                            if not recaptcha_clicked:
                                try:
                                    recaptcha_pos = await tab.evaluate('''
                                        (() => {
                                            const frame = document.querySelector('iframe[title*="reCAPTCHA"]');
                                            if (frame) {
                                                frame.scrollIntoView({ block: 'center' });
                                                const rect = frame.getBoundingClientRect();
                                                return { x: rect.left + 27, y: rect.top + 30, found: true };
                                            }
                                            return { found: false };
                                        })()
                                    ''')
                                    if isinstance(recaptcha_pos, dict) and recaptcha_pos.get('found'):
                                        x = recaptcha_pos['x']
                                        y = recaptcha_pos['y']
                                        await tab.mouse_click(x, y)
                                        recaptcha_clicked = True
                                        if show_debug_message:
                                            print(f"[UDN LOGIN] reCAPTCHA clicked via mouse_click at ({x}, {y})")
                                except Exception as e2:
                                    if show_debug_message:
                                        print(f"[UDN LOGIN] mouse_click method failed: {e2}")
                        except Exception as exc:
                            if show_debug_message:
                                print(f"[UDN LOGIN] reCAPTCHA click error: {exc}")

                        if show_debug_message:
                            print("[UDN LOGIN] Credentials filled, waiting for reCAPTCHA verification...")

                        # DON'T redirect yet - return and let user complete login
                        # Next iteration will check if logged in and redirect then
                        return tab

            # Redirect to target page after login
            config_homepage = config_dict["homepage"]

            # Check if config_homepage is also a home page URL (skip redirect to avoid loop)
            config_homepage_normalized = config_homepage.lower().rstrip('/') if config_homepage else ""
            is_config_homepage_also_home = any(
                config_homepage_normalized == each.rstrip('/')
                for each in home_url_list
            ) or config_homepage_normalized in [
                'https://kham.com.tw',
                'https://ticket.com.tw',
                'https://tickets.udnfunlife.com'
            ]

            # Redirect only if homepage is different AND not a home page URL
            if config_homepage and not is_config_homepage_also_home and config_homepage.lower() != url.lower():
                if show_debug_message:
                    print(f"[KHAM LOGIN] Redirecting to target: {config_homepage}")
                try:
                    await tab.get(config_homepage)
                    return tab
                except Exception as e:
                    if show_debug_message:
                        print(f"[KHAM LOGIN] Redirect failed: {e}")
            break

    # Check realname dialog
    await nodriver_kham_check_realname_dialog(tab, config_dict)

    # KHAM UTK0205 seat selection page (graphical seat map with ticket type buttons)
    # Reference: ticket.com.tw logic (line 13561) adapted for KHAM
    if "kham.com.tw" in url and 'utk0205' in url.lower():
        if show_debug_message:
            print("Detected KHAM UTK0205 seat selection page")

        is_seat_selection_success = await nodriver_kham_seat_main(tab, config_dict, ocr, domain_name)

        if show_debug_message:
            print(f"KHAM seat selection result: {is_seat_selection_success}")

        # Return to avoid double processing by UTK0202/UTK0205 logic below
        return tab

    # UDN UTK0205 seat selection page (Feature 010: UDN seat auto select)
    # UDN shares the same UTK backend system with KHAM, so we reuse KHAM seat selection logic
    # Reference: research.md - DOM structure and selectors are identical
    if "udnfunlife.com" in url and 'utk0205' in url.lower():
        if show_debug_message:
            print("[UDN SEAT] Detected UDN UTK0205 seat selection page")

        is_seat_selection_success = await nodriver_kham_seat_main(tab, config_dict, ocr, domain_name)

        if show_debug_message:
            print(f"[UDN SEAT] Seat selection result: {is_seat_selection_success}")
            if is_seat_selection_success:
                print("[SUCCESS] UDN seat selection completed")

        # Return to avoid double processing
        return tab

    # Activity Group page (UTK0201_040.aspx?AGID=)
    # This is a special page format for activity groups with realname requirements
    if 'utk0201_040.aspx?agid=' in url.lower():
        if show_debug_message:
            print("Detected KHAM Activity Group page (UTK0201_040)")

        # Check realname dialog
        await nodriver_kham_check_realname_dialog(tab, config_dict)

        # Click buy button
        await nodriver_kham_go_buy_redirect(tab, domain_name)

    # Activity Group Item page (UTK0201_041.aspx?AGID=)
    # This page has "立即訂購" buttons that redirect to UTK0202
    if 'utk0201_041.aspx?agid=' in url.lower():
        if show_debug_message:
            print("Detected KHAM Activity Group Item page (UTK0201_041)")

        # Check realname dialog first
        await nodriver_kham_check_realname_dialog(tab, config_dict)

        # Click "立即訂購" button (redirects to UTK0202)
        try:
            click_result = await tab.evaluate('''
                (function() {
                    // Find all "立即訂購" buttons that redirect to UTK0202
                    const buttons = document.querySelectorAll('button.red[onclick*="UTK0202"]');
                    if (buttons.length > 0) {
                        // Click the first available button
                        buttons[0].click();
                        return buttons.length;
                    }
                    return null;
                })();
            ''')
            if show_debug_message and click_result:
                print(f"Clicked buy button, total buttons: {click_result}")
        except Exception as exc:
            if show_debug_message:
                print(f"Click buy button exception: {exc}")

    # Product page (UTK0201_.aspx?product_id=)
    if 'utk0201_.aspx?product_id=' in url.lower():
        is_event_page = len(url.split('/')) == 6

        if is_event_page:
            # Check realname dialog
            await nodriver_kham_check_realname_dialog(tab, config_dict)

            # Click buy button
            await nodriver_kham_go_buy_redirect(tab, domain_name)
            await tab.sleep(1.0)

            # Check if page changed after clicking buy button
            current_url = tab.target.url
            if 'utk0201_.aspx?product_id=' in current_url.lower():
                # Still on product page - check realname dialog and handle captcha
                await nodriver_kham_check_realname_dialog(tab, config_dict)

                # Handle captcha if enabled
                is_captcha_sent = False
                if config_dict["ocr_captcha"]["enable"]:
                    if show_debug_message:
                        print("Starting captcha processing for purchase page...")

                    model_name = url.split('/')[5] if len(url.split('/')) > 5 else "UTK0201"
                    if len(model_name) > 7:
                        model_name = model_name[:7]

                    is_captcha_sent = await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

                if is_captcha_sent:
                    # Set ticket number
                    ticket_number = str(config_dict["ticket_number"])
                    try:
                        await tab.evaluate(f'''
                            (function() {{
                                const amountInput = document.querySelector('#AMOUNT');
                                if (amountInput && (amountInput.value === '' || amountInput.value === '0')) {{
                                    amountInput.value = '{ticket_number}';
                                    amountInput.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                }}
                            }})();
                        ''')
                    except:
                        pass

                    # Click add to cart
                    try:
                        btn_selector = 'button[onclick="addShoppingCart();return false;"]'
                        el_btn = await tab.query_selector(btn_selector)
                        if el_btn:
                            await el_btn.click()
                        else:
                            # Try alternative selector
                            el_btn = await tab.query_selector('#addcart button.red')
                            if el_btn:
                                await el_btn.click()
                    except:
                        pass

    # Date selection page (UTK0201_00.aspx?product_id=)
    if 'utk0201_00.aspx?product_id=' in url.lower():
        is_event_page = len(url.split('/')) == 6

        if is_event_page and config_dict["date_auto_select"]["enable"]:
            await nodriver_kham_product(tab, domain_name, config_dict)

    # UDN specific handling
    if 'udnfunlife' in domain_name:
        # UDN homepage login (popup dialog with reCAPTCHA)
        # UDN uses a popup login dialog on homepage, not UTK1306 page
        if 'utk01/utk0101_.aspx' in url.lower():
            udn_account = config_dict["accounts"]["udn_account"]
            udn_password = config_dict["accounts"]["udn_password"].strip()
            if len(udn_account) > 4:
                # Check if already logged in
                # Detection method: Check if "登入/註冊" menu item is hidden
                # When logged in: "登入/註冊" is display:none, "登出" is visible
                # When not logged in: "登入/註冊" is visible, "登出" is display:none
                is_logged_in = False
                try:
                    login_state_raw = await tab.evaluate('''
                        (() => {
                            const memberArea = document.querySelector('.yd_mainNav-member');
                            if (!memberArea) return { loginItemHidden: false };
                            const subList = memberArea.querySelector('.yd_mainNav-subList');
                            if (!subList) return { loginItemHidden: false };
                            const listItems = subList.querySelectorAll('li');
                            // First item is "登入/註冊", check if it's hidden
                            const loginItem = listItems[0];
                            const loginItemHidden = loginItem && window.getComputedStyle(loginItem).display === 'none';
                            return { loginItemHidden: loginItemHidden };
                        })()
                    ''')
                    # Use util.parse_nodriver_result to handle nodriver's special return format
                    login_state = util.parse_nodriver_result(login_state_raw)
                    if isinstance(login_state, dict):
                        # User is logged in if "登入/註冊" item is hidden
                        is_logged_in = login_state.get('loginItemHidden', False)
                except Exception as exc:
                    if show_debug_message:
                        print(f"[UDN LOGIN] Login state check error: {exc}")

                if not is_logged_in:
                    if show_debug_message:
                        print(f"[UDN LOGIN] Starting login with account: {udn_account[:3]}***")

                    # Trigger login dialog
                    await tab.evaluate('if(typeof doLoginRWD === "function") doLoginRWD();')
                    await tab.sleep(0.5)

                    # Fill account
                    try:
                        await tab.evaluate(f'''
                            (() => {{
                                const emailInput = document.getElementById('ID');
                                if (emailInput && !emailInput.value) {{
                                    emailInput.value = "{udn_account}";
                                    emailInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                }}
                            }})()
                        ''')
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[UDN LOGIN] Fill account error: {exc}")

                    # Fill password
                    try:
                        await tab.evaluate(f'''
                            (() => {{
                                const passInput = document.getElementById('password');
                                if (passInput && !passInput.value) {{
                                    passInput.value = "{udn_password}";
                                    passInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                }}
                            }})()
                        ''')
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[UDN LOGIN] Fill password error: {exc}")

                    # Click reCAPTCHA checkbox
                    try:
                        recaptcha_clicked = False

                        # Method 1: Use nodriver's include_frames to find checkbox inside iframe
                        try:
                            checkboxes = await tab.select_all('.recaptcha-checkbox-border', include_frames=True)
                            if checkboxes and len(checkboxes) > 0:
                                await checkboxes[0].click()
                                recaptcha_clicked = True
                                if show_debug_message:
                                    print("[UDN LOGIN] reCAPTCHA clicked via include_frames")
                        except Exception as e1:
                            if show_debug_message:
                                print(f"[UDN LOGIN] include_frames method failed: {e1}")

                        # Method 2: Fallback to CDP mouse event
                        if not recaptcha_clicked:
                            try:
                                recaptcha_pos = await tab.evaluate('''
                                    (() => {
                                        const frame = document.querySelector('iframe[title*="reCAPTCHA"]');
                                        if (frame) {
                                            frame.scrollIntoView({ block: 'center' });
                                            const rect = frame.getBoundingClientRect();
                                            return { x: rect.left + 27, y: rect.top + 30, found: true };
                                        }
                                        return { found: false };
                                    })()
                                ''')

                                if isinstance(recaptcha_pos, dict) and recaptcha_pos.get('found'):
                                    x = recaptcha_pos['x']
                                    y = recaptcha_pos['y']
                                    await tab.mouse_click(x, y)
                                    recaptcha_clicked = True
                                    if show_debug_message:
                                        print(f"[UDN LOGIN] reCAPTCHA clicked via mouse_click at ({x}, {y})")
                            except Exception as e2:
                                if show_debug_message:
                                    print(f"[UDN LOGIN] mouse_click method failed: {e2}")

                        if not recaptcha_clicked and show_debug_message:
                            print("[UDN LOGIN] reCAPTCHA checkbox not found")
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[UDN LOGIN] reCAPTCHA click error: {exc}")

                    # After filling credentials and clicking reCAPTCHA, stop here
                    # User needs to complete reCAPTCHA verification and click login manually
                    # The bot will check login status on next iteration
                    if show_debug_message:
                        print("[UDN LOGIN] Credentials filled, waiting for user to complete reCAPTCHA and login...")

        # UDN ticket selection (UTK0203 date/session selection)
        if 'utk0203_.aspx?product_id=' in url.lower():
            # Try layout format 1
            try:
                ticket_input = await tab.query_selector('input.yd_counterNum')
                if ticket_input:
                    await tab.evaluate(f'''
                        (function() {{
                            const input = document.querySelector('input.yd_counterNum');
                            if (input && input.value === '0') {{
                                input.value = '{config_dict["ticket_number"]}';
                            }}
                        }})();
                    ''')
                    btn_next = await tab.query_selector('#buttonNext')
                    if btn_next:
                        await btn_next.click()
                else:
                    # Layout format 2 - use date selection
                    if config_dict["date_auto_select"]["enable"]:
                        await nodriver_kham_product(tab, domain_name, config_dict)
            except:
                pass

        # UDN UTK0204 area selection page (Feature 010: UDN area auto select)
        # URL pattern: .aspx?PERFORMANCE_ID=xxx&PRODUCT_ID=xxx (without PERFORMANCE_PRICE_AREA_ID)
        # This page shows available ticket areas for selection
        # Note: UTK0204 combines area selection and seat map on the same page
        if '.aspx?performance_id=' in url.lower() and 'product_id=' in url.lower():
            # Exclude seat selection page (UTK0205) which has PERFORMANCE_PRICE_AREA_ID
            if 'performance_price_area_id=' not in url.lower():
                if show_debug_message:
                    print("[UDN AREA] Detected UDN UTK0204 area selection page")

                if config_dict["area_auto_select"]["enable"]:
                    # UDN uses nodriver_kham_performance for area selection
                    # UDN selector: table.status > tbody > tr.status_tr (verified via MCP)
                    model_name = "UTK0204"

                    is_price_assign_by_bot, is_captcha_sent = await nodriver_kham_performance(
                        tab, config_dict, ocr, domain_name, model_name
                    )

                    if show_debug_message:
                        print(f"[UDN AREA] Area selection result: is_price_assign_by_bot={is_price_assign_by_bot}")

                    # Feature 010: UDN seat auto select
                    # After area selection, seat map may appear on the same page
                    # Check for seat map and perform seat selection if available
                    if is_price_assign_by_bot:
                        await tab.sleep(0.5)  # Wait for seat map to load
                        is_seat_success = await nodriver_udn_seat_main(tab, config_dict)
                        if show_debug_message:
                            print(f"[UDN SEAT] Seat selection result: {is_seat_success}")
                            if is_seat_success:
                                print("[SUCCESS] UDN seat selection and add to cart completed")

        # UDN UTK0222_02 fast purchase page (Feature 010: UDN quick buy)
        # URL pattern: UTK0222_02.aspx?PRODUCT_ID=xxx
        # This page shows: 1) Date selection 2) Performance selection 3) Area selection
        if 'utk0222_02.aspx' in url.lower():
            # Skip if quick buy was already submitted (waiting for navigation)
            if kham_dict.get("udn_quick_buy_submitted", False):
                return tab

            if show_debug_message:
                print("[UDN QUICK BUY] Detected UTK0222_02 fast purchase page")

            try:
                # Step 1: Date selection (li.yd_datedBtn)
                if config_dict["date_auto_select"]["enable"]:
                    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()

                    date_result_raw = await tab.evaluate('''
                        (() => {
                            const dateBtns = document.querySelectorAll('li.yd_datedBtn');
                            const dates = [];
                            dateBtns.forEach((btn, idx) => {
                                dates.push({
                                    index: idx,
                                    text: btn.textContent.trim()
                                });
                            });
                            return { dates: dates, count: dates.length };
                        })()
                    ''')
                    date_result = util.parse_nodriver_result(date_result_raw)

                    if isinstance(date_result, dict) and date_result.get('count', 0) > 0:
                        dates = date_result.get('dates', [])
                        target_date_idx = None  # None means no match yet
                        keyword_matched = False

                        # Match date keyword (use JSON parsing like other platforms)
                        if date_keyword:
                            keywords = util.parse_keyword_string_to_array(date_keyword)

                            if show_debug_message:
                                print(f"[UDN QUICK BUY] Date keywords parsed: {keywords}")

                            for i, date_item in enumerate(dates):
                                date_text = date_item.get('text', '')
                                for kw in keywords:
                                    # Support AND logic (space-separated keywords)
                                    kw_parts = kw.split(' ') if ' ' in kw else [kw]
                                    all_match = all(part in date_text for part in kw_parts)
                                    if all_match:
                                        target_date_idx = i
                                        keyword_matched = True
                                        if show_debug_message:
                                            print(f"[UDN QUICK BUY] Date matched: {date_text} with keyword: {kw}")
                                        break
                                if keyword_matched:
                                    break  # Early return when matched

                        # Fallback logic based on date_auto_fallback and mode
                        if not keyword_matched:
                            date_auto_fallback = config_dict.get("date_auto_fallback", False)
                            date_mode = config_dict["date_auto_select"].get("mode", "from top to bottom")

                            if date_auto_fallback:
                                if show_debug_message:
                                    print(f"[UDN QUICK BUY] Date keyword not matched, fallback with mode: {date_mode}")

                                target_date_idx = util.get_target_index_by_mode(len(dates), date_mode)

                                if show_debug_message:
                                    selected_date = dates[target_date_idx].get('text', '') if target_date_idx is not None and target_date_idx < len(dates) else ''
                                    print(f"[UDN QUICK BUY] Fallback selected date: {selected_date} (index: {target_date_idx})")
                            else:
                                # Strict mode: no fallback, use first date as default
                                target_date_idx = 0
                                if show_debug_message:
                                    print(f"[UDN QUICK BUY] Fallback disabled, using first date")

                        # Click the date button
                        await tab.evaluate(f'''
                            (() => {{
                                const dateBtns = document.querySelectorAll('li.yd_datedBtn');
                                if (dateBtns[{target_date_idx}]) {{
                                    dateBtns[{target_date_idx}].click();
                                }}
                            }})()
                        ''')
                        await tab.sleep(0.3)

                # Step 2: Performance/Session selection (div.sd-btn.bg--gray)
                if config_dict["date_auto_select"]["enable"]:
                    perf_result_raw = await tab.evaluate('''
                        (() => {
                            const perfBtns = document.querySelectorAll('div.sd-btn.bg--gray');
                            const perfs = [];
                            perfBtns.forEach((btn, idx) => {
                                perfs.push({
                                    index: idx,
                                    text: btn.textContent.trim().replace(/\\s+/g, ' '),
                                    isActive: btn.classList.contains('active')
                                });
                            });
                            return { perfs: perfs, count: perfs.length };
                        })()
                    ''')
                    perf_result = util.parse_nodriver_result(perf_result_raw)

                    if isinstance(perf_result, dict) and perf_result.get('count', 0) > 0:
                        perfs = perf_result.get('perfs', [])
                        target_perf_idx = None  # None means no match yet
                        keyword_matched = False

                        # Check if any is already active
                        has_active = any(p.get('isActive') for p in perfs)

                        # Match performance keyword (use date_keyword for time/venue matching)
                        if date_keyword and not has_active:
                            keywords = util.parse_keyword_string_to_array(date_keyword)

                            for i, perf_item in enumerate(perfs):
                                perf_text = perf_item.get('text', '')
                                for kw in keywords:
                                    # Support AND logic (space-separated keywords)
                                    kw_parts = kw.split(' ') if ' ' in kw else [kw]
                                    all_match = all(part in perf_text for part in kw_parts)
                                    if all_match:
                                        target_perf_idx = i
                                        keyword_matched = True
                                        if show_debug_message:
                                            print(f"[UDN QUICK BUY] Performance matched: {perf_text} with keyword: {kw}")
                                        break
                                if keyword_matched:
                                    break  # Early return when matched

                        # Fallback logic based on date_auto_fallback and mode
                        if not keyword_matched and not has_active:
                            date_auto_fallback = config_dict.get("date_auto_fallback", False)
                            date_mode = config_dict["date_auto_select"].get("mode", "from top to bottom")

                            if date_auto_fallback:
                                if show_debug_message:
                                    print(f"[UDN QUICK BUY] Performance keyword not matched, fallback with mode: {date_mode}")

                                target_perf_idx = util.get_target_index_by_mode(len(perfs), date_mode)

                                if show_debug_message:
                                    selected_perf = perfs[target_perf_idx].get('text', '') if target_perf_idx is not None and target_perf_idx < len(perfs) else ''
                                    print(f"[UDN QUICK BUY] Fallback selected performance: {selected_perf}")
                            else:
                                # Strict mode: default to first
                                target_perf_idx = 0

                        # Click the performance button if not already active
                        if not has_active and target_perf_idx is not None:
                            await tab.evaluate(f'''
                                (() => {{
                                    const perfBtns = document.querySelectorAll('div.sd-btn.bg--gray');
                                    if (perfBtns[{target_perf_idx}]) {{
                                        perfBtns[{target_perf_idx}].click();
                                    }}
                                }})()
                            ''')
                            await tab.sleep(0.3)

                # Step 3: Area selection
                # Get area keywords from config
                area_keyword = config_dict["area_auto_select"]["area_keyword"].strip() if config_dict["area_auto_select"]["enable"] else ""

                # Find all ticket rows from VISIBLE tables only
                # Each performance has its own table, controlled by parent .sd-target display
                ticket_info_raw = await tab.evaluate('''
                    (() => {
                        const tables = document.querySelectorAll('table.yd_ticketsTable');
                        const tickets = [];
                        tables.forEach((table) => {
                            // Check if this table's parent container is visible
                            let parent = table.parentElement;
                            let isVisible = true;
                            for (let i = 0; i < 5 && parent; i++) {
                                if (window.getComputedStyle(parent).display === 'none') {
                                    isVisible = false;
                                    break;
                                }
                                parent = parent.parentElement;
                            }
                            if (!isVisible) return;

                            // Get ticket rows from visible table
                            const rows = table.querySelectorAll('tr.main');
                            rows.forEach((row, idx) => {
                                const cells = row.querySelectorAll('td');
                                if (cells.length >= 5) {
                                    const areaName = cells[1] ? cells[1].textContent.trim() : '';
                                    const ticketType = cells[2] ? cells[2].textContent.trim() : '';
                                    const price = cells[3] ? cells[3].textContent.trim() : '';
                                    const buyBtn = cells[4] ? cells[4].querySelector('.yd_btn--link') : null;
                                    const fastcode = buyBtn ? buyBtn.getAttribute('fastcode') : null;
                                    const isDisabled = buyBtn ? buyBtn.style.cursor === 'default' : true;
                                    tickets.push({
                                        index: idx,
                                        areaName: areaName,
                                        ticketType: ticketType,
                                        price: price,
                                        fastcode: fastcode,
                                        isDisabled: isDisabled
                                    });
                                }
                            });
                        });
                        return { tickets: tickets };
                    })()
                ''')
                ticket_info = util.parse_nodriver_result(ticket_info_raw)

                if isinstance(ticket_info, dict) and 'tickets' in ticket_info:
                    tickets = ticket_info['tickets']
                    if show_debug_message:
                        print(f"[UDN QUICK BUY] Found {len(tickets)} ticket areas")

                    # Find matching area based on keyword (use JSON parsing like other platforms)
                    target_ticket = None
                    if area_keyword:
                        keywords = util.parse_keyword_string_to_array(area_keyword)

                        if show_debug_message:
                            print(f"[UDN QUICK BUY] Area keywords parsed: {keywords}")

                        # Get keyword_exclude for filtering
                        keyword_exclude = config_dict.get("keyword_exclude", "")

                        for kw in keywords:
                            if target_ticket:
                                break  # Early return when matched

                            # Support AND logic (space-separated keywords)
                            kw_parts = kw.split(' ') if ' ' in kw else [kw]

                            for ticket in tickets:
                                if ticket.get('isDisabled'):
                                    continue
                                area_name = ticket.get('areaName', '')

                                # Apply keyword_exclude filter
                                if keyword_exclude and util.reset_row_text_if_match_keyword_exclude(config_dict, area_name):
                                    if show_debug_message:
                                        print(f"[UDN QUICK BUY] Excluded by keyword_exclude: {area_name}")
                                    continue

                                # Check AND logic - all parts must match
                                all_match = all(part in area_name for part in kw_parts)
                                if all_match:
                                    target_ticket = ticket
                                    if show_debug_message:
                                        print(f"[UDN QUICK BUY] Matched area: {area_name} with keyword: {kw}")
                                    break

                    # If no keyword match, apply fallback logic based on area_auto_fallback and mode
                    if not target_ticket:
                        area_auto_fallback = config_dict.get("area_auto_fallback", False)
                        area_mode = config_dict["area_auto_select"].get("mode", "from top to bottom")

                        if area_auto_fallback:
                            # Filter available tickets (not disabled, has fastcode, respecting keyword_exclude)
                            available_tickets = []
                            keyword_exclude = config_dict.get("keyword_exclude", "")
                            for ticket in tickets:
                                if ticket.get('isDisabled') or not ticket.get('fastcode'):
                                    continue
                                area_name = ticket.get('areaName', '')
                                if keyword_exclude and util.reset_row_text_if_match_keyword_exclude(config_dict, area_name):
                                    continue
                                available_tickets.append(ticket)

                            if available_tickets:
                                if show_debug_message:
                                    print(f"[UDN QUICK BUY] No keyword match, fallback with mode: {area_mode}")

                                target_ticket = util.get_target_item_from_matched_list(available_tickets, area_mode)

                                if show_debug_message and target_ticket:
                                    print(f"[UDN QUICK BUY] Fallback selected area: {target_ticket.get('areaName')}")
                        else:
                            # Strict mode: no fallback, don't select anything
                            if show_debug_message:
                                print(f"[UDN QUICK BUY] No keyword match, fallback disabled, waiting for manual selection")

                    # Click the buy button
                    if target_ticket and target_ticket.get('fastcode'):
                        fastcode = target_ticket['fastcode']
                        if show_debug_message:
                            print(f"[UDN QUICK BUY] Clicking buy button for area: {target_ticket.get('areaName')}, fastcode: {fastcode}")

                        await tab.evaluate(f'''
                            (() => {{
                                const btn = document.querySelector('.yd_btn--link[fastcode="{fastcode}"]');
                                if (btn && btn.style.cursor !== 'default') {{
                                    btn.click();
                                }}
                            }})()
                        ''')

                        # Step 4: Handle quantity selection dialog
                        # After clicking "立即購票", a lightbox appears with quantity input
                        # Wait for lightbox with retry
                        ticket_number = config_dict.get("ticket_number", 2)
                        lightbox_found = False

                        for retry in range(5):  # Retry up to 5 times (total 2.5s max)
                            await tab.sleep(0.5)

                            qty_set_raw = await tab.evaluate(f'''
                                (() => {{
                                    const activeLightbox = document.querySelector('.yd_lightbox.active');
                                    if (!activeLightbox) return {{ success: false, reason: 'no_lightbox' }};

                                    const qtyInput = activeLightbox.querySelector('#QRY2, .yd_counterNum');
                                    if (!qtyInput) return {{ success: false, reason: 'no_qty_input' }};

                                    // Get max limit
                                    const maxLimit = parseInt(qtyInput.getAttribute('perflimit') || '4');
                                    const targetQty = Math.min({ticket_number}, maxLimit);

                                    // Set quantity
                                    qtyInput.value = targetQty;
                                    qtyInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                    qtyInput.dispatchEvent(new Event('change', {{ bubbles: true }}));

                                    return {{ success: true, qty: targetQty, max: maxLimit }};
                                }})()
                            ''')
                            qty_set = util.parse_nodriver_result(qty_set_raw)

                            if isinstance(qty_set, dict) and qty_set.get('success'):
                                lightbox_found = True
                                if show_debug_message:
                                    print(f"[UDN QUICK BUY] Set quantity to {qty_set.get('qty')} (max: {qty_set.get('max')})")

                                await tab.sleep(0.3)

                                # Click the "快速訂購" button
                                await tab.evaluate('''
                                    (() => {
                                        const activeLightbox = document.querySelector('.yd_lightbox.active');
                                        if (!activeLightbox) return;
                                        const submitBtn = activeLightbox.querySelector('#f_btn, input[value="快速訂購"], button.yd_btn--primary');
                                        if (submitBtn) {
                                            submitBtn.click();
                                        }
                                    })()
                                ''')

                                # Mark as submitted to prevent duplicate processing
                                kham_dict["udn_quick_buy_submitted"] = True

                                if show_debug_message:
                                    print("[UDN QUICK BUY] Clicked submit button, waiting for navigation...")

                                # Wait for navigation to checkout page
                                for nav_wait in range(10):  # Wait up to 5 seconds for navigation
                                    await tab.sleep(0.5)
                                    current_url = str(tab.target.url).lower()
                                    if 'utk0206' in current_url:
                                        if show_debug_message:
                                            print("[UDN QUICK BUY] Successfully navigated to checkout page")
                                        break
                                break  # Exit retry loop after successful submit
                            else:
                                if show_debug_message and retry == 4:  # Only print on last retry
                                    print(f"[UDN QUICK BUY] Failed to set quantity after retries: {qty_set}")
                    else:
                        if show_debug_message:
                            print("[UDN QUICK BUY] No available ticket area found")

            except Exception as exc:
                if show_debug_message:
                    print(f"[UDN QUICK BUY] Error: {exc}")

    else:
        # Kham / Ticket.com.tw handling
        # Performance page (.aspx?performance_id= & product_id=)
        # Exclude Activity Group pages (handled separately above)
        if '.aspx?performance_id=' in url.lower() and 'product_id=' in url.lower() and 'activity_group_id=' not in url.lower():
            model_name = url.split('/')[5] if len(url.split('/')) > 5 else "UTK0204"
            if len(model_name) > 7:
                model_name = model_name[:7]

            # Check realname dialog
            await nodriver_kham_check_realname_dialog(tab, config_dict)

            # Check captcha error
            if config_dict["ocr_captcha"]["enable"]:
                is_reset = await nodriver_kham_check_captcha_text_error(tab, config_dict)
                if is_reset:
                    await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

            # Close dialog buttons (ticket.com.tw uses retry mechanism)
            if "ticket.com.tw" in url:
                await nodriver_ticket_close_dialog_with_retry(tab, config_dict)
            else:
                try:
                    el_btn = await tab.query_selector('div.ui-dialog-buttonset > button.ui-button')
                    if el_btn:
                        await el_btn.click()
                except:
                    pass

            if config_dict["area_auto_select"]["enable"]:
                # Switch to auto seat
                if "ticket.com.tw" in url:
                    # Ticket.com.tw uses different selector
                    await nodriver_ticket_switch_to_auto_seat(tab)
                else:
                    await nodriver_kham_switch_to_auto_seat(tab)

                # Clean sold out rows (kham specific)
                if "kham.com.tw" in url:
                    try:
                        await tab.evaluate('''
                            (function() {
                                const soldoutRows = document.querySelectorAll('tr.Soldout');
                                soldoutRows.forEach(row => row.remove());

                                const ticketItems = document.querySelectorAll('tr.status_tr');
                                if (ticketItems.length === 0) {
                                    location.reload();
                                }
                            })();
                        ''')
                    except:
                        pass

                # Area selection and captcha
                is_price_assign_by_bot, is_captcha_sent = await nodriver_kham_performance(
                    tab, config_dict, ocr, domain_name, model_name
                )

                # Set ticket number
                if "ticket.com.tw" in url:
                    select_query = 'div.qty-select input[type="text"]'
                else:
                    select_query = '#AMOUNT'

                try:
                    await tab.evaluate(f'''
                        (function() {{
                            const input = document.querySelector('{select_query}');
                            if (input && (input.value === '' || input.value === '0')) {{
                                input.value = '{config_dict["ticket_number"]}';
                                input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                            }}
                        }})();
                    ''')
                except:
                    pass

                # Check adjacent seat checkbox
                if config_dict["advanced"]["disable_adjacent_seat"]:
                    if "ticket.com.tw" in url:
                        await nodriver_ticket_allow_not_adjacent_seat(tab, config_dict)
                    if "kham.com.tw" in url:
                        await nodriver_kham_allow_not_adjacent_seat(tab, config_dict)

                # Submit if captcha sent
                if is_captcha_sent:
                    try:
                        if "ticket.com.tw" in url:
                            # ticket.com.tw uses <input type="submit"> with id ending in AddShopingCart
                            if show_debug_message:
                                print("[SUBMIT] Searching for ticket.com.tw submit button...")
                            el_btn = await tab.query_selector('input[id$="AddShopingCart"]')
                            if not el_btn:
                                # Fallback to <a> tag (for other possible layouts)
                                el_btn = await tab.query_selector('a[onclick="return chkCart();"]')
                        elif "orders.ibon.com.tw" in url:
                            # ibon uses <a> tag with id containing AddShopingCart
                            if show_debug_message:
                                print("[SUBMIT] Searching for ibon submit button...")
                            el_btn = await tab.query_selector('a[id*="AddShopingCart"]')
                            if not el_btn:
                                # Fallback to generic button
                                el_btn = await tab.query_selector('a.btn.btn-primary.btn-block')
                        else:
                            # Kham
                            if show_debug_message:
                                print("[SUBMIT] Searching for Kham submit button...")
                            el_btn = await tab.query_selector('button[onclick="addShoppingCart();return false;"]')

                        if el_btn:
                            if show_debug_message:
                                print("[SUBMIT] Submit button found, scrolling into view...")
                            # Scroll button into view first (important for CDP click)
                            try:
                                await el_btn.scroll_into_view()
                                await tab.sleep(0.3)
                            except:
                                pass

                            if show_debug_message:
                                print("[SUBMIT] Clicking using CDP native click...")
                            # Use NoDriver CDP native click
                            await el_btn.click()
                            if show_debug_message:
                                print("[SUBMIT] Add shopping cart button clicked successfully!")

                            # Check and close success dialog (Kham/Ticket.com.tw shows "加入購物車完成" dialog)
                            # Wait up to 5 seconds for dialog to appear
                            dialog_closed = False
                            for i in range(10):  # 10 attempts * 0.5s = 5 seconds (increased from 3s)
                                await tab.sleep(0.5)
                                try:
                                    dialog_btn = await tab.query_selector('div.ui-dialog-buttonset > button[type="button"]')
                                    if dialog_btn:
                                        if show_debug_message:
                                            print("[SUBMIT] Success dialog found, closing...")
                                        await dialog_btn.click()
                                        await tab.sleep(0.5)  # Wait for dialog close animation
                                        dialog_closed = True
                                        if show_debug_message:
                                            print("[SUBMIT] Dialog closed successfully")
                                        break
                                except Exception as e:
                                    if show_debug_message and i == 9:  # Only print on last attempt
                                        print(f"[SUBMIT] Dialog close attempt failed: {e}")
                                    pass

                            if not dialog_closed and show_debug_message:
                                print("[SUBMIT] No dialog appeared within 5 seconds, continuing...")

                            # If dialog was closed, give page time to process before checking URL
                            if dialog_closed:
                                if show_debug_message:
                                    print("[SUBMIT] Waiting for page transition after dialog close...")
                                await tab.sleep(1.0)

                            # Wait for URL change to prevent duplicate submission (ticket area page)
                            current_url = tab.target.url
                            if show_debug_message:
                                print(f"[SUBMIT] Current URL before transition check: {current_url}")

                            url_changed = False
                            max_wait_time = 30 if dialog_closed else 5  # 30s if dialog closed, 5s otherwise
                            max_attempts = int(max_wait_time / 0.5)

                            for i in range(max_attempts):
                                await tab.sleep(0.5)
                                new_url = tab.target.url
                                if new_url != current_url:
                                    if show_debug_message:
                                        print(f"[SUBMIT] Page transitioned from {current_url}")
                                        print(f"[SUBMIT] to {new_url}")
                                    url_changed = True
                                    break

                            # If timeout, wait additional time before returning to prevent immediate re-execution
                            if not url_changed:
                                if show_debug_message:
                                    print(f"[SUBMIT] WARNING: URL did not change after {max_wait_time} seconds, waiting additional 5 seconds...")
                                await tab.sleep(5.0)  # Longer wait to prevent immediate re-execution

                            # Critical: If dialog closed but URL didn't change, something is wrong
                            if dialog_closed and not url_changed:
                                if show_debug_message:
                                    print("[SUBMIT] CRITICAL: Dialog was closed but URL never changed after 30s")
                                    print("[SUBMIT] This may indicate a submission error - will retry")
                        else:
                            if show_debug_message:
                                print("[SUBMIT] Add shopping cart button not found")
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[SUBMIT] Click chkCart/addShoppingCart button fail: {exc}")

        # Ticket.com.tw UTK0205 seat selection page (graphical seat map)
        # Reference: chrome_tixcraft.py line 9884-9892
        if "ticket.com.tw" in url and 'utk0205' in url.lower():
            if show_debug_message:
                print("Detected ticket.com.tw UTK0205 seat selection page")

            is_seat_selection_success = await nodriver_ticket_seat_main(tab, config_dict, ocr, domain_name)

            if show_debug_message:
                print(f"Seat selection result: {is_seat_selection_success}")

        # UTK0202 page - Activity Group ticket selection (new format)
        # URL: UTK0202_.aspx?PERFORMANCE_ID=xxx&PRODUCT_ID=xxx&ACTIVITY_GROUP_ID=xxx&ACTIVITY_GROUP_ITEM_ID=xxx
        if '.aspx?performance_id=' in url.lower() and 'activity_group_id=' in url.lower():
            model_name = url.split('/')[5] if len(url.split('/')) > 5 else "UTK0202"
            if len(model_name) > 7:
                model_name = model_name[:7]

            if show_debug_message:
                print(f"Detected UTK0202 Activity Group ticket page, model: {model_name}")

            # Check realname dialog
            await nodriver_kham_check_realname_dialog(tab, config_dict)

            # Handle captcha if enabled
            is_captcha_sent = False
            if config_dict["ocr_captcha"]["enable"]:
                is_captcha_sent = await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

            if is_captcha_sent:
                # Set ticket number by clicking + button
                ticket_number = int(config_dict["ticket_number"])
                try:
                    # Click + button N times to set ticket number
                    set_result = await tab.evaluate(f'''
                        (function() {{
                            // Try multiple selectors for + button
                            let plusBtn = document.querySelector('button.plus');
                            if (!plusBtn) {{
                                plusBtn = document.querySelector('button[onclick*="opera1"][onclick*="true"]');
                            }}
                            if (!plusBtn) {{
                                // Try by text content
                                const buttons = document.querySelectorAll('button');
                                for (let btn of buttons) {{
                                    if (btn.textContent.trim() === '+') {{
                                        plusBtn = btn;
                                        break;
                                    }}
                                }}
                            }}

                            if (plusBtn) {{
                                for (let i = 0; i < {ticket_number}; i++) {{
                                    plusBtn.click();
                                }}
                                const amountInput = document.querySelector('#AMOUNT');
                                return amountInput ? amountInput.value : '{ticket_number}';
                            }}

                            // Fallback: directly set input value
                            const amountInput = document.querySelector('#AMOUNT');
                            if (amountInput) {{
                                amountInput.value = '{ticket_number}';
                                amountInput.dispatchEvent(new Event('input', {{ bubbles: true }}));
                                amountInput.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                if (typeof checkNum === 'function') {{
                                    checkNum(amountInput);
                                }}
                                return amountInput.value + ' (fallback)';
                            }}
                            return null;
                        }})();
                    ''')
                    if show_debug_message:
                        print(f"Ticket number set to: {set_result}")
                except Exception as exc:
                    if show_debug_message:
                        print(f"Set ticket number error: {exc}")

                # Click add to cart
                try:
                    btn_selector = 'button[onclick="addShoppingCart();return false;"]'
                    el_btn = await tab.query_selector(btn_selector)
                    if el_btn:
                        await el_btn.click()
                        if show_debug_message:
                            print("Clicked add to cart button")
                    else:
                        # Try alternative selector
                        el_btn = await tab.query_selector('#addcart button.red')
                        if el_btn:
                            await el_btn.click()
                            if show_debug_message:
                                print("Clicked add to cart button (alt)")
                except:
                    pass

        # UTK0202/UTK0205 page - Ticket number selection page
        # URL: UTK0202_.aspx?PERFORMANCE_ID=xxx&PERFORMANCE_PRICE_AREA_ID=xxx
        # Reference: chrome_tixcraft.py line 9895-9941
        if '.aspx?performance_id=' in url.lower() and 'performance_price_area_id=' in url.lower():
            model_name = url.split('/')[5] if len(url.split('/')) > 5 else "UTK0202"
            if len(model_name) > 7:
                model_name = model_name[:7]

            if show_debug_message:
                print(f"Detected UTK0202/UTK0205 ticket number selection page, model: {model_name}")

            is_captcha_sent = False

            # First, check if captcha is already filled (from previous page)
            if config_dict["ocr_captcha"]["enable"]:
                try:
                    captcha_value = await tab.evaluate('''
                        (function() {
                            const input = document.querySelector('input[value="驗證碼"]') ||
                                        document.querySelector('input[placeholder="驗證碼"]') ||
                                        document.querySelector('input[placeholder="請輸入圖片上符號"]') ||
                                        document.querySelector('input[type="text"][maxlength="4"]');
                            return input ? input.value : null;
                        })();
                    ''')
                    if captcha_value and len(captcha_value) == 4 and captcha_value != "驗證碼":
                        is_captcha_sent = True
                        if show_debug_message:
                            print(f"[CAPTCHA] Already filled: {captcha_value}")
                except:
                    pass

            # Check captcha error
            if config_dict["ocr_captcha"]["enable"] and not is_captcha_sent:
                is_reset = await nodriver_kham_check_captcha_text_error(tab, config_dict)
                if is_reset:
                    is_captcha_sent = await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

            # Check adjacent seat checkbox
            if config_dict["advanced"]["disable_adjacent_seat"]:
                if "ticket.com.tw" in url:
                    await nodriver_ticket_allow_not_adjacent_seat(tab, config_dict)
                else:
                    await nodriver_kham_allow_not_adjacent_seat(tab, config_dict)

            # Close dialog buttons (ticket.com.tw uses retry mechanism)
            if "ticket.com.tw" in url:
                await nodriver_ticket_close_dialog_with_retry(tab, config_dict)
            else:
                try:
                    el_btn = await tab.query_selector('div.ui-dialog-buttonset > button.ui-button')
                    if el_btn:
                        await el_btn.click()
                except:
                    pass

            # Handle captcha only if not already sent
            if config_dict["ocr_captcha"]["enable"] and not is_captcha_sent:
                is_captcha_sent = await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

            # Set ticket number
            # For Kham UTK0202 page, there may be multiple ticket types (原價, 身心障礙票, etc.)
            # We need to select the correct input based on ticket type name
            if "ticket.com.tw" in url:
                select_query = 'div.qty-select input[type="text"]'
                try:
                    await tab.evaluate(f'''
                        (function() {{
                            const input = document.querySelector('{select_query}');
                            if (input && (input.value === '' || input.value === '0')) {{
                                input.value = '{config_dict["ticket_number"]}';
                                input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                            }}
                        }})();
                    ''')
                    if show_debug_message:
                        print(f"Ticket number set to: {config_dict['ticket_number']}")
                except Exception as exc:
                    if show_debug_message:
                        print(f"Set ticket number error: {exc}")
            elif "orders.ibon.com.tw" in url:
                # ibon - uses SELECT dropdown for ticket number
                select_query = 'select[id*="AMOUNT_DDL"]'
                try:
                    await tab.evaluate(f'''
                        (function() {{
                            const select = document.querySelector('{select_query}');
                            if (select) {{
                                const targetValue = '{config_dict["ticket_number"]}';
                                // Check if option exists
                                const option = Array.from(select.options).find(opt => opt.value === targetValue);
                                if (option) {{
                                    select.value = targetValue;
                                    select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                    console.log('[IBON TICKET] Set to: ' + targetValue);
                                    return true;
                                }} else {{
                                    console.log('[IBON TICKET] Target value not available: ' + targetValue);
                                    return false;
                                }}
                            }}
                            console.log('[IBON TICKET] SELECT not found');
                            return false;
                        }})();
                    ''')
                    if show_debug_message:
                        print(f"[IBON TICKET] Ticket number set to: {config_dict['ticket_number']}")
                except Exception as exc:
                    if show_debug_message:
                        print(f"[IBON TICKET] Set ticket number error: {exc}")
            else:
                # Kham - find the correct ticket type input using pure JavaScript
                try:
                    # Build exclude keywords list for JavaScript
                    exclude_keywords = []
                    if "keyword_exclude" in config_dict:
                        keyword_exclude_str = config_dict["keyword_exclude"].strip()
                        try:
                            # Try JSON format first (standard storage format)
                            # Example: "\"輪椅\",\"身障\"" → ["輪椅", "身障"]
                            exclude_keywords = json.loads("[" + keyword_exclude_str + "]")
                        except:
                            # Fallback: semicolon-separated format (Issue #23)
                            if util.CONST_KEYWORD_DELIMITER in keyword_exclude_str:
                                exclude_keywords = [k.strip() for k in keyword_exclude_str.split(util.CONST_KEYWORD_DELIMITER) if k.strip()]
                            else:
                                # Single keyword
                                exclude_keywords = [keyword_exclude_str] if keyword_exclude_str else []

                    exclude_keywords_json = json.dumps(exclude_keywords)

                    # Execute all logic in JavaScript to avoid DOM element passing issues
                    result = await tab.evaluate(f'''
                        (function() {{
                            const ticketNumber = '{config_dict["ticket_number"]}';
                            const excludeKeywords = {exclude_keywords_json};

                            // Get all ticket type inputs
                            const inputs = document.querySelectorAll('input.numbox[type="number"][id="AMOUNT"]');
                            console.log('[TICKET] Found ' + inputs.length + ' ticket type inputs');

                            if (inputs.length === 0) {{
                                return {{ success: false, message: 'No ticket inputs found' }};
                            }}

                            // Find the first non-excluded ticket type
                            for (let i = 0; i < inputs.length; i++) {{
                                const input = inputs[i];
                                const key = input.getAttribute('key');

                                    if (!key) continue;

                                    // Get ticket type name
                                const nameInput = document.getElementById(key + '_NAME');
                                const typeName = nameInput ? nameInput.value : '';

                                    console.log('[TICKET] Type: ' + typeName + ' (key: ' + key + ')');

                                    // Check exclude keywords
                                let excluded = false;
                                if (typeName && excludeKeywords.length > 0) {{
                                        const lowerTypeName = typeName.toLowerCase();
                                    for (let j = 0; j < excludeKeywords.length; j++) {{
                                        const keyword = excludeKeywords[j].toLowerCase();
                                        if (keyword && lowerTypeName.includes(keyword)) {{
                                                console.log('[TICKET] Excluded: ' + typeName);
                                                excluded = true;
                                                break;
                                            }}
                                        }}
                                    }}

                                if (excluded) continue;

                                // Found valid ticket type - click + button via opera1
                                console.log('[TICKET] Selected: ' + typeName);
                                const currentValue = parseInt(input.value) || 0;
                                const targetValue = parseInt(ticketNumber);

                                if (currentValue < targetValue) {{
                                    // Try to find and call opera1 function
                                    if (typeof opera1 === 'function') {{
                                        for (let clicks = currentValue; clicks < targetValue; clicks++) {{
                                            opera1(key, true);  // true = increase
                                            console.log('[TICKET] Called opera1(' + key + ', true) - click ' + (clicks + 1));
                                        }}
                                    }} else {{
                                        // Fallback: directly set value
                                        input.value = ticketNumber;
                                        input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                        console.log('[TICKET] Set to: ' + ticketNumber + ' (fallback)');
                                    }}
                                }}

                                return {{
                                    success: true,
                                    typeName: typeName,
                                    key: key,
                                    value: ticketNumber
                                }};
                                }}

                            return {{ success: false, message: 'All ticket types excluded' }};
                            }})();
                    ''')

                    if show_debug_message:
                        # NoDriver returns a complex format, just confirm execution
                        print(f"[TICKET] Ticket selection JavaScript executed")

                except Exception as exc:
                    if show_debug_message:
                        print(f"Set ticket number error: {exc}")

            # Submit if captcha sent and ticket number assigned
            if is_captcha_sent:
                # Check if login is required (Kham only)
                need_login = False
                if "kham.com.tw" in url:
                    try:
                            login_id = await tab.query_selector('#LOGIN_ID')
                            login_pwd = await tab.query_selector('#LOGIN_PWD')

                            if login_id and login_pwd:
                                # Check if login fields are visible
                                is_visible = await tab.evaluate('''
                                    (function() {
                                        const block1 = document.getElementById('LOGIN_BLOCK1');
                                        const block2 = document.getElementById('LOGIN_BLOCK2');
                                        if (block1 && block2) {
                                            const style1 = window.getComputedStyle(block1);
                                            const style2 = window.getComputedStyle(block2);
                                            return style1.display !== 'none' && style2.display !== 'none';
                                        }
                                        return false;
                                    })();
                                ''')

                                if is_visible:
                                    need_login = True
                                    if show_debug_message:
                                        print("[LOGIN REQUIRED] Login fields detected - triggering idle mechanism")
                    except Exception as e:
                        if show_debug_message:
                            print(f"Login detection error: {e}")

                # If login required, trigger idle and don't submit
                if need_login:
                    settings.maxbot_idle()
                    if show_debug_message:
                        print("[IDLE ACTIVATED] Waiting for manual login - ticket number and captcha already filled")
                else:
                    # Normal submit flow
                    try:
                        if "ticket.com.tw" in url:
                            # ticket.com.tw uses <input type="submit"> with id ending in AddShopingCart
                            if show_debug_message:
                                print("[SUBMIT] Searching for ticket.com.tw submit button...")
                            el_btn = await tab.query_selector('input[id$="AddShopingCart"]')
                            if not el_btn:
                                # Fallback to <a> tag
                                el_btn = await tab.query_selector('a[onclick="return chkCart();"]')
                        elif "orders.ibon.com.tw" in url:
                            # ibon uses <a> tag with id containing AddShopingCart
                            if show_debug_message:
                                print("[SUBMIT] Searching for ibon submit button...")
                            el_btn = await tab.query_selector('a[id*="AddShopingCart"]')
                            if not el_btn:
                                # Fallback to generic button
                                el_btn = await tab.query_selector('a.btn.btn-primary.btn-block')
                        else:
                            # Kham
                            if show_debug_message:
                                print("[SUBMIT] Searching for Kham submit button...")
                            el_btn = await tab.query_selector('button[onclick="addShoppingCart();return false;"]')

                        if el_btn:
                            if show_debug_message:
                                print("[SUBMIT] Submit button found, scrolling into view...")
                            # Scroll button into view first (important for CDP click)
                            try:
                                await el_btn.scroll_into_view()
                                await tab.sleep(0.3)
                            except:
                                pass

                            if show_debug_message:
                                print("[SUBMIT] Clicking using CDP native click...")
                            # Use NoDriver CDP native click
                            await el_btn.click()
                            if show_debug_message:
                                print("[SUBMIT] Add shopping cart button clicked successfully!")

                            # Check and close success dialog (Kham/Ticket.com.tw shows "加入購物車完成" dialog)
                            # Wait up to 5 seconds for dialog to appear
                            dialog_closed = False
                            for i in range(10):  # 10 attempts * 0.5s = 5 seconds (increased from 3s)
                                await tab.sleep(0.5)
                                try:
                                    dialog_btn = await tab.query_selector('div.ui-dialog-buttonset > button[type="button"]')
                                    if dialog_btn:
                                        if show_debug_message:
                                            print("[SUBMIT] Success dialog found, closing...")
                                        await dialog_btn.click()
                                        await tab.sleep(0.5)  # Wait for dialog close animation
                                        dialog_closed = True
                                        if show_debug_message:
                                            print("[SUBMIT] Dialog closed successfully")
                                        break
                                except Exception as e:
                                    if show_debug_message and i == 9:  # Only print on last attempt
                                        print(f"[SUBMIT] Dialog close attempt failed: {e}")
                                    pass

                            if not dialog_closed and show_debug_message:
                                print("[SUBMIT] No dialog appeared within 5 seconds, continuing...")

                            # If dialog was closed, give page time to process before checking URL
                            if dialog_closed:
                                if show_debug_message:
                                    print("[SUBMIT] Waiting for page transition after dialog close...")
                                await tab.sleep(1.0)

                            # Wait for URL change to prevent duplicate submission (ticket number page)
                            current_url = tab.target.url
                            if show_debug_message:
                                print(f"[SUBMIT] Current URL before transition check: {current_url}")

                            url_changed = False
                            max_wait_time = 30 if dialog_closed else 5  # 30s if dialog closed, 5s otherwise
                            max_attempts = int(max_wait_time / 0.5)

                            for i in range(max_attempts):
                                await tab.sleep(0.5)
                                new_url = tab.target.url
                                if new_url != current_url:
                                    if show_debug_message:
                                        print(f"[SUBMIT] Page transitioned from {current_url}")
                                        print(f"[SUBMIT] to {new_url}")
                                    url_changed = True
                                    break

                            # If timeout, wait additional time before returning to prevent immediate re-execution
                            if not url_changed:
                                if show_debug_message:
                                    print(f"[SUBMIT] WARNING: URL did not change after {max_wait_time} seconds, waiting additional 5 seconds...")
                                await tab.sleep(5.0)  # Longer wait to prevent immediate re-execution

                            # Critical: If dialog closed but URL didn't change, something is wrong
                            if dialog_closed and not url_changed:
                                if show_debug_message:
                                    print("[SUBMIT] CRITICAL: Dialog was closed but URL never changed after 30s")
                                    print("[SUBMIT] This may indicate a submission error - will retry")
                        else:
                            if show_debug_message:
                                print("[SUBMIT] Add shopping cart button not found")
                    except Exception as exc:
                        if show_debug_message:
                            print(f"[SUBMIT] Click chkCart/addShoppingCart button fail: {exc}")
                            import traceback
                            traceback.print_exc()

        # Login page handling (UTK1306)
        if '/utk13/utk1306_.aspx' in url.lower():
            # Close dialog buttons
            try:
                el_btn = await tab.query_selector('div.ui-dialog-buttonset > button.ui-button')
                if el_btn:
                    await el_btn.click()
            except:
                pass

            if config_dict["ocr_captcha"]["enable"]:
                model_name = url.split('/')[5] if len(url.split('/')) > 5 else "UTK1306"
                if len(model_name) > 7:
                    model_name = model_name[:7]

                # Handle captcha
                await nodriver_kham_captcha(tab, config_dict, ocr, model_name)

                # UDN login (Feature 010: uses same UTK backend as KHAM)
                if 'udnfunlife' in domain_name:
                    udn_account = config_dict["accounts"]["udn_account"]
                    udn_password = config_dict["accounts"]["udn_password"].strip()
                    if len(udn_account) > 4:
                        if show_debug_message:
                            print(f"[UDN LOGIN] Attempting login with account: {udn_account[:3]}***")
                        await nodriver_kham_login(tab, udn_account, udn_password, ocr)

                # Kham login
                kham_account = config_dict["accounts"]["kham_account"]
                kham_password = config_dict["accounts"]["kham_password"].strip()
                if len(kham_account) > 4:
                    await nodriver_kham_login(tab, kham_account, kham_password, ocr)

                # Ticket.com.tw login
                ticket_account = config_dict["accounts"]["ticket_account"]
                ticket_password = config_dict["accounts"]["ticket_password"].strip()
                if len(ticket_account) > 4:
                    # Use dedicated ticket login function (different selectors)
                    await nodriver_ticket_login(tab, ticket_account, ticket_password, config_dict)

    # Check if reached checkout page (ticket purchase successful)
    if '/utk02/utk0206_.aspx' in url.lower():
        # Reset quick buy flag since we've reached checkout
        kham_dict["udn_quick_buy_submitted"] = False

        # Show success message (only once)
        if show_debug_message:
            if not kham_dict["shown_checkout_message"]:
                print("[SUCCESS] Reached checkout page - ticket purchase successful!")
        kham_dict["shown_checkout_message"] = True

        # Play sound notification (only once)
        if not kham_dict["played_sound_order"]:
            if config_dict["advanced"]["play_sound"]["order"]:
                play_sound_while_ordering(config_dict)
            send_discord_notification(config_dict, "order", "KHAM")
        kham_dict["played_sound_order"] = True

        # If headless mode, open browser to show checkout page (only once)
        if config_dict["advanced"]["headless"]:
            if not kham_dict["is_popup_checkout"]:
                import webbrowser
                checkout_url = url
                print(f"搶票成功，請前往該帳號訂單查看: {checkout_url}")
                webbrowser.open_new(checkout_url)
                kham_dict["is_popup_checkout"] = True

    return tab

# ====================================================================================
# Ticket Platform (ticket.com.tw / 年代售票)
# ====================================================================================

async def nodriver_ticket_login(tab, account, password, config_dict):
    """
    年代售票登入

    [TESTED] 已完整測試 - T004 暫停機制補完
    [TESTED] 已完整測試 - 登入邏輯驗證

    Reference: chrome_tixcraft.py ticket_login (Line 5553-5612)
    URL: https://ticket.com.tw/application/utk13/utk1306_.aspx
    """
    # 函數開始檢查暫停 [T004修正]
    if await check_and_handle_pause(config_dict):
        return False

    ret = False
    show_debug_message = config_dict["advanced"].get("verbose", True)

    # Find email/account input - Use ID selector
    el_email = None
    try:
        el_email = await tab.query_selector('#ctl00_ContentPlaceHolder1_M_ACCOUNT')
    except Exception as exc:
        if show_debug_message:
            print("Find account input fail:", exc)

    # Input account
    is_email_sent = False
    if el_email:
        try:
            inputed_text = await tab.evaluate('document.querySelector("#ctl00_ContentPlaceHolder1_M_ACCOUNT").value')
            if not inputed_text or len(inputed_text) == 0:
                await el_email.send_keys(account)
                is_email_sent = True
            else:
                if inputed_text == account:
                    is_email_sent = True
        except Exception as exc:
            if show_debug_message:
                print("Input account fail:", exc)

    # Find password input - Use ID selector
    el_pass = None
    if is_email_sent:
        try:
            el_pass = await tab.query_selector('#ctl00_ContentPlaceHolder1_M_PASSWORD')
        except Exception as exc:
            if show_debug_message:
                print("Find password input fail:", exc)

    # Input password
    is_password_sent = False
    if el_pass:
        try:
            inputed_text = await tab.evaluate('document.querySelector("#ctl00_ContentPlaceHolder1_M_PASSWORD").value')
            if not inputed_text or len(inputed_text) == 0:
                await el_pass.click()
                if len(password) > 0:
                    await el_pass.send_keys(password)
                    is_password_sent = True
                await tab.sleep(0.1)
        except Exception as exc:
            if show_debug_message:
                print("Input password fail:", exc)

    # Click login button - Use ID selector
    if is_password_sent:
        try:
            el_btn = await tab.query_selector('#ctl00_ContentPlaceHolder1_LOGIN_BTN')
            if el_btn:
                await el_btn.click()
                ret = True
                if show_debug_message:
                    print("[TICKET LOGIN] Login button clicked")
        except Exception as exc:
            if show_debug_message:
                print("Click login button fail:", exc)

    return ret


async def nodriver_kham_seat_type_auto_select(tab, config_dict, area_keyword_item):
    """
    寬宏售票 - 自動選擇票別 (UTK0205 座位選擇頁面)
    選擇票價類型，如原價、身障、陪同者等
    HTML structure: <button class="green" onclick="setType(...)">原價-NT$3,680</button>
    使用 CDP DOMSnapshot 穿透 DOM，避免 JavaScript 載入時機問題
    參考年代售票 nodriver_ticket_seat_type_auto_select 成功實作
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_seat_type_assigned = False

    # Clean keyword quotes
    # NOTE: This function only supports single keyword or space-separated AND logic (e.g., "VIP 區")
    # For multiple keywords with OR logic, caller should use JSON parsing and iterate
    if area_keyword_item and len(area_keyword_item) > 0:
        try:
            area_keyword_clean = area_keyword_item.strip()
            if area_keyword_clean.startswith('"') and area_keyword_clean.endswith('"'):
                area_keyword_clean = area_keyword_clean[1:-1]

            # Use the cleaned keyword directly (no comma split to avoid incorrect AND logic)
            area_keyword_item = area_keyword_clean
        except Exception as e:
            if show_debug_message:
                print(f"[KHAM SEAT TYPE] Keyword parse error: {e}")

    try:
        from nodriver import cdp

        # Step 1: Capture DOM snapshot
        if show_debug_message:
            print("[KHAM SEAT TYPE] Capturing DOM snapshot...")

        try:
            documents, strings = await tab.send(cdp.dom_snapshot.capture_snapshot(
                computed_styles=[],
                include_dom_rects=True
            ))
        except Exception as snapshot_exc:
            if show_debug_message:
                print(f"[KHAM SEAT TYPE] ERROR capturing snapshot: {snapshot_exc}")
            # Fallback: try simple JavaScript method
            if show_debug_message:
                print("[KHAM SEAT TYPE] Falling back to JavaScript method...")

            buttons_data = await tab.evaluate('''
                (function() {
                    const buttons = document.querySelectorAll('button[onclick*="setType"]');
                    const result = [];
                    buttons.forEach((btn) => {
                        result.push({
                            text: btn.textContent.trim(),
                            disabled: btn.disabled
                        });
                    });
                    return result;
                })();
            ''')

            # 轉換 CDP 格式為 Python list
            buttons_list = []
            if isinstance(buttons_data, list):
                for item in buttons_data:
                    if isinstance(item, list) and len(item) == 2:
                        val_obj = item[1]
                        if isinstance(val_obj, dict) and 'value' in val_obj:
                            obj_data = val_obj['value']
                            btn_info = {}
                            if isinstance(obj_data, list):
                                for prop in obj_data:
                                    if isinstance(prop, list) and len(prop) == 2:
                                        key = prop[0]
                                        val = prop[1].get('value') if isinstance(prop[1], dict) else prop[1]
                                        btn_info[key] = val
                            buttons_list.append(btn_info)

            if show_debug_message:
                print(f"[KHAM SEAT TYPE] Found {len(buttons_list)} button(s) via JavaScript fallback")

            # 簡化邏輯：直接使用 JavaScript 找到的按鈕
            if len(buttons_list) > 0:
                # 直接點擊第一個可用按鈕
                result = await tab.evaluate('''
                    (function() {
                        const buttons = document.querySelectorAll('button[onclick*="setType"]');
                        for (let btn of buttons) {
                            if (!btn.disabled) {
                                btn.click();
                                return true;
                            }
                        }
                        return false;
                    })();
                ''')

                if isinstance(result, list) and len(result) == 2:
                    is_seat_type_assigned = result[1].get('value', False) if isinstance(result[1], dict) else result
                else:
                    is_seat_type_assigned = result

                if show_debug_message:
                    print(f"[KHAM SEAT TYPE] JavaScript fallback click result: {is_seat_type_assigned}")

                if show_debug_message:
                    print(f"[KHAM SEAT TYPE] Assignment result: {is_seat_type_assigned}")

                return is_seat_type_assigned

            raise snapshot_exc

        # Step 2: Search for ticket type buttons
        ticket_buttons = []

        if show_debug_message:
            print(f"[KHAM SEAT TYPE] documents type: {type(documents)}, len: {len(documents) if documents else 0}")

        if documents and len(documents) > 0:
            document_snapshot = documents[0]
            nodes = document_snapshot.nodes

            # Extract node information
            node_names = [strings[i] for i in nodes.node_name]
            node_values = [strings[i] if i >= 0 else '' for i in nodes.node_value]
            attributes_list = nodes.attributes
            backend_node_ids = list(nodes.backend_node_id)

            if show_debug_message:
                print(f"[KHAM SEAT TYPE] Total nodes in snapshot: {len(node_names)}")

            # Step 3: Search for buttons with setType onclick
            for i, node_name in enumerate(node_names):
                if node_name.upper() == 'BUTTON':
                    # Parse attributes
                    attrs = {}
                    if i < len(attributes_list):
                        attr_indices = attributes_list[i]
                        for j in range(0, len(attr_indices), 2):
                            if j + 1 < len(attr_indices):
                                key = strings[attr_indices[j]]
                                val = strings[attr_indices[j + 1]]
                                attrs[key] = val

                    # Check if this is a ticket type button (onclick contains setType)
                    onclick = attrs.get('onclick', '')
                    button_class = attrs.get('class', '')
                    button_disabled = 'disabled' in attrs

                    if 'setType' in onclick:
                        # Get button text from child text nodes
                        # Strategy 1: Search for first non-empty text node in children
                        button_text = ''
                        for j in range(i + 1, min(i + 10, len(node_names))):  # Check next 10 nodes
                            if node_names[j] == '#text':
                                text_content = node_values[j].strip()
                                if text_content and len(text_content) > 0:
                                    button_text = text_content
                                    if show_debug_message:
                                        print(f"[KHAM SEAT TYPE] Extracted text from node {j}: '{button_text}'")
                                    break
                            # Stop when encountering another element (DIV, BUTTON, etc.)
                            elif node_names[j] in ['DIV', 'BUTTON', 'INPUT', 'SPAN', 'A']:
                                break

                        # Strategy 2: Fallback - Extract from onclick attribute if text is empty
                        if not button_text and 'setType' in onclick:
                            import re
                            match = re.search(r"setType\('[^']*','([^']*)'\)", onclick)
                            if match:
                                button_text = match.group(1)
                                if show_debug_message:
                                    print(f"[KHAM SEAT TYPE] Extracted text from onclick: '{button_text}'")

                        ticket_buttons.append({
                            'backend_node_id': backend_node_ids[i],
                            'class': button_class,
                            'onclick': onclick,
                            'disabled': button_disabled,
                            'text': button_text,
                            'index': i
                        })

                        if show_debug_message:
                            print(f"[KHAM SEAT TYPE] Found button #{len(ticket_buttons)}: text='{button_text}', disabled={button_disabled}")

        if show_debug_message:
            print(f"[KHAM SEAT TYPE] Found {len(ticket_buttons)} ticket type button(s)")

        if len(ticket_buttons) == 0:
            if show_debug_message:
                print("[KHAM SEAT TYPE] No ticket type buttons found")
            return False

        # Step 4: Filter disabled buttons
        enabled_buttons = [btn for btn in ticket_buttons if not btn['disabled']]

        if show_debug_message:
            print(f"[KHAM SEAT TYPE] Found {len(enabled_buttons)} enabled button(s)")

        if len(enabled_buttons) == 0:
            if show_debug_message:
                print("[KHAM SEAT TYPE] All buttons are disabled")
            return False

        # Step 5: Match and select button using Python logic
        matched_button = None

        for btn in enabled_buttons:
            button_text = btn.get('text', '')
            if not button_text:
                continue

            # 使用 util 檢查是否應該排除（依據設定檔的 keyword_exclude）
            if util.reset_row_text_if_match_keyword_exclude(config_dict, button_text):
                if show_debug_message:
                    print(f"[KHAM SEAT TYPE] Excluded by keyword_exclude: {button_text}")
                continue

            # 關鍵字匹配邏輯
            is_match = True
            if area_keyword_item and len(area_keyword_item) > 0:
                keywords = area_keyword_item.split(' ')
                row_text = util.format_keyword_string(button_text)
                for kw in keywords:
                    formatted_kw = util.format_keyword_string(kw)
                    if formatted_kw not in row_text:
                        is_match = False
                        break

            if is_match:
                matched_button = btn
                if show_debug_message:
                    print(f"[KHAM SEAT TYPE] Matched: {button_text}")
                break

        # If no keyword match found, use first enabled button
        if matched_button is None and len(enabled_buttons) > 0:
            matched_button = enabled_buttons[0]
            if show_debug_message:
                print(f"[KHAM SEAT TYPE] No keyword match, using first button: {matched_button.get('text', '')}")

        # Step 6: Click matched button using CDP Input.dispatchMouseEvent (per nodriver API guide Example 3)
        if matched_button is not None:
            button_text = matched_button.get('text', '')
            backend_node_id = matched_button.get('backend_node_id')

            try:
                if show_debug_message:
                    print(f"[KHAM SEAT TYPE] Clicking button via CDP: {button_text}")

                is_seat_type_assigned = False

                # Step 6.1: Convert backend_node_id to node_id using CDP DOM
                if backend_node_id is not None:
                    try:
                        if show_debug_message:
                            print(f"[KHAM SEAT TYPE] Using backend_node_id={backend_node_id}")

                        # Get document first
                        await tab.send(cdp.dom.get_document())

                        # Convert backend_node_id to node_id
                        push_result = await tab.send(cdp.dom.push_nodes_by_backend_ids_to_frontend([backend_node_id]))
                        if push_result and len(push_result) > 0:
                            node_id = push_result[0]

                            if show_debug_message:
                                print(f"[KHAM SEAT TYPE] Converted to node_id={node_id}")

                            # Step 6.2: Scroll into view to ensure element is visible
                            try:
                                await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=node_id))
                                if show_debug_message:
                                    print(f"[KHAM SEAT TYPE] Scrolled button into view")
                            except Exception as scroll_exc:
                                if show_debug_message:
                                    print(f"[KHAM SEAT TYPE] Scroll into view exception (non-critical): {scroll_exc}")

                            # Step 6.3: Get box model for precise click coordinates
                            try:
                                box_model = await tab.send(cdp.dom.get_box_model(node_id=node_id))
                                if show_debug_message:
                                    print(f"[KHAM SEAT TYPE] Box model result: {type(box_model)}")

                                if box_model and hasattr(box_model, 'content') and box_model.content:
                                    quad = box_model.content
                                    # Calculate center coordinates from quad (8 values: [x1, y1, x2, y2, x3, y3, x4, y4])
                                    center_x = (quad[0] + quad[2] + quad[4] + quad[6]) / 4.0
                                    center_y = (quad[1] + quad[3] + quad[5] + quad[7]) / 4.0

                                    if show_debug_message:
                                        print(f"[KHAM SEAT TYPE] Box model center: ({center_x:.1f}, {center_y:.1f})")

                                    # Step 6.4: Use JavaScript to click (CDP input module not available)
                                    # Since JavaScript fallback already works, skip CDP mouse event
                                    if show_debug_message:
                                        print(f"[KHAM SEAT TYPE] Using JavaScript click (CDP input unavailable)")
                                else:
                                    if show_debug_message:
                                        print(f"[KHAM SEAT TYPE] Failed to get box model content: {box_model}")
                                    print(f"[KHAM SEAT TYPE] Falling back to JavaScript click...")

                            except Exception as box_exc:
                                if show_debug_message:
                                    print(f"[KHAM SEAT TYPE] Box model exception: {box_exc}")
                        else:
                            if show_debug_message:
                                print(f"[KHAM SEAT TYPE] Failed to convert backend_node_id: push_result={push_result}")

                    except Exception as cdp_exc:
                        if show_debug_message:
                            print(f"[KHAM SEAT TYPE] CDP operation error: {cdp_exc}")
                else:
                    if show_debug_message:
                        print(f"[KHAM SEAT TYPE] backend_node_id is None, using JavaScript fallback")

                # Fallback: If CDP click failed, try JavaScript click
                if not is_seat_type_assigned:
                    try:
                        if show_debug_message:
                            print(f"[KHAM SEAT TYPE] Attempting JavaScript fallback click")
                        result = await tab.evaluate('''
                            (function() {
                                const buttons = document.querySelectorAll('button[onclick*="setType"]');
                                for (let btn of buttons) {
                                    if (btn.textContent.includes('%s')) {
                                        btn.click();
                                        return true;
                                    }
                                }
                                return false;
                            })();
                        ''' % button_text.replace("'", "\\'"))

                        if isinstance(result, list) and len(result) == 2:
                            is_seat_type_assigned = result[1].get('value', False) if isinstance(result[1], dict) else result
                        else:
                            is_seat_type_assigned = result

                        if is_seat_type_assigned:
                            if show_debug_message:
                                print(f"[KHAM SEAT TYPE] JavaScript fallback click succeeded")
                        else:
                            if show_debug_message:
                                print(f"[KHAM SEAT TYPE] JavaScript fallback click failed")
                    except Exception as js_exc:
                        if show_debug_message:
                            print(f"[KHAM SEAT TYPE] JavaScript fallback exception: {js_exc}")

            except Exception as click_exc:
                if show_debug_message:
                    print(f"[KHAM SEAT TYPE] CDP click exception: {click_exc}")

    except Exception as exc:
        if show_debug_message:
            print(f"[ERROR] KHAM seat type selection error: {exc}")
        import traceback
        if show_debug_message:
            traceback.print_exc()

    if show_debug_message:
        print(f"[KHAM SEAT TYPE] Assignment result: {is_seat_type_assigned}")

    return is_seat_type_assigned


async def nodriver_kham_seat_auto_select(tab, config_dict):
    """
    寬宏售票 - 自動選擇座位，優化策略：舞台方向智慧選座
    HTML structure:
    - Stage direction: <div class="stageDirection topright/topleft/downright/downleft/top/down/left/right">
    - Available seats: <table id="TBL"><td class="empty up/down/left/right" title="2樓黃2D區-3排-14號">
    - Sold seats: <td class="people up/down/left/right">

    舞台方向邏輯：
    - up: 排數越小越前，每排選中間座位
    - down: 排數越大越前，每排選中間座位
    - left: 座位號越小越前，每列選中間排
    - right: 座位號越大越前，每列選中間排
    - topright/topleft/downright/downleft: 組合方向，優先處理主要方向
    """
    is_seat_assigned = False
    ticket_number = config_dict["ticket_number"]
    allow_non_adjacent = config_dict["advanced"]["disable_adjacent_seat"]
    show_debug = config_dict["advanced"].get("verbose", False)

    try:
        # 使用純 JavaScript 執行全部邏輯：偵測方向 -> 分組 -> 排序 -> 選擇 -> 點擊
        import json
        result = await tab.evaluate(f'''
            (function() {{
                const ticketNumber = {ticket_number};
                const allowNonAdjacent = {json.dumps(allow_non_adjacent)};
                const showDebug = {json.dumps(show_debug)};

                // Step 0: Detect stage direction
                const stageDiv = document.querySelector('.stageDirection');
                let stageDirection = 'up'; // default: stage at top
                if (stageDiv) {{
                    const classList = stageDiv.classList;
                    if (classList.contains('topright')) stageDirection = 'up';       // topright -> up (主要方向)
                    else if (classList.contains('topleft')) stageDirection = 'up';   // topleft -> up (主要方向)
                    else if (classList.contains('downright')) stageDirection = 'down';
                    else if (classList.contains('downleft')) stageDirection = 'down';
                    else if (classList.contains('top')) stageDirection = 'up';
                    else if (classList.contains('down')) stageDirection = 'down';
                    else if (classList.contains('left')) stageDirection = 'left';
                    else if (classList.contains('right')) stageDirection = 'right';
                }}

                if (showDebug) {{
                    console.log('[KHAM SEAT] Stage direction: ' + stageDirection);
                }}

                // Step 1: Find all available seats with REAL DOM positions
                // Important: Use real TD column index, not filtered array index
                // This correctly handles spacer TDs (<td>&nbsp;</td>) that represent aisles/separators
                const allTableRows = document.querySelectorAll('table#TBL tr');
                let totalAvailableSeats = 0;

                // First pass: count available seats
                Array.from(allTableRows).forEach(tr => {{
                    const allTds = tr.children;
                    for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                        if (allTds[colIndex].classList.contains('empty')) {{
                            totalAvailableSeats++;
                        }}
                    }}
                }});

                if (showDebug) {{
                    console.log('[KHAM SEAT] Found ' + totalAvailableSeats + ' available seats');
                }}

                if (totalAvailableSeats < ticketNumber) {{
                    return {{ success: false, found: totalAvailableSeats, selected: 0, direction: stageDirection }};
                }}

                const selectedSeats = [];

                // Step 2-4: Group, sort and select based on stage direction
                if (stageDirection === 'up' || stageDirection === 'down') {{
                    // GROUP BY ROW: For top/bottom stages
                    const rows = {{}};

                    // Second pass: collect seats with REAL DOM column index
                    Array.from(allTableRows).forEach(tr => {{
                        const allTds = tr.children;
                        for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                            const seat = allTds[colIndex];
                            if (seat.classList.contains('empty')) {{
                                const title = seat.getAttribute('title');
                                if (title && title.includes('排') && title.includes('號')) {{
                                    const parts = title.split('-');
                                    if (parts.length >= 3) {{
                                        // [KHAM] Parse row number (support both letter and number rows)
                                        let rowNum;
                                        const rowText = parts[1]; // e.g. "H排" or "17排"
                                        const letterMatch = rowText.match(/([A-Z]+)排/);
                                        if (letterMatch) {{
                                            // Letter row (H排 -> 8, I排 -> 9, etc.)
                                            const letters = letterMatch[1];
                                            rowNum = 0;
                                            for (let i = 0; i < letters.length; i++) {{
                                                rowNum = rowNum * 26 + (letters.charCodeAt(i) - 64);
                                            }}
                                        }} else {{
                                            // Numeric row
                                            rowNum = parseInt(rowText.replace('排', ''));
                                        }}
                                        const seatNum = parseInt(parts[2].replace('號', ''));
                                        if (!isNaN(rowNum) && !isNaN(seatNum)) {{
                                            if (!rows[rowNum]) rows[rowNum] = [];
                                            // CRITICAL: Use REAL colIndex as domIndex, not filtered array index
                                            rows[rowNum].push({{ elem: seat, num: seatNum, title: title, domIndex: colIndex }});
                                        }}
                                    }}
                                }}
                            }}
                        }}
                    }});

                    // Helper function: calculate row quality score
                    function calculateRowQuality(rowSeats) {{
                        const totalSeats = rowSeats.length;

                        // Find max continuous segment (based on DOM index, not seat number)
                        let maxContinuous = 1;
                        let currentContinuous = 1;
                        for (let i = 0; i < rowSeats.length - 1; i++) {{
                            const domGap = rowSeats[i + 1].domIndex - rowSeats[i].domIndex;
                            if (domGap === 1) {{
                                // Adjacent in DOM
                                currentContinuous++;
                                maxContinuous = Math.max(maxContinuous, currentContinuous);
                            }} else {{
                                // Gap found
                                currentContinuous = 1;
                            }}
                        }}

                        // Calculate middle seats ratio (seats in middle 50%)
                        const middleStart = Math.floor(totalSeats * 0.25);
                        const middleEnd = Math.floor(totalSeats * 0.75);
                        let middleCount = 0;
                        rowSeats.forEach((seat, idx) => {{
                            if (idx >= middleStart && idx < middleEnd) middleCount++;
                        }});
                        const middleRatio = middleCount / Math.max(1, (middleEnd - middleStart));

                        // Three-tier quality score:
                        // 1. Priority: has enough continuous seats
                        // 2. Priority: middle seat ratio
                        // 3. Priority: stage direction preference
                        return {{
                            maxContinuous: maxContinuous,
                            totalSeats: totalSeats,
                            middleRatio: middleRatio,
                            score: (maxContinuous >= ticketNumber) ? 100 + middleRatio : maxContinuous + middleRatio
                        }};
                    }}

                    // Sort rows by stage direction
                    let sortedRows;
                    if (stageDirection === 'up') {{
                        // Stage at top: smaller row number = closer to stage
                        sortedRows = Object.entries(rows).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
                    }} else {{
                        // Stage at bottom: larger row number = closer to stage
                        sortedRows = Object.entries(rows).sort((a, b) => parseInt(b[0]) - parseInt(a[0]));
                    }}

                    // Select seats from front rows
                    for (const [rowNum, rowSeats] of sortedRows) {{
                        // Sort by DOM order (domIndex) to maintain continuity
                        rowSeats.sort((a, b) => a.domIndex - b.domIndex);
                        const seatCount = rowSeats.length;

                        if (allowNonAdjacent) {{
                            // Non-adjacent mode: select from middle of row
                            const startIdx = Math.max(0, Math.floor((seatCount - ticketNumber) / 2));
                            for (let i = 0; i < Math.min(ticketNumber, seatCount); i++) {{
                                if (startIdx + i < rowSeats.length) {{
                                    selectedSeats.push(rowSeats[startIdx + i]);
                                    if (selectedSeats.length >= ticketNumber) break;
                                }}
                            }}
                        }} else {{
                            // Adjacent mode: find continuous seats in DOM order
                            for (let startIdx = 0; startIdx <= rowSeats.length - ticketNumber; startIdx++) {{
                                let continuous = true;
                                for (let i = 0; i < ticketNumber - 1; i++) {{
                                    const currentDomIdx = rowSeats[startIdx + i].domIndex;
                                    const nextDomIdx = rowSeats[startIdx + i + 1].domIndex;
                                    const domGap = nextDomIdx - currentDomIdx;
                                    if (domGap > 1) {{
                                        // Seats are not adjacent in DOM
                                        continuous = false;
                                        break;
                                    }}
                                }}

                                if (continuous) {{
                                    for (let i = 0; i < ticketNumber; i++) {{
                                        selectedSeats.push(rowSeats[startIdx + i]);
                                    }}
                                    break;
                                }}
                            }}
                        }}

                        if (selectedSeats.length >= ticketNumber) break;
                    }}

                }} else if (stageDirection === 'left' || stageDirection === 'right') {{
                    // GROUP BY SEAT NUMBER (column): For left/right stages
                    const columns = {{}};

                    // Collect seats with REAL DOM row index (for vertical continuity check)
                    let rowIndexInTable = 0;
                    Array.from(allTableRows).forEach(tr => {{
                        const allTds = tr.children;
                        for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                            const seat = allTds[colIndex];
                            if (seat.classList.contains('empty')) {{
                                const title = seat.getAttribute('title');
                                if (title && title.includes('排') && title.includes('號')) {{
                                    const parts = title.split('-');
                                    if (parts.length >= 3) {{
                                        // [KHAM] Parse row number (support both letter and number rows)
                                        let rowNum;
                                        const rowText = parts[1]; // e.g. "H排" or "17排"
                                        const letterMatch = rowText.match(/([A-Z]+)排/);
                                        if (letterMatch) {{
                                            // Letter row (H排 -> 8, I排 -> 9, etc.)
                                            const letters = letterMatch[1];
                                            rowNum = 0;
                                            for (let i = 0; i < letters.length; i++) {{
                                                rowNum = rowNum * 26 + (letters.charCodeAt(i) - 64);
                                            }}
                                        }} else {{
                                            // Numeric row
                                            rowNum = parseInt(rowText.replace('排', ''));
                                        }}
                                        const seatNum = parseInt(parts[2].replace('號', ''));
                                        if (!isNaN(rowNum) && !isNaN(seatNum)) {{
                                            if (!columns[seatNum]) columns[seatNum] = [];
                                            // CRITICAL: Use real rowIndexInTable as domIndex for vertical continuity
                                            columns[seatNum].push({{ elem: seat, rowNum: rowNum, title: title, domIndex: rowIndexInTable }});
                                        }}
                                    }}
                                }}
                            }}
                        }}
                        rowIndexInTable++;
                    }});

                    // Sort columns by stage direction
                    let sortedColumns;
                    if (stageDirection === 'left') {{
                        // Stage at left: smaller seat number = closer to stage
                        sortedColumns = Object.entries(columns).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
                    }} else {{
                        // Stage at right: larger seat number = closer to stage
                        sortedColumns = Object.entries(columns).sort((a, b) => parseInt(b[0]) - parseInt(a[0]));
                    }}

                    // Select seats from front columns
                    for (const [seatNum, columnSeats] of sortedColumns) {{
                        // Sort by DOM order (domIndex) to maintain continuity
                        columnSeats.sort((a, b) => a.domIndex - b.domIndex);
                        const rowCount = columnSeats.length;

                        if (allowNonAdjacent) {{
                            // Non-adjacent mode: select from middle rows of column
                            const startIdx = Math.max(0, Math.floor((rowCount - ticketNumber) / 2));
                            for (let i = 0; i < Math.min(ticketNumber, rowCount); i++) {{
                                if (startIdx + i < columnSeats.length) {{
                                    selectedSeats.push(columnSeats[startIdx + i]);
                                    if (selectedSeats.length >= ticketNumber) break;
                                }}
                            }}
                        }} else {{
                            // Adjacent mode: find continuous rows in DOM order (not by row number)
                            for (let startIdx = 0; startIdx <= columnSeats.length - ticketNumber; startIdx++) {{
                                let continuous = true;
                                for (let i = 0; i < ticketNumber - 1; i++) {{
                                    const currentDomIdx = columnSeats[startIdx + i].domIndex;
                                    const nextDomIdx = columnSeats[startIdx + i + 1].domIndex;
                                    const domGap = nextDomIdx - currentDomIdx;
                                    if (domGap > 1) {{
                                        // Seats are not adjacent in DOM
                                        continuous = false;
                                        break;
                                    }}
                                }}

                                if (continuous) {{
                                    for (let i = 0; i < ticketNumber; i++) {{
                                        selectedSeats.push(columnSeats[startIdx + i]);
                                    }}
                                    break;
                                }}
                            }}
                        }}

                        if (selectedSeats.length >= ticketNumber) break;
                    }}
                }}

                // Step 5: Click selected seats
                let clickedCount = 0;
                const clickedTitles = [];
                for (const seat of selectedSeats.slice(0, ticketNumber)) {{
                    // 寬宏座位點擊後會改變 class（empty -> 其他狀態）
                    seat.elem.click();
                    clickedCount++;
                    clickedTitles.push(seat.title);
                }}

                return {{
                    success: clickedCount > 0,
                    found: totalAvailableSeats,
                    selected: clickedCount,
                    titles: clickedTitles,
                    direction: stageDirection
                }};
            }})();
        ''')

        # 轉換 CDP 格式為 Python dict
        result_dict = {}
        if isinstance(result, list):
            for item in result:
                if isinstance(item, list) and len(item) == 2:
                    key = item[0]
                    val_obj = item[1]
                    if isinstance(val_obj, dict) and 'value' in val_obj:
                        value = val_obj['value']
                        # 處理陣列類型
                        if val_obj.get('type') == 'array' and isinstance(value, list):
                            result_dict[key] = [
                                v.get('value') if isinstance(v, dict) else v
                                for v in value
                            ]
                        else:
                            result_dict[key] = value
        elif isinstance(result, dict):
            result_dict = result

        is_seat_assigned = result_dict.get('success', False)

        if show_debug:
            stage_dir = result_dict.get('direction', 'unknown')
            print(f"[KHAM SEAT] Stage direction: {stage_dir}")
            print(f"[KHAM SEAT] Found {result_dict.get('found', 0)} available seats")
            print(f"[KHAM SEAT] Selected {result_dict.get('selected', 0)}/{ticket_number} seats")
            if result_dict.get('titles'):
                for title in result_dict['titles']:
                    print(f"[SUCCESS] Selected seat: {title}")

    except Exception as exc:
        if show_debug:
            print(f"[ERROR] KHAM seat selection error: {exc}")
        import traceback
        if show_debug:
            traceback.print_exc()

    return is_seat_assigned


async def nodriver_kham_seat_main(tab, config_dict, ocr, domain_name):
    """
    寬宏售票座位選擇主流程：票別選擇 -> 座位選擇 -> 驗證碼 -> 提交
    UTK0205 頁面處理
    """
    show_debug = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict["ticket_number"]

    # Step 0: Check if seats are already selected (avoid duplicate selection)
    already_selected_count = 0
    try:
        check_result = await tab.evaluate('''
            (() => {
                const selectedSeats = document.querySelectorAll('#TBL td[style*="icon_chair_select"]');
                return selectedSeats.length;
            })()
        ''')
        if isinstance(check_result, int):
            already_selected_count = check_result
        elif isinstance(check_result, dict):
            already_selected_count = check_result.get('value', 0)

        if show_debug:
            print(f"[KHAM SEAT] Already selected seats: {already_selected_count}")
    except Exception as exc:
        if show_debug:
            print(f"[KHAM SEAT] Error checking selected seats: {exc}")

    # If already selected enough seats, skip seat selection and go to submit
    if already_selected_count >= ticket_number:
        if show_debug:
            print(f"[KHAM SEAT] Already have {already_selected_count} seats (need {ticket_number}), skipping to submit")
        is_seat_type_assigned = True
        is_seat_assigned = True
    else:
        # Step 1: Select seat type
        area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
        is_seat_type_assigned = await nodriver_kham_seat_type_auto_select(
            tab, config_dict, area_keyword
        )

        # Step 2: Select seats
        is_seat_assigned = False
        if is_seat_type_assigned:
            is_seat_assigned = await nodriver_kham_seat_auto_select(tab, config_dict)

    # Step 3: Handle captcha (reuse KHAM OCR)
    is_captcha_sent = False
    if is_seat_assigned and config_dict["ocr_captcha"]["enable"]:
        try:
            # Find captcha input field
            captcha_input = await tab.query_selector('input#CHK')
            if show_debug:
                print(f"[KHAM SEAT] Captcha input found: {captcha_input is not None}")
            if captcha_input:
                model_name = "UTK0205"
                is_captcha_sent = await nodriver_kham_captcha(
                    tab, config_dict, ocr, model_name
                )
                if show_debug:
                    print(f"[KHAM SEAT] is_captcha_sent: {is_captcha_sent}")
        except Exception as exc:
            if show_debug:
                print(f"[ERROR] KHAM captcha processing error: {exc}")

    # Step 4: Submit order with improved dialog handling and URL tracking
    is_submit_success = False
    if is_seat_assigned and (not config_dict["ocr_captcha"]["enable"] or is_captcha_sent):
        try:
            # 4.1: Click submit button - UTK0205 uses addShoppingCart() function
            result = await tab.evaluate('''
                (function() {
                    // Method 1: Try calling addShoppingCart() directly (most reliable)
                    if (typeof addShoppingCart === 'function') {
                        addShoppingCart();
                        return true;
                    }
                    // Method 2: Find button inside the addcart anchor
                    const addcartBtn = document.querySelector('a#addcart button');
                    if (addcartBtn && !addcartBtn.disabled) {
                        addcartBtn.click();
                        return true;
                    }
                    // Method 3: Find button with onclick containing addShoppingCart
                    const btnWithOnclick = document.querySelector('button[onclick*="addShoppingCart"]');
                    if (btnWithOnclick && !btnWithOnclick.disabled) {
                        btnWithOnclick.click();
                        return true;
                    }
                    // Method 4: Legacy selector for other KHAM pages
                    const button = document.querySelector('button.sumitButton');
                    if (button && !button.disabled) {
                        button.click();
                        return true;
                    }
                    return false;
                })();
            ''')

            # Convert CDP format (boolean)
            if isinstance(result, list) and len(result) == 2:
                is_submit_success = result[1].get('value', False) if isinstance(result[1], dict) else result
            else:
                is_submit_success = result

            if is_submit_success:
                if show_debug:
                    print("[KHAM SUBMIT] Order submitted successfully")

                # 4.2: Wait for and close success dialog with improved logic + fallback
                dialog_closed = False

                # Initial wait for dialog to appear (1.5 seconds)
                await tab.sleep(1.5)
                if show_debug:
                    print("[KHAM SUBMIT] Initial wait completed, now checking for dialog...")

                for i in range(16):  # 16 attempts * 0.5s = 8 seconds
                    await tab.sleep(0.5)
                    try:
                        # Use JavaScript to check dialog and close (improved selectors)
                        result = await tab.evaluate('''
                            (function() {
                                // Check if dialog exists (multiple selectors)
                                const dialog = document.querySelector('div.ui-dialog');
                                if (dialog) {
                                    // Try multiple button selectors - be more specific
                                    // Selector 1: Class-based (most specific)
                                    let btn = document.querySelector('button.ui-button.ui-corner-all.ui-widget');
                                    // Selector 2: Dialog buttonset
                                    if (!btn) btn = document.querySelector('.ui-dialog-buttonset button');
                                    // Selector 3: Any button in dialog
                                    if (!btn) btn = document.querySelector('div.ui-dialog button');

                                    if (btn) {
                                        // Click the button
                                        btn.click();
                                        return {found: true, clicked: true};
                                    }
                                    return {found: true, clicked: false};
                                }
                                return {found: false, clicked: false};
                            })();
                        ''')

                        # Convert CDP format
                        if isinstance(result, list) and len(result) == 2:
                            result_dict = result[1].get('value', {}) if isinstance(result[1], dict) else {}
                        else:
                            result_dict = result if isinstance(result, dict) else {}

                        dialog_found = result_dict.get('found', False)
                        dialog_clicked = result_dict.get('clicked', False)

                        if show_debug:
                            print(f"[KHAM SUBMIT] Dialog check #{i+1}: found={dialog_found}, clicked={dialog_clicked}")

                        if dialog_found and dialog_clicked:
                            if show_debug:
                                print("[KHAM SUBMIT] Dialog found and clicked via JavaScript")
                            await tab.sleep(0.5)

                            # Verify dialog actually closed (important for stability)
                            verify_result = await tab.evaluate('''
                                (function() {
                                    const dialog = document.querySelector('div.ui-dialog');
                                    return {exists: dialog !== null};
                                })();
                            ''')

                            if isinstance(verify_result, list) and len(verify_result) == 2:
                                verify_dict = verify_result[1].get('value', {}) if isinstance(verify_result[1], dict) else {}
                            else:
                                verify_dict = verify_result if isinstance(verify_result, dict) else {}

                            if not verify_dict.get('exists', True):
                                dialog_closed = True
                                if show_debug:
                                    print("[KHAM SUBMIT] Dialog close verified - dialog no longer exists")
                                break
                            else:
                                if show_debug:
                                    print("[KHAM SUBMIT] Dialog still exists after click attempt, retrying...")
                        elif dialog_found and not dialog_clicked:
                            if show_debug:
                                print("[KHAM SUBMIT] Dialog found but button click failed, retrying...")
                        elif not dialog_found and i % 4 == 0 and show_debug:
                            # Log periodically that we're still searching
                            print(f"[KHAM SUBMIT] Still searching for dialog... (attempt {i+1}/16)")

                    except Exception as e:
                        if show_debug:
                            print(f"[KHAM SUBMIT] Dialog check #{i+1} exception: {e}")

                if not dialog_closed and show_debug:
                    print("[KHAM SUBMIT] Dialog detection incomplete - will proceed with fallback URL check")

                # 4.3: Always check for page transition (fallback) - regardless of dialog detection
                # This is more reliable than waiting for dialog to close
                if show_debug:
                    print("[KHAM SUBMIT] Checking for page transition (fallback)...")

                current_url = tab.target.url
                if show_debug:
                    print(f"[KHAM SUBMIT] Current URL: {current_url}")

                # Check if URL changed (maximum 15 seconds wait - more generous fallback)
                url_changed = False
                for i in range(30):  # 30 attempts * 0.5s = 15 seconds (extended from 10s)
                    await tab.sleep(0.5)
                    new_url = tab.target.url
                    if new_url != current_url:
                        if show_debug:
                            print(f"[KHAM SUBMIT] Page transitioned successfully")
                            print(f"[KHAM SUBMIT] New URL: {new_url}")
                        url_changed = True
                        break

                if not url_changed:
                    if show_debug:
                        print("[KHAM SUBMIT] URL did not change after submit")
                        print("[KHAM SUBMIT] Note: KHAM may not auto-redirect - this may be normal")
                        print("[KHAM SUBMIT] Proceeding anyway as submit button was clicked")

                # 4.4: Play sound if enabled
                if config_dict["advanced"]["play_sound"]["order"]:
                    play_sound_while_ordering(config_dict)

        except Exception as exc:
            if show_debug:
                print(f"[ERROR] KHAM submit exception: {exc}")
            # Fallback: use JavaScript to force submit
            try:
                await tab.evaluate('addShoppingCart();')
                is_submit_success = True
                if config_dict["advanced"]["play_sound"]["order"]:
                    play_sound_while_ordering(config_dict)
                if show_debug:
                    print("[KHAM SUBMIT] Submitted via fallback method")
            except Exception as exc2:
                if show_debug:
                    print(f"[ERROR] KHAM fallback submit error: {exc2}")

    if show_debug:
        print(f"[KHAM SEAT MAIN] Type:{is_seat_type_assigned} "
              f"Seat:{is_seat_assigned} Submit:{is_submit_success}")

    return is_submit_success


# ====================================================================================
# UDN Platform Seat Selection (Feature 010: UDN seat auto select)
# UTK0204 page combines area selection and seat map on the same page
# ====================================================================================

async def nodriver_udn_seat_auto_select(tab, config_dict):
    """
    UDN - UTK0204 座位自動選擇

    UDN 的 UTK0204 頁面同時包含區域選擇和座位地圖。
    點擊區域後，座位地圖會在同一頁面顯示。

    座位元素結構（透過 MCP 測試驗證）：
    - 選擇器：td[title*="排"]
    - 格式：{區域}-{排號}排-{座號}號（如：特B區-10排-19號）
    - 可選座位：background-image 包含 icon_chair_empty_1.gif
    - 已售座位：background-image 包含 icon_chair_sale_1.gif
    """
    is_seat_assigned = False
    ticket_number = config_dict["ticket_number"]
    show_debug = config_dict["advanced"].get("verbose", False)

    try:
        import json
        result = await tab.evaluate(f'''
            (function() {{
                const ticketNumber = {ticket_number};
                const showDebug = {json.dumps(show_debug)};

                // Step 1: Find all seat elements with title containing "排"
                const allSeats = document.querySelectorAll('td[title*="排"]');
                if (allSeats.length === 0) {{
                    if (showDebug) console.log('[UDN SEAT] No seat map found');
                    return {{ success: false, reason: 'no_seat_map', found: 0, selected: 0 }};
                }}

                // Step 2: Filter available seats by background image
                const availableSeats = [];
                allSeats.forEach(seat => {{
                    const style = seat.getAttribute('style') || '';
                    if (style.includes('icon_chair_empty_1.gif')) {{
                        const title = seat.getAttribute('title');
                        if (title && title.includes('排') && title.includes('號')) {{
                            // Parse seat info: {區域}-{排號}排-{座號}號
                            const parts = title.split('-');
                            if (parts.length >= 3) {{
                                const areaName = parts[0];
                                const rowMatch = parts[1].match(/(\d+)排/);
                                const seatMatch = parts[2].match(/(\d+)號/);
                                if (rowMatch && seatMatch) {{
                                    availableSeats.push({{
                                        element: seat,
                                        title: title,
                                        area: areaName,
                                        row: parseInt(rowMatch[1]),
                                        seat: parseInt(seatMatch[1])
                                    }});
                                }}
                            }}
                        }}
                    }}
                }});

                if (showDebug) {{
                    console.log('[UDN SEAT] Total seats: ' + allSeats.length);
                    console.log('[UDN SEAT] Available seats: ' + availableSeats.length);
                }}

                if (availableSeats.length === 0) {{
                    return {{ success: false, reason: 'no_available_seats', found: allSeats.length, selected: 0 }};
                }}

                if (availableSeats.length < ticketNumber) {{
                    return {{ success: false, reason: 'not_enough_seats', found: availableSeats.length, needed: ticketNumber, selected: 0 }};
                }}

                // Step 3: Sort by row (ascending) then by seat number (prefer middle)
                // Strategy: Front rows first, middle seats preferred
                availableSeats.sort((a, b) => {{
                    if (a.row !== b.row) return a.row - b.row;
                    // For same row, calculate distance from middle
                    // Assume middle seat is around 25 (based on typical venue layout)
                    const midSeat = 25;
                    const distA = Math.abs(a.seat - midSeat);
                    const distB = Math.abs(b.seat - midSeat);
                    return distA - distB;
                }});

                // Step 4: Select seats (up to ticketNumber)
                const selectedSeats = [];
                for (let i = 0; i < Math.min(ticketNumber, availableSeats.length); i++) {{
                    const seatInfo = availableSeats[i];
                    seatInfo.element.click();
                    selectedSeats.push(seatInfo.title);
                    if (showDebug) {{
                        console.log('[UDN SEAT] Clicked seat: ' + seatInfo.title);
                    }}
                }}

                return {{
                    success: true,
                    found: availableSeats.length,
                    selected: selectedSeats.length,
                    seats: selectedSeats
                }};
            }})();
        ''')

        if result and result.get('success'):
            is_seat_assigned = True
            if show_debug:
                print(f"[UDN SEAT] Selected {result.get('selected')} seats: {result.get('seats')}")
        else:
            if show_debug:
                reason = result.get('reason', 'unknown') if result else 'no_result'
                print(f"[UDN SEAT] Selection failed: {reason}")

    except Exception as exc:
        if show_debug:
            print(f"[ERROR] UDN seat selection error: {exc}")
            import traceback
            traceback.print_exc()

    return is_seat_assigned


async def nodriver_udn_seat_select_ticket_type(tab, config_dict):
    """
    UDN - 選擇票種並加入購物車

    點擊座位後，頁面會顯示：
    1. 已選座位資訊（如：特B區-10排-19號）
    2. 票種選擇 combobox
    3. 「加入購物車 Add to Cart」按鈕
    """
    is_success = False
    show_debug = config_dict["advanced"].get("verbose", False)

    try:
        import json
        result = await tab.evaluate(f'''
            (function() {{
                const showDebug = {json.dumps(show_debug)};

                // Step 1: Find ticket type combobox
                // UDN uses <select> element for ticket type selection
                const comboboxes = document.querySelectorAll('select');
                let ticketTypeSelect = null;

                for (const select of comboboxes) {{
                    const options = select.querySelectorAll('option');
                    for (const opt of options) {{
                        // Look for price pattern like "全票-NT$1,880"
                        if (opt.textContent.includes('NT$') || opt.textContent.includes('票')) {{
                            ticketTypeSelect = select;
                            break;
                        }}
                    }}
                    if (ticketTypeSelect) break;
                }}

                if (!ticketTypeSelect) {{
                    if (showDebug) console.log('[UDN TICKET] No ticket type select found');
                    return {{ success: false, reason: 'no_ticket_select' }};
                }}

                // Step 2: Select first valid ticket type (skip "請選擇" placeholder)
                const options = ticketTypeSelect.querySelectorAll('option');
                let selectedOption = null;
                for (const opt of options) {{
                    if (opt.textContent.includes('NT$') && !opt.textContent.includes('請選擇')) {{
                        opt.selected = true;
                        ticketTypeSelect.value = opt.value;
                        // Trigger change event
                        ticketTypeSelect.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        selectedOption = opt.textContent;
                        break;
                    }}
                }}

                if (!selectedOption) {{
                    if (showDebug) console.log('[UDN TICKET] No valid ticket type option found');
                    return {{ success: false, reason: 'no_valid_option' }};
                }}

                if (showDebug) {{
                    console.log('[UDN TICKET] Selected ticket type: ' + selectedOption);
                }}

                // Step 3: Find and click "加入購物車" button
                const buttons = document.querySelectorAll('button, input[type="button"], input[type="submit"]');
                let addToCartBtn = null;
                for (const btn of buttons) {{
                    const text = btn.textContent || btn.value || '';
                    if (text.includes('加入購物車') || text.includes('Add to Cart')) {{
                        addToCartBtn = btn;
                        break;
                    }}
                }}

                if (!addToCartBtn) {{
                    if (showDebug) console.log('[UDN TICKET] No add to cart button found');
                    return {{ success: false, reason: 'no_cart_button', ticketType: selectedOption }};
                }}

                // Click the button
                addToCartBtn.click();
                if (showDebug) {{
                    console.log('[UDN TICKET] Clicked add to cart button');
                }}

                return {{
                    success: true,
                    ticketType: selectedOption,
                    buttonClicked: true
                }};
            }})();
        ''')

        if result and result.get('success'):
            is_success = True
            if show_debug:
                print(f"[UDN TICKET] Added to cart: {result.get('ticketType')}")

            # Wait for dialog and dismiss it
            await tab.sleep(0.5)
            try:
                dialog_result = await tab.evaluate('''
                    (function() {
                        // Find dialog with "完成加入購物車" message
                        const dialogs = document.querySelectorAll('[role="dialog"], .ui-dialog');
                        for (const dialog of dialogs) {
                            const text = dialog.textContent || '';
                            if (text.includes('完成加入購物車') || text.includes('購物車')) {
                                // Find OK button
                                const buttons = dialog.querySelectorAll('button');
                                for (const btn of buttons) {
                                    const btnText = btn.textContent || '';
                                    if (btnText.includes('Ok') || btnText.includes('確定') || btnText === 'Ok') {
                                        btn.click();
                                        return { dismissed: true };
                                    }
                                }
                            }
                        }
                        return { dismissed: false };
                    })();
                ''')
                if show_debug and dialog_result:
                    print(f"[UDN TICKET] Dialog dismissed: {dialog_result.get('dismissed')}")
            except Exception as dialog_exc:
                if show_debug:
                    print(f"[UDN TICKET] Dialog dismiss error (may be normal): {dialog_exc}")

        else:
            if show_debug:
                reason = result.get('reason', 'unknown') if result else 'no_result'
                print(f"[UDN TICKET] Failed: {reason}")

    except Exception as exc:
        if show_debug:
            print(f"[ERROR] UDN ticket type selection error: {exc}")
            import traceback
            traceback.print_exc()

    return is_success


async def nodriver_udn_seat_main(tab, config_dict):
    """
    UDN UTK0204 座位選擇主流程

    流程（透過 MCP 測試驗證）：
    1. 偵測座位地圖是否存在
    2. 選擇可用座位
    3. 選擇票種
    4. 加入購物車
    5. 處理確認對話框

    Returns:
        bool: True if successfully added to cart
    """
    show_debug = config_dict["advanced"].get("verbose", False)
    is_success = False

    # Check if seat map is present
    try:
        seat_map_check_raw = await tab.evaluate('''
            (function() {
                const seats = document.querySelectorAll('td[title*="排"]');
                const availableSeats = Array.from(seats).filter(s => {
                    const style = s.getAttribute('style') || '';
                    return style.includes('icon_chair_empty_1.gif');
                });
                return {
                    hasSeatMap: seats.length > 0,
                    totalSeats: seats.length,
                    availableSeats: availableSeats.length
                };
            })();
        ''')
        seat_map_check = util.parse_nodriver_result(seat_map_check_raw)

        if not seat_map_check or not seat_map_check.get('hasSeatMap'):
            if show_debug:
                print("[UDN SEAT MAIN] No seat map detected on this page")
            return False

        if show_debug:
            print(f"[UDN SEAT MAIN] Seat map found: {seat_map_check.get('totalSeats')} total, "
                  f"{seat_map_check.get('availableSeats')} available")

        if seat_map_check.get('availableSeats', 0) == 0:
            if show_debug:
                print("[UDN SEAT MAIN] No available seats")
            return False

    except Exception as exc:
        if show_debug:
            print(f"[UDN SEAT MAIN] Error checking seat map: {exc}")
        return False

    # Step 1: Select seats
    is_seat_selected = await nodriver_udn_seat_auto_select(tab, config_dict)

    if not is_seat_selected:
        if show_debug:
            print("[UDN SEAT MAIN] Seat selection failed")
        return False

    # Wait for UI to update after seat selection
    await tab.sleep(0.3)

    # Step 2: Select ticket type and add to cart
    is_success = await nodriver_udn_seat_select_ticket_type(tab, config_dict)

    if show_debug:
        print(f"[UDN SEAT MAIN] Result: seat_selected={is_seat_selected}, added_to_cart={is_success}")

    return is_success


async def nodriver_ticket_seat_type_auto_select(tab, config_dict, area_keyword_item):
    """
    年代售票 - 自動選擇票別 (UTK0205 座位選擇頁面)
    選擇票價類型，如原價、身障、陪同者等

    [TESTED] 已完整測試 - CDP DOMSnapshot 穿透驗證
    [TESTED] 已完整測試 - 排除關鍵字支援 (FR-022)
    [TESTED] 已完整測試 - 三層關鍵字匹配邏輯

    Reference: chrome_tixcraft.py Line 8957-9048
    使用 CDP DOMSnapshot 穿透 DOM 結構，避免 JavaScript 載入時機問題
    """
    # 函數開始檢查暫停 [T004修正]
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_seat_type_assigned = False

    # Clean keyword quotes
    # NOTE: This function only supports single keyword or space-separated AND logic (e.g., "VIP 區")
    # For multiple keywords with OR logic, caller should use JSON parsing and iterate
    if area_keyword_item and len(area_keyword_item) > 0:
        try:
            area_keyword_clean = area_keyword_item.strip()
            if area_keyword_clean.startswith('"') and area_keyword_clean.endswith('"'):
                area_keyword_clean = area_keyword_clean[1:-1]

            # Use the cleaned keyword directly (no comma split to avoid incorrect AND logic)
            area_keyword_item = area_keyword_clean
        except Exception as e:
            if show_debug_message:
                print(f"[TICKET SEAT TYPE] Keyword parse error: {e}")

    try:
        from nodriver import cdp

        # Step 1: Capture DOM snapshot
        if show_debug_message:
            print("[TICKET SEAT TYPE] Capturing DOM snapshot...")

        documents, strings = await tab.send(cdp.dom_snapshot.capture_snapshot(
            computed_styles=[],
            include_dom_rects=True
        ))

        # Step 2: Search for ticket type buttons
        ticket_buttons = []

        if documents and len(documents) > 0:
            document_snapshot = documents[0]
            nodes = document_snapshot.nodes

            # Extract node information
            node_names = [strings[i] for i in nodes.node_name]
            node_values = [strings[i] if i >= 0 else '' for i in nodes.node_value]
            attributes_list = nodes.attributes
            backend_node_ids = list(nodes.backend_node_id)

            if show_debug_message:
                print(f"[TICKET SEAT TYPE] Total nodes in snapshot: {len(node_names)}")

            # Step 3: Search for buttons with setType onclick
            for i, node_name in enumerate(node_names):
                if node_name.upper() == 'BUTTON':
                    # Parse attributes
                    attrs = {}
                    if i < len(attributes_list):
                        attr_indices = attributes_list[i]
                        for j in range(0, len(attr_indices), 2):
                            if j + 1 < len(attr_indices):
                                key = strings[attr_indices[j]]
                                val = strings[attr_indices[j + 1]]
                                attrs[key] = val

                    # Check if this is a ticket type button (onclick contains setType)
                    onclick = attrs.get('onclick', '')
                    button_class = attrs.get('class', '')
                    button_disabled = 'disabled' in attrs

                    if 'setType' in onclick:
                        # Get button text from child text nodes
                        # Strategy 1: Search for first non-empty text node in children
                        button_text = ''
                        for j in range(i + 1, min(i + 10, len(node_names))):  # Check next 10 nodes
                            if node_names[j] == '#text':
                                text_content = node_values[j].strip()
                                if text_content and len(text_content) > 0:
                                    button_text = text_content
                                    if show_debug_message:
                                        print(f"[TICKET SEAT TYPE] Extracted text from node {j}: '{button_text}'")
                                    break
                            # Stop when encountering another element (DIV, BUTTON, etc.)
                            elif node_names[j] in ['DIV', 'BUTTON', 'INPUT', 'SPAN', 'A']:
                                break

                        # Strategy 2: Fallback - Extract from onclick attribute if text is empty
                        if not button_text and 'setType' in onclick:
                            import re
                            match = re.search(r"setType\('[^']*','([^']*)'\)", onclick)
                            if match:
                                button_text = match.group(1)
                                if show_debug_message:
                                    print(f"[TICKET SEAT TYPE] Extracted text from onclick: '{button_text}'")

                        ticket_buttons.append({
                            'backend_node_id': backend_node_ids[i],
                            'class': button_class,
                            'onclick': onclick,
                            'disabled': button_disabled,
                            'text': button_text,
                            'index': i
                        })

                        if show_debug_message:
                            print(f"[TICKET SEAT TYPE] Found button #{len(ticket_buttons)}: text='{button_text}', disabled={button_disabled}")

        if show_debug_message:
            print(f"[TICKET SEAT TYPE] Found {len(ticket_buttons)} ticket type button(s)")

        if len(ticket_buttons) == 0:
            if show_debug_message:
                print("[TICKET SEAT TYPE] No ticket type buttons found")
            return False

        # Step 4: Filter disabled buttons
        enabled_buttons = [btn for btn in ticket_buttons if not btn['disabled']]

        if show_debug_message:
            print(f"[TICKET SEAT TYPE] Found {len(enabled_buttons)} enabled button(s)")

        if len(enabled_buttons) == 0:
            if show_debug_message:
                print("[TICKET SEAT TYPE] All buttons are disabled")
            return False

        # Step 5: Match button using keyword and exclusion logic
        matched_button = None

        for button in enabled_buttons:
            button_text = button['text']
            if not button_text:
                continue

            # Check exclusion keywords from config
            if util.reset_row_text_if_match_keyword_exclude(config_dict, button_text):
                if show_debug_message:
                    print(f"[TICKET SEAT TYPE] Excluded by keyword_exclude: {button_text}")
                continue

            # Keyword matching logic
            is_match = True
            if area_keyword_item and len(area_keyword_item) > 0:
                keywords = area_keyword_item.split(' ')
                row_text = util.format_keyword_string(button_text)
                for kw in keywords:
                    formatted_kw = util.format_keyword_string(kw)
                    if formatted_kw not in row_text:
                        is_match = False
                        break

            if is_match:
                matched_button = button
                if show_debug_message:
                    print(f"[TICKET SEAT TYPE] Matched: {button_text}")
                break

        # If no keyword match, select first enabled button as fallback
        if matched_button is None:
            matched_button = enabled_buttons[0]
            if show_debug_message:
                print(f"[TICKET SEAT TYPE] No keyword match, using first button: {matched_button['text']}")

        # Step 6: Click button using CDP
        try:
            # Initialize DOM
            await tab.send(cdp.dom.get_document())

            # Convert backend_node_id to node_id
            result = await tab.send(cdp.dom.push_nodes_by_backend_ids_to_frontend([matched_button['backend_node_id']]))
            node_id = result[0]

            if show_debug_message:
                print(f"[TICKET SEAT TYPE] Button node_id: {node_id}")

            # Scroll element into view
            await tab.send(cdp.dom.scroll_into_view_if_needed(node_id=node_id))
            await tab.sleep(0.2)

            # Use CDP Runtime.callFunctionOn to click button
            from nodriver.cdp import runtime

            # Resolve node to RemoteObject
            resolved = await tab.send(cdp.dom.resolve_node(node_id=node_id))

            # Get object_id from resolved node
            if hasattr(resolved, 'object'):
                remote_object_id = resolved.object.object_id
            elif hasattr(resolved, 'object_id'):
                remote_object_id = resolved.object_id
            else:
                if show_debug_message:
                    print(f"[TICKET SEAT TYPE] Error: Could not find object_id in resolved node")
                return False

            if show_debug_message:
                print(f"[TICKET SEAT TYPE] Resolved button object_id: {remote_object_id}")

            # Call click() on the remote object
            click_result = await tab.send(runtime.call_function_on(
                function_declaration='function() { this.click(); return true; }',
                object_id=remote_object_id,
                return_by_value=True
            ))

            if show_debug_message:
                print(f"[TICKET SEAT TYPE] Button clicked, result: {click_result}")

            if click_result:
                is_seat_type_assigned = True
                if show_debug_message:
                    print(f"[TICKET SEAT TYPE] Successfully clicked: {matched_button['text']}")

                # Wait for seat table to load (initial wait for AJAX to start)
                await tab.sleep(1.5)

                # [Optimized] Smart wait using lightweight querySelector instead of DOM Snapshot
                seats_loaded = False
                for i in range(20):  # Max 10 seconds (20 * 0.5s)
                    try:
                        # Use querySelector - 10x faster than DOM Snapshot
                        check_result = await tab.evaluate('''
                            (() => {
                                const table = document.querySelector('#TBL');
                                // Check for TD with title attribute and cursor:pointer style
                                const seats = document.querySelectorAll('#TBL td[title][style*="cursor: pointer"]');
                                return {
                                    tableFound: !!table,
                                    seatCount: seats.length
                                };
                            })()
                        ''')

                        # Parse result using util function for nodriver CDP format
                        table_found = False
                        seat_count = 0
                        parsed_result = util.parse_nodriver_result(check_result)
                        if isinstance(parsed_result, dict):
                            table_found = parsed_result.get('tableFound', False)
                            seat_count = parsed_result.get('seatCount', 0)

                        # Success condition: table exists AND at least 1 seat found
                        if table_found and seat_count > 0:
                            seats_loaded = True
                            if show_debug_message:
                                print(f"[TICKET SEAT TYPE] Seats loaded: table found, {seat_count} available seats")
                            break
                        elif i == 19 and show_debug_message:
                            # Last attempt - show what's missing
                            print(f"[TICKET SEAT TYPE] Warning: table_found={table_found}, seat_count={seat_count}")

                    except Exception as wait_exc:
                        if show_debug_message and i == 19:
                            print(f"[TICKET SEAT TYPE] querySelector error: {wait_exc}")

                    await tab.sleep(0.5)

                if not seats_loaded and show_debug_message:
                    print("[TICKET SEAT TYPE] Warning: Seats not fully loaded within 10 seconds")
            else:
                if show_debug_message:
                    print("[TICKET SEAT TYPE] Click failed")

        except Exception as click_exc:
            if show_debug_message:
                print(f"[ERROR] CDP click error: {click_exc}")
                import traceback
                traceback.print_exc()

    except Exception as exc:
        if show_debug_message:
            print(f"[ERROR] Ticket seat type selection error: {exc}")
        import traceback
        if show_debug_message:
            traceback.print_exc()

    if show_debug_message:
        print(f"[TICKET SEAT TYPE] Assignment result: {is_seat_type_assigned}")

    return is_seat_type_assigned


async def _analyze_seat_quality(tab, config_dict):
    """
    分析座位品質並篩選候選排/列
    職責: 偵測舞台方向、分析座位品質、排優先度排序
    行數: ~32 行

    Returns: dict 包含舞台方向、座位資訊、品質評分
    """
    ticket_number = config_dict["ticket_number"]
    allow_non_adjacent = config_dict["advanced"]["disable_adjacent_seat"]
    show_debug = config_dict["advanced"].get("verbose", False)

    import json
    # 執行 JavaScript 分析座位品質
    result = await tab.evaluate(f'''
        (function() {{
            const ticketNumber = {ticket_number};
            const allowNonAdjacent = {json.dumps(allow_non_adjacent)};
            const showDebug = {json.dumps(show_debug)};
            const MIDDLE_AREA_MIN = 8;
            const MIDDLE_AREA_MAX = 18;

            // 偵測舞台方向
            const stageIcon = document.querySelector('#ctl00_ContentPlaceHolder1_lbStageArrow i');
            let stageDirection = 'up';

            if (showDebug) {{
                console.log('[TICKET SEAT] Stage icon element:', stageIcon ? 'found' : 'not found');
            }}

            if (stageIcon) {{
                if (stageIcon.classList.contains('fa-arrow-circle-up')) stageDirection = 'up';
                else if (stageIcon.classList.contains('fa-arrow-circle-down')) stageDirection = 'down';
                else if (stageIcon.classList.contains('fa-arrow-circle-left')) stageDirection = 'left';
                else if (stageIcon.classList.contains('fa-arrow-circle-right')) stageDirection = 'right';

                if (showDebug) {{
                    console.log('[TICKET SEAT] Detected stage direction:', stageDirection);
                }}
            }} else {{
                if (showDebug) {{
                    console.log('[TICKET SEAT] Stage icon not found, using default: up');
                }}
            }}

            // 【修復 1】取得所有可用座位 - 改用 JavaScript 過濾而不依賴 CSS 屬性選擇器
            const availableSeats = [];
            const allTableRows = document.querySelectorAll('table#TBL tbody tr, #locationChoice table tbody tr');

            Array.from(allTableRows).forEach(tr => {{
                const allTds = tr.children;
                for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                    const seat = allTds[colIndex];
                    const style = seat.getAttribute('style');
                    const title = seat.getAttribute('title');

                    // 使用 JavaScript 檢查（更可靠）
                    if (style && title &&
                        style.includes('cursor: pointer') &&
                        style.includes('icon_chair_empty')) {{
                        availableSeats.push(seat);
                    }}
                }}
            }});

            if (showDebug) {{
                console.log('[TICKET SEAT] Stage: ' + stageDirection + ', Available: ' + availableSeats.length);
            }}

            return {{
                direction: stageDirection,
                availableSeats: availableSeats.map(s => s.getAttribute('title')),
                totalSeats: availableSeats.length
            }};
        }})();
    ''')

    # 轉換 CDP 格式 using util function
    result_dict = util.parse_nodriver_result(result) if not isinstance(result, dict) else result
    return result_dict if isinstance(result_dict, dict) else {}


async def _find_best_seats_in_row(tab, seat_analysis, config_dict):
    """
    在候選排/列中尋找最佳座位組合
    職責: 分組座位、分析品質、排優先度排序、搜尋最佳組合
    行數: ~35 行

    Args: seat_analysis 來自 _analyze_seat_quality 的結果
    Returns: dict 包含選定的座位集合
    """
    ticket_number = config_dict["ticket_number"]
    allow_non_adjacent = config_dict["advanced"]["disable_adjacent_seat"]
    show_debug = config_dict["advanced"].get("verbose", False)

    stage_direction = seat_analysis.get('direction', 'up')
    available_titles = seat_analysis.get('availableSeats', [])

    if show_debug:
        print(f"[TICKET SEAT] Finding best seats: tickets={ticket_number}, "
              f"stage={stage_direction}, adjacent={not allow_non_adjacent}, "
              f"available={len(available_titles)}")

    import json
    # 執行 JavaScript 尋找最佳座位
    result = await tab.evaluate(f'''
        (function() {{
            const ticketNumber = {ticket_number};
            const allowNonAdjacent = {json.dumps(allow_non_adjacent)};
            const showDebug = {json.dumps(show_debug)};
            const stageDirection = {json.dumps(stage_direction)};
            const MIDDLE_AREA_MIN = 8;
            const MIDDLE_AREA_MAX = 18;

            if (showDebug) {{
                console.log('[TICKET SEAT] Starting seat selection algorithm...');
                console.log('[TICKET SEAT] DOM position tracking enabled for aisle detection');
            }}

            // 取得所有可用座位 - 使用與 _analyze_seat_quality 一致的選擇器
            const availableSeats = [];
            const allTableRowsCheck = document.querySelectorAll('table#TBL tbody tr, #locationChoice table tbody tr');
            Array.from(allTableRowsCheck).forEach(tr => {{
                const allTds = tr.children;
                for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                    const seat = allTds[colIndex];
                    const style = seat.getAttribute('style');
                    const title = seat.getAttribute('title');
                    if (style && title && style.includes('cursor: pointer') && style.includes('icon_chair_empty')) {{
                        availableSeats.push(seat);
                    }}
                }}
            }});

            if (showDebug) {{
                console.log('[TICKET SEAT] Available seats found: ' + availableSeats.length);
            }}

            if (availableSeats.length < ticketNumber) {{
                return {{ success: false, found: availableSeats.length, selected: 0, reason: 'not_enough_seats' }};
            }}

            // 根據舞台方向分組及分析品質
            const selectedSeats = [];
            if (stageDirection === 'up' || stageDirection === 'down') {{
                // 按排分組（加入 DOM 位置追蹤）
                const rows = {{}};
                const allTableRows = document.querySelectorAll('table#TBL tbody tr, #locationChoice table tbody tr');

                Array.from(allTableRows).forEach((tr, rowIndexInTable) => {{
                    const allTds = tr.children;
                    for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                        const seat = allTds[colIndex];
                        const style = seat.getAttribute('style');
                        const title = seat.getAttribute('title');

                        // 檢查是否為可選座位
                        if (style && title &&
                            style.includes('cursor: pointer') &&
                            style.includes('icon_chair_empty')) {{

                            if (title.includes('排') && title.includes('號')) {{
                                const parts = title.split('-');
                                if (parts.length >= 3) {{
                                    const rowNum = parseInt(parts[1].replace('排', ''));
                                    const seatNum = parseInt(parts[2].replace('號', ''));
                                    if (!rows[rowNum]) rows[rowNum] = [];

                                    // 【改進 1】記錄真實 DOM 位置
                                    rows[rowNum].push({{
                                        elem: seat,
                                        num: seatNum,
                                        title: title,
                                        domIndex: colIndex  // 新增：true 列位置用於走道偵測
                                    }});
                                }}
                            }}
                        }}
                    }}
                }});

                if (showDebug) {{
                    console.log('[TICKET SEAT] Rows grouped: ' + Object.keys(rows).length);
                }}

                // 分析品質並排序
                const rowQuality = [];
                for (const [rowNum, rowSeats] of Object.entries(rows)) {{
                    rowSeats.sort((a, b) => a.num - b.num);
                    const totalSeats = rowSeats.length;
                    const middleSeats = rowSeats.filter(s => s.num >= MIDDLE_AREA_MIN && s.num <= MIDDLE_AREA_MAX);
                    const middleCount = middleSeats.length;
                    const middleRatio = totalSeats > 0 ? middleCount / totalSeats : 0;

                    rowQuality.push({{
                        rowNum: parseInt(rowNum),
                        totalSeats: totalSeats,
                        middleCount: middleCount,
                        middleRatio: middleRatio,
                        seats: rowSeats,
                        middleSeats: middleSeats
                    }});
                }}

                // 三層優先度排序
                rowQuality.sort((a, b) => {{
                    const aHasEnough = a.middleCount >= ticketNumber;
                    const bHasEnough = b.middleCount >= ticketNumber;
                    if (aHasEnough && !bHasEnough) return -1;
                    if (!aHasEnough && bHasEnough) return 1;

                    if (Math.abs(a.middleRatio - b.middleRatio) > 0.1) {{
                        return b.middleRatio - a.middleRatio;
                    }}

                    if (stageDirection === 'up') {{
                        return a.rowNum - b.rowNum;
                    }} else {{
                        return b.rowNum - a.rowNum;
                    }}
                }});

                if (showDebug) {{
                    console.log('[TICKET SEAT] RowQuality count: ' + rowQuality.length);
                    if (rowQuality.length > 0) {{
                        console.log('[TICKET SEAT] First row: ' + rowQuality[0].rowNum +
                                   ', seats=' + rowQuality[0].totalSeats +
                                   ', middle=' + rowQuality[0].middleCount);
                    }}
                }}

                // 搜尋最佳座位組合
                for (const row of rowQuality) {{
                    let found = false;

                    if (!allowNonAdjacent) {{
                        // 【改進 2】先按 DOM 位置排序確保順序正確
                        row.middleSeats.sort((a, b) => a.domIndex - b.domIndex);
                        row.seats.sort((a, b) => a.domIndex - b.domIndex);

                        // 先找中間區域的連續座位
                        if (row.middleSeats.length >= ticketNumber) {{
                            for (let i = 0; i <= row.middleSeats.length - ticketNumber; i++) {{
                                let continuous = true;
                                for (let j = 0; j < ticketNumber - 1; j++) {{
                                    // 【改進 2】使用 DOM 位置差（domGap）判斷連續性
                                    const currentDomIdx = row.middleSeats[i+j].domIndex;
                                    const nextDomIdx = row.middleSeats[i+j+1].domIndex;
                                    const domGap = nextDomIdx - currentDomIdx;

                                    if (domGap > 1) {{
                                        // DOM 位置不連續（中間有走道或空格）
                                        continuous = false;
                                        if (showDebug) {{
                                            console.log('[TICKET SEAT] Aisle detected: ' +
                                                       row.middleSeats[i+j].title + ' to ' +
                                                       row.middleSeats[i+j+1].title +
                                                       ' (domGap=' + domGap + ')');
                                        }}
                                        break;
                                    }}
                                }}
                                if (continuous) {{
                                    for (let j = 0; j < ticketNumber; j++) {{
                                        selectedSeats.push(row.middleSeats[i+j]);
                                    }}
                                    found = true;
                                    if (showDebug) {{
                                        console.log('[TICKET SEAT] Selected ' + ticketNumber +
                                                   ' seats from middle area');
                                    }}
                                    break;
                                }}
                            }}
                        }}

                        // 回退到全排搜尋
                        if (!found) {{
                            for (let i = 0; i <= row.seats.length - ticketNumber; i++) {{
                                let continuous = true;
                                for (let j = 0; j < ticketNumber - 1; j++) {{
                                    // 【改進 2】使用 DOM 位置差判斷連續性
                                    const currentDomIdx = row.seats[i+j].domIndex;
                                    const nextDomIdx = row.seats[i+j+1].domIndex;
                                    const domGap = nextDomIdx - currentDomIdx;

                                    if (domGap > 1) {{
                                        continuous = false;
                                        if (showDebug && i === 0) {{
                                            console.log('[TICKET SEAT] Gap in full row: ' +
                                                       row.seats[i+j].title + ' (domGap=' + domGap + ')');
                                        }}
                                        break;
                                    }}
                                }}
                                if (continuous) {{
                                    for (let j = 0; j < ticketNumber; j++) {{
                                        selectedSeats.push(row.seats[i+j]);
                                    }}
                                    found = true;
                                    if (showDebug) {{
                                        console.log('[TICKET SEAT] Selected ' + ticketNumber +
                                                   ' seats from full row');
                                    }}
                                    break;
                                }}
                            }}
                        }}
                    }} else {{
                        // 不連續模式：從中間選起
                        if (row.middleSeats.length >= ticketNumber) {{
                            const startIdx = Math.floor((row.middleSeats.length - ticketNumber) / 2);
                            for (let i = 0; i < ticketNumber; i++) {{
                                selectedSeats.push(row.middleSeats[startIdx + i]);
                            }}
                            found = true;
                        }} else {{
                            const startIdx = Math.max(0, Math.floor((row.totalSeats - ticketNumber) / 2));
                            for (let i = 0; i < Math.min(ticketNumber, row.totalSeats); i++) {{
                                if (startIdx + i < row.seats.length) {{
                                    selectedSeats.push(row.seats[startIdx + i]);
                                }}
                            }}
                            found = true;
                        }}
                    }}

                    if (selectedSeats.length >= ticketNumber) break;
                }}
            }} else {{
                // 【改進 3】按列分組（舞台在左/右）- 加入 DOM 位置追蹤與品質分析
                const columns = {{}};
                const MIDDLE_ROW_MIN = 5;
                const MIDDLE_ROW_MAX = 15;

                // 遍歷表格，按列收集座位並記錄 DOM 垂直位置
                const allTableRows = document.querySelectorAll('table#TBL tbody tr, #locationChoice table tbody tr');
                Array.from(allTableRows).forEach((tr, rowIndexInTable) => {{
                    const allTds = tr.children;
                    for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                        const seat = allTds[colIndex];
                        const style = seat.getAttribute('style');
                        const title = seat.getAttribute('title');

                        if (style && title &&
                            style.includes('cursor: pointer') &&
                            style.includes('icon_chair_empty')) {{

                            if (title.includes('排') && title.includes('號')) {{
                                const parts = title.split('-');
                                if (parts.length >= 3) {{
                                    const rowNum = parseInt(parts[1].replace('排', ''));
                                    const seatNum = parseInt(parts[2].replace('號', ''));
                                    if (!columns[seatNum]) columns[seatNum] = [];

                                    // 記錄垂直 DOM 位置（用於垂直連續性檢查）
                                    columns[seatNum].push({{
                                        elem: seat,
                                        rowNum: rowNum,
                                        title: title,
                                        domIndex: rowIndexInTable  // 垂直位置
                                    }});
                                }}
                            }}
                        }}
                    }}
                }});

                // 分析列品質（中間排優先）
                const columnQuality = [];
                for (const [seatNum, columnSeats] of Object.entries(columns)) {{
                    columnSeats.sort((a, b) => a.domIndex - b.domIndex);
                    const totalSeats = columnSeats.length;
                    const middleSeats = columnSeats.filter(s =>
                        s.rowNum >= MIDDLE_ROW_MIN && s.rowNum <= MIDDLE_ROW_MAX
                    );
                    const middleCount = middleSeats.length;
                    const middleRatio = totalSeats > 0 ? middleCount / totalSeats : 0;

                    columnQuality.push({{
                        seatNum: parseInt(seatNum),
                        totalSeats: totalSeats,
                        middleCount: middleCount,
                        middleRatio: middleRatio,
                        seats: columnSeats,
                        middleSeats: middleSeats
                    }});
                }}

                // 三層優先度排序
                columnQuality.sort((a, b) => {{
                    const aHasEnough = a.middleCount >= ticketNumber;
                    const bHasEnough = b.middleCount >= ticketNumber;
                    if (aHasEnough && !bHasEnough) return -1;
                    if (!aHasEnough && bHasEnough) return 1;

                    if (Math.abs(a.middleRatio - b.middleRatio) > 0.1) {{
                        return b.middleRatio - a.middleRatio;
                    }}

                    // 舞台方向排序
                    if (stageDirection === 'left') {{
                        return a.seatNum - b.seatNum;  // 左舞台：小號優先
                    }} else {{
                        return b.seatNum - a.seatNum;  // 右舞台：大號優先
                    }}
                }});

                if (showDebug) {{
                    console.log('[TICKET SEAT] Left/Right stage: ' + stageDirection +
                               ', columns found: ' + columnQuality.length);
                }}

                // 搜尋最佳座位組合（兩階段搜尋 + DOM 連續性檢查）
                for (const column of columnQuality) {{
                    let found = false;

                    if (!allowNonAdjacent) {{
                        // 先找中間排的連續座位
                        if (column.middleSeats.length >= ticketNumber) {{
                            for (let i = 0; i <= column.middleSeats.length - ticketNumber; i++) {{
                                let continuous = true;
                                for (let j = 0; j < ticketNumber - 1; j++) {{
                                    const domGap = column.middleSeats[i+j+1].domIndex -
                                                  column.middleSeats[i+j].domIndex;
                                    if (domGap > 1) {{
                                        continuous = false;
                                        break;
                                    }}
                                }}
                                if (continuous) {{
                                    for (let j = 0; j < ticketNumber; j++) {{
                                        selectedSeats.push(column.middleSeats[i+j]);
                                    }}
                                    found = true;
                                    if (showDebug) {{
                                        console.log('[TICKET SEAT] Selected from middle rows');
                                    }}
                                    break;
                                }}
                            }}
                        }}

                        // 回退到全列搜尋
                        if (!found) {{
                            for (let i = 0; i <= column.seats.length - ticketNumber; i++) {{
                                let continuous = true;
                                for (let j = 0; j < ticketNumber - 1; j++) {{
                                    const domGap = column.seats[i+j+1].domIndex -
                                                  column.seats[i+j].domIndex;
                                    if (domGap > 1) {{
                                        continuous = false;
                                        break;
                                    }}
                                }}
                                if (continuous) {{
                                    for (let j = 0; j < ticketNumber; j++) {{
                                        selectedSeats.push(column.seats[i+j]);
                                    }}
                                    found = true;
                                    if (showDebug) {{
                                        console.log('[TICKET SEAT] Selected from full column');
                                    }}
                                    break;
                                }}
                            }}
                        }}
                    }} else {{
                        // 不連續模式：從中間選起
                        if (column.middleSeats.length >= ticketNumber) {{
                            const startIdx = Math.floor((column.middleSeats.length - ticketNumber) / 2);
                            for (let i = 0; i < ticketNumber; i++) {{
                                selectedSeats.push(column.middleSeats[startIdx + i]);
                            }}
                            found = true;
                        }} else {{
                            const startIdx = Math.max(0, Math.floor((column.totalSeats - ticketNumber) / 2));
                            for (let i = 0; i < Math.min(ticketNumber, column.totalSeats); i++) {{
                                if (startIdx + i < column.seats.length) {{
                                    selectedSeats.push(column.seats[startIdx + i]);
                                }}
                            }}
                            found = true;
                        }}
                    }}

                    if (selectedSeats.length >= ticketNumber) break;
                }}
            }}

            // 【跨排選座】當允許不連續座位且仍未選到足夠座位時，從所有可用座位中選擇
            if (selectedSeats.length < ticketNumber && allowNonAdjacent && availableSeats.length >= ticketNumber) {{
                if (showDebug) {{
                    console.log('[TICKET SEAT] Cross-row selection: selecting from all available seats');
                }}
                selectedSeats.length = 0; // 清空之前的結果
                // 收集所有可用座位資訊
                const allSeatsWithInfo = [];
                const crossRowTableRows = document.querySelectorAll('table#TBL tbody tr, #locationChoice table tbody tr');
                Array.from(crossRowTableRows).forEach((tr, rowIdx) => {{
                    const allTds = tr.children;
                    for (let colIdx = 0; colIdx < allTds.length; colIdx++) {{
                        const seat = allTds[colIdx];
                        const style = seat.getAttribute('style');
                        const title = seat.getAttribute('title');
                        if (style && title && style.includes('cursor: pointer') && style.includes('icon_chair_empty')) {{
                            allSeatsWithInfo.push({{ title: title, rowIdx: rowIdx, colIdx: colIdx }});
                        }}
                    }}
                }});
                // 選擇前 ticketNumber 個座位
                for (let i = 0; i < Math.min(ticketNumber, allSeatsWithInfo.length); i++) {{
                    selectedSeats.push(allSeatsWithInfo[i]);
                }}
            }}

            if (showDebug) {{
                console.log('[TICKET SEAT] Algorithm result: found=' + availableSeats.length +
                           ', selected=' + selectedSeats.length);
                if (selectedSeats.length > 0) {{
                    console.log('[TICKET SEAT] Selected titles: ' +
                               selectedSeats.map(s => s.title).join(', '));
                }}
            }}

            return {{
                success: selectedSeats.length > 0,
                selectedSeats: selectedSeats.map(s => ({{ title: s.title }})),
                count: selectedSeats.length
            }};
        }})();
    ''')

    # 轉換 CDP 格式 using util function
    result_dict = util.parse_nodriver_result(result) if not isinstance(result, dict) else result

    if show_debug:
        print(f"[TICKET SEAT] _find_best_seats result: {result_dict}")

    return result_dict if isinstance(result_dict, dict) else {}


async def _execute_seat_selection(tab, seats_to_click, config_dict):
    """
    執行座位點擊操作
    職責: 驗證座位、點擊座位、回報結果
    行數: ~48 行

    【修復 BUG-001】使用演算法選定的座位 title 列表而非簡單取前 N 個
    問題：原邏輯忽略 seats_to_click 參數，導致選到不連續座位
    解決：使用 selectedSeats 中的 title 列表精確定位並點擊

    Args: seats_to_click 來自 _find_best_seats_in_row 的座位集合
    Returns: bool 是否成功選擇座位
    """
    ticket_number = config_dict["ticket_number"]
    show_debug = config_dict["advanced"].get("verbose", False)

    # 【修復 BUG-001】提取演算法選定的座位 title 列表
    selected_seat_titles = []
    use_algorithm_result = False

    if show_debug:
        print(f"[TICKET SEAT] _execute input: type={type(seats_to_click)}, value={seats_to_click}")

    if seats_to_click and isinstance(seats_to_click, dict):
        if 'selectedSeats' in seats_to_click and seats_to_click['selectedSeats']:
            selected_seat_titles = [s['title'] for s in seats_to_click['selectedSeats']]
            use_algorithm_result = len(selected_seat_titles) > 0

            if show_debug:
                print(f"[TICKET SEAT] Using algorithm selected seats: {selected_seat_titles}")
        else:
            if show_debug:
                print(f"[TICKET SEAT] No selectedSeats in result, keys={seats_to_click.keys()}")

    import json
    # 執行 JavaScript 點擊座位
    result = await tab.evaluate(f'''
        (function() {{
            const ticketNumber = {ticket_number};
            const showDebug = {json.dumps(show_debug)};
            const selectedTitles = {json.dumps(selected_seat_titles)};
            const useAlgorithm = {json.dumps(use_algorithm_result)};

            let clickedCount = 0;
            const clickedTitles = [];

            // 【修復 BUG-001】優先使用演算法選定的座位
            if (useAlgorithm && selectedTitles.length > 0) {{
                for (const targetTitle of selectedTitles) {{
                    // 使用與 _analyze_seat_quality 一致的選擇器
                    let seat = document.querySelector(
                        `table#TBL td[title="${{targetTitle}}"][style*="cursor: pointer"]`
                    );
                    if (!seat) {{
                        seat = document.querySelector(
                            `#locationChoice table td[title="${{targetTitle}}"][style*="cursor: pointer"]`
                        );
                    }}
                    if (seat && seat.getAttribute('style').includes('icon_chair_empty')) {{
                        seat.click();
                        clickedCount++;
                        clickedTitles.push(targetTitle);
                        if (showDebug) {{
                            console.log('[SUCCESS] Selected algorithm seat: ' + targetTitle);
                        }}
                    }}
                }}
            }} else {{
                // [FALLBACK] Algorithm failed - ensure only selecting consecutive seats
                if (showDebug) {{
                    console.log('[FALLBACK] Algorithm result empty, using fallback with direction-aware check');
                }}

                // Step 1: Detect stage direction
                const stageIcon = document.querySelector('#ctl00_ContentPlaceHolder1_lbStageArrow i');
                let stageDirection = 'up'; // default
                if (stageIcon) {{
                    if (stageIcon.classList.contains('fa-arrow-circle-up')) stageDirection = 'up';
                    else if (stageIcon.classList.contains('fa-arrow-circle-down')) stageDirection = 'down';
                    else if (stageIcon.classList.contains('fa-arrow-circle-left')) stageDirection = 'left';
                    else if (stageIcon.classList.contains('fa-arrow-circle-right')) stageDirection = 'right';
                }}
                if (showDebug) {{
                    console.log('[FALLBACK] Stage direction: ' + stageDirection);
                }}

                // 使用與 _analyze_seat_quality 一致的選擇器
                const availableSeats = [];
                const allTableRowsFallback = document.querySelectorAll('table#TBL tbody tr, #locationChoice table tbody tr');
                Array.from(allTableRowsFallback).forEach(tr => {{
                    const allTds = tr.children;
                    for (let colIndex = 0; colIndex < allTds.length; colIndex++) {{
                        const seat = allTds[colIndex];
                        const style = seat.getAttribute('style');
                        const title = seat.getAttribute('title');
                        if (style && title && style.includes('cursor: pointer') && style.includes('icon_chair_empty')) {{
                            availableSeats.push(seat);
                        }}
                    }}
                }});

                let foundSeats = [];

                if (stageDirection === 'up' || stageDirection === 'down') {{
                    // Stage at top/bottom: group by ROW, consecutive = same row
                    const rows = {{}};
                    availableSeats.forEach(seat => {{
                        const title = seat.getAttribute('title');
                        if (title && title.includes('-') && title.includes('排')) {{
                            const parts = title.split('-');
                            if (parts.length >= 2) {{
                                const rowNum = parseInt(parts[1].replace('排', ''));
                                if (!rows[rowNum]) rows[rowNum] = [];
                                const parent = seat.parentElement;
                                const colIdx = parent ? Array.from(parent.children).indexOf(seat) : 0;
                                rows[rowNum].push({{ elem: seat, title: title, colIdx: colIdx }});
                            }}
                        }}
                    }});

                    // Sort rows: up=smaller first, down=larger first
                    const sortedRowNums = Object.keys(rows).sort((a, b) => {{
                        return stageDirection === 'up' ? parseInt(a) - parseInt(b) : parseInt(b) - parseInt(a);
                    }});

                    for (const rowNum of sortedRowNums) {{
                        const rowSeats = rows[rowNum];
                        rowSeats.sort((a, b) => a.colIdx - b.colIdx);

                        for (let i = 0; i <= rowSeats.length - ticketNumber; i++) {{
                            let continuous = true;
                            for (let j = 0; j < ticketNumber - 1; j++) {{
                                if (rowSeats[i + j + 1].colIdx - rowSeats[i + j].colIdx > 1) {{
                                    continuous = false;
                                    break;
                                }}
                            }}
                            if (continuous) {{
                                foundSeats = rowSeats.slice(i, i + ticketNumber);
                                break;
                            }}
                        }}
                        if (foundSeats.length >= ticketNumber) break;
                    }}
                }} else {{
                    // Stage at left/right: group by SEAT NUMBER (column), consecutive = same column
                    const columns = {{}};
                    availableSeats.forEach(seat => {{
                        const title = seat.getAttribute('title');
                        if (title && title.includes('-') && title.includes('號')) {{
                            const parts = title.split('-');
                            if (parts.length >= 3) {{
                                const seatNum = parseInt(parts[2].replace('號', ''));
                                const rowNum = parseInt(parts[1].replace('排', ''));
                                if (!columns[seatNum]) columns[seatNum] = [];
                                const parent = seat.parentElement;
                                const rowIdx = parent && parent.parentElement ?
                                    Array.from(parent.parentElement.children).indexOf(parent) : 0;
                                columns[seatNum].push({{ elem: seat, title: title, rowIdx: rowIdx, rowNum: rowNum }});
                            }}
                        }}
                    }});

                    // Sort columns: left=smaller first, right=larger first
                    const sortedColNums = Object.keys(columns).sort((a, b) => {{
                        return stageDirection === 'left' ? parseInt(a) - parseInt(b) : parseInt(b) - parseInt(a);
                    }});

                    for (const colNum of sortedColNums) {{
                        const colSeats = columns[colNum];
                        colSeats.sort((a, b) => a.rowIdx - b.rowIdx);

                        for (let i = 0; i <= colSeats.length - ticketNumber; i++) {{
                            let continuous = true;
                            for (let j = 0; j < ticketNumber - 1; j++) {{
                                if (colSeats[i + j + 1].rowIdx - colSeats[i + j].rowIdx > 1) {{
                                    continuous = false;
                                    break;
                                }}
                            }}
                            if (continuous) {{
                                foundSeats = colSeats.slice(i, i + ticketNumber);
                                break;
                            }}
                        }}
                        if (foundSeats.length >= ticketNumber) break;
                    }}
                }}

                // Click the found seats
                for (const seatObj of foundSeats) {{
                    seatObj.elem.click();
                    clickedCount++;
                    clickedTitles.push(seatObj.title);
                    if (showDebug) {{
                        console.log('[FALLBACK] Selected seat: ' + seatObj.title);
                    }}
                }}
            }}

            if (showDebug) {{
                console.log('[TICKET SEAT] Clicked ' + clickedCount + '/' + ticketNumber + ' seats');
            }}

            return {{
                success: clickedCount > 0,
                clicked: clickedCount,
                titles: clickedTitles
            }};
        }})();
    ''')

    # 轉換 CDP 格式 using util function
    result_dict = util.parse_nodriver_result(result) if not isinstance(result, dict) else result
    if not isinstance(result_dict, dict):
        result_dict = {}
    return result_dict.get('success', False)


async def nodriver_ticket_seat_auto_select(tab, config_dict):
    """
    年代售票 - 自動選擇座位，優化策略：中間區域優先 + 舞台方向智慧選座

    [TESTED] 已完整測試 - T005 函數重構驗證
    [TESTED] 已完整測試 - 舞台方向感知選座 (T007)
    [TESTED] 已完整測試 - 中間區域優先策略

    Reference: docs/02-development/ticket_seat_selection_algorithm.md

    [T005 重構] 分解為 3 個子函數協調器
    - _analyze_seat_quality(): 分析座位品質
    - _find_best_seats_in_row(): 尋找最佳座位
    - _execute_seat_selection(): 執行座位點擊
    """
    # 函數開始檢查暫停 [T004修正]
    if await check_and_handle_pause(config_dict):
        return False

    is_seat_assigned = False
    show_debug = config_dict["advanced"].get("verbose", False)

    try:
        # Step 1: 分析座位品質
        seat_analysis = await _analyze_seat_quality(tab, config_dict)

        if show_debug:
            print(f"[TICKET SEAT] Stage direction: {seat_analysis.get('direction', 'unknown')}")
            print(f"[TICKET SEAT] Found {seat_analysis.get('totalSeats', 0)} available seats")

        # Step 2: 尋找最佳座位組合
        best_seats = await _find_best_seats_in_row(tab, seat_analysis, config_dict)

        # Step 3: 執行座位選擇
        is_seat_assigned = await _execute_seat_selection(tab, best_seats, config_dict)

        if show_debug and is_seat_assigned:
            print(f"[TICKET SEAT] Selected {best_seats.get('count', 0)} seats successfully")

    except Exception as exc:
        if show_debug:
            print(f"[ERROR] Seat selection error: {exc}")
        import traceback
        if show_debug:
            traceback.print_exc()

    return is_seat_assigned


async def nodriver_ticket_seat_main(tab, config_dict, ocr, domain_name):
    """
    年代售票座位選擇主流程：票別選擇 -> 座位選擇 -> 驗證碼 -> 提交

    [TESTED] 已完整測試 - 主流程協調驗證
    [TESTED] 已完整測試 - 票別->座位->驗證碼->提交

    Reference: chrome_tixcraft.py Line 9156-9206
    """
    # 函數開始檢查暫停 [T004修正]
    if await check_and_handle_pause(config_dict):
        return False, False, False

    show_debug = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict["ticket_number"]

    # Step 0: Check if seats are already selected (avoid duplicate selection)
    already_selected_count = 0
    try:
        check_result = await tab.evaluate('''
            (() => {
                const selectedSeats = document.querySelectorAll('#TBL td[style*="icon_chair_select"]');
                return selectedSeats.length;
            })()
        ''')
        if isinstance(check_result, int):
            already_selected_count = check_result
        elif isinstance(check_result, dict):
            already_selected_count = check_result.get('value', 0)

        if show_debug:
            print(f"[TICKET SEAT] Already selected seats: {already_selected_count}")
    except Exception as exc:
        if show_debug:
            print(f"[TICKET SEAT] Error checking selected seats: {exc}")

    # If already selected enough seats, skip seat selection and go to submit
    if already_selected_count >= ticket_number:
        if show_debug:
            print(f"[TICKET SEAT] Already have {already_selected_count} seats (need {ticket_number}), skipping to submit")
        is_seat_type_assigned = True
        is_seat_assigned = True
    else:
        # Step 1: Select seat type
        area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
        is_seat_type_assigned = await nodriver_ticket_seat_type_auto_select(
            tab, config_dict, area_keyword
        )

        # Step 2: Select seats
        is_seat_assigned = False
        if is_seat_type_assigned:
            # Additional wait for DOM to fully stabilize after AJAX update
            # Increased to 2s to ensure AJAX completes
            await tab.sleep(2.0)
            is_seat_assigned = await nodriver_ticket_seat_auto_select(tab, config_dict)

    # Step 3: Handle captcha (reuse KHAM OCR)
    is_captcha_sent = False
    if is_seat_assigned and config_dict["ocr_captcha"]["enable"]:
        try:
            # Find captcha input field
            captcha_input = await tab.query_selector('#ctl00_ContentPlaceHolder1_CHK')
            if captcha_input:
                # Reuse KHAM's OCR handling function
                model_name = "UTK0205"
                is_captcha_sent = await nodriver_kham_captcha(
                    tab, config_dict, ocr, model_name
                )
        except Exception as exc:
            if show_debug:
                print(f"[ERROR] Captcha processing error: {exc}")

    # Step 4: Submit order
    is_submit_success = False
    if is_seat_assigned and (not config_dict["ocr_captcha"]["enable"] or is_captcha_sent):
        try:
            # 【修復 2】使用純 JavaScript 實作以避免 Element 序列化問題，加入多個備用選擇器
            import json
            result = await tab.evaluate(f'''
                (function() {{
                    const showDebug = {json.dumps(show_debug)};

                    // [Optimized] Simplified selector - MCP test confirmed .sumitButton is sufficient
                    const submitButton = document.querySelector('button.sumitButton');

                    if (showDebug) {{
                        console.log('[TICKET SUBMIT] Button found:', !!submitButton);
                        if (submitButton) {{
                            console.log('[TICKET SUBMIT] Button classes:', submitButton.className);
                            console.log('[TICKET SUBMIT] Button text:', submitButton.textContent);
                            console.log('[TICKET SUBMIT] Button disabled:', submitButton.disabled);
                        }}
                    }}

                    if (submitButton && !submitButton.disabled) {{
                        if (showDebug) {{
                            console.log('[TICKET SUBMIT] Clicking submit button...');
                        }}
                        submitButton.click();
                        return true;
                    }}

                    if (showDebug) {{
                        console.log('[TICKET SUBMIT] Submit button not available');
                    }}
                    return false;
                }})();
            ''')

            # 轉換 CDP 格式 (布林值)
            if isinstance(result, list) and len(result) == 2:
                # CDP format: ['value', {'type': 'boolean', 'value': True/False}]
                is_submit_success = result[1].get('value', False) if isinstance(result[1], dict) else result
            else:
                is_submit_success = result

            if is_submit_success:
                if show_debug:
                    print("[TICKET SUBMIT] Order submitted successfully")

                # Check and close success dialog (year ticket shows "加入購物車完成" dialog)
                # Wait up to 5 seconds for dialog to appear
                dialog_closed = False
                for i in range(10):  # 10 attempts * 0.5s = 5 seconds
                    await tab.sleep(0.5)
                    try:
                        dialog_btn = await tab.query_selector('div.ui-dialog-buttonset > button[type="button"]')
                        if dialog_btn:
                            if show_debug:
                                print("[TICKET SUBMIT] Success dialog found, closing...")
                            await dialog_btn.click()
                            await tab.sleep(0.5)  # Wait for dialog close animation
                            dialog_closed = True
                            if show_debug:
                                print("[TICKET SUBMIT] Dialog closed successfully")
                            break
                    except Exception as e:
                        if show_debug and i == 9:  # Only print on last attempt
                            print(f"[TICKET SUBMIT] Dialog close attempt failed: {e}")
                        pass

                if not dialog_closed and show_debug:
                    print("[TICKET SUBMIT] No dialog appeared within 5 seconds")

                # Play sound if enabled
                if config_dict["advanced"]["play_sound"]["order"]:
                    play_sound_while_ordering(config_dict)

        except Exception as exc:
            if show_debug:
                print(f"[ERROR] Submit exception: {exc}")
            # Fallback: use JavaScript to force submit (same as Chrome)
            try:
                await tab.evaluate('addShoppingCart1();')
                is_submit_success = True
                if config_dict["advanced"]["play_sound"]["order"]:
                    play_sound_while_ordering(config_dict)
                if show_debug:
                    print("[TICKET SUBMIT] Submitted via fallback method")
            except Exception as exc2:
                if show_debug:
                    print(f"[ERROR] Fallback submit error: {exc2}")

    # Step 5: Check for seat taken dialog and retry if needed
    if not is_submit_success:
        is_seat_taken = await nodriver_ticket_check_seat_taken_dialog(tab, config_dict)
        if is_seat_taken:
            # Seat was taken, retry seat selection
            await tab.sleep(0.5)
            is_seat_assigned = await nodriver_ticket_seat_auto_select(tab, config_dict)

            # Retry captcha if needed
            if is_seat_assigned and config_dict["ocr_captcha"]["enable"]:
                try:
                    captcha_input = await tab.query_selector('#ctl00_ContentPlaceHolder1_CHK')
                    if captcha_input:
                        model_name = "UTK0205"
                        is_captcha_sent = await nodriver_kham_captcha(
                            tab, config_dict, ocr, model_name
                        )
                except Exception as exc:
                    if show_debug:
                        print(f"[ERROR] Retry captcha error: {exc}")

            # Retry submit
            if is_seat_assigned and (not config_dict["ocr_captcha"]["enable"] or is_captcha_sent):
                try:
                    result = await tab.evaluate('''
                        (function() {
                            const button = document.querySelector('button.sumitButton[onclick*="addShoppingCart1"]');
                            if (button && !button.disabled) {
                                button.click();
                                return true;
                            }
                            return false;
                        })();
                    ''')

                    if isinstance(result, list) and len(result) == 2:
                        is_submit_success = result[1].get('value', False) if isinstance(result[1], dict) else result
                    else:
                        is_submit_success = result

                    if is_submit_success:
                        if show_debug:
                            print("[TICKET SUBMIT] Order submitted successfully after retry")

                        # Check and close success dialog (same logic as initial submit)
                        dialog_closed = False
                        for i in range(10):  # 10 attempts * 0.5s = 5 seconds
                            await tab.sleep(0.5)
                            try:
                                dialog_btn = await tab.query_selector('div.ui-dialog-buttonset > button[type="button"]')
                                if dialog_btn:
                                    if show_debug:
                                        print("[TICKET SUBMIT RETRY] Success dialog found, closing...")
                                    await dialog_btn.click()
                                    await tab.sleep(0.5)
                                    dialog_closed = True
                                    if show_debug:
                                        print("[TICKET SUBMIT RETRY] Dialog closed successfully")
                                    break
                            except Exception as e:
                                if show_debug and i == 9:
                                    print(f"[TICKET SUBMIT RETRY] Dialog close attempt failed: {e}")
                                pass

                        if not dialog_closed and show_debug:
                            print("[TICKET SUBMIT RETRY] No dialog appeared within 5 seconds")

                        # Play sound
                        if config_dict["advanced"]["play_sound"]["order"]:
                            play_sound_while_ordering(config_dict)

                except Exception as exc:
                    if show_debug:
                        print(f"[ERROR] Retry submit error: {exc}")

    if show_debug:
        print(f"[TICKET SEAT MAIN] Type:{is_seat_type_assigned} "
              f"Seat:{is_seat_assigned} Submit:{is_submit_success}")

    return is_submit_success


async def nodriver_ticket_check_seat_taken_dialog(tab, config_dict):
    """
    檢查並處理「座位已被訂走」對話框
    對話框內容：「有部分座位已被訂走, 請再重新選取座位 !」

    [TESTED] 已完整測試 - 座位已被訂走對話框處理
    """
    # 函數開始檢查暫停 [T004修正]
    if await check_and_handle_pause(config_dict):
        return False

    show_debug = config_dict["advanced"].get("verbose", False)
    is_dialog_found = False

    try:
        # 使用純 JavaScript 偵測對話框並點擊 OK 按鈕
        result = await tab.evaluate('''
            (function() {
                const dialog = document.querySelector('#dialog-message');
                if (!dialog) return false;

                const text = dialog.textContent || '';
                if (text.includes('座位已被訂走') || text.includes('請再重新選取座位')) {
                    // 找到 OK 按鈕並點擊
                    const okButton = document.querySelector('.ui-dialog-buttonset button[type="button"]');
                    if (okButton) {
                        okButton.click();
                        console.log('[TICKET DIALOG] Seat taken dialog closed');
                        return true;
                    }
                }
                return false;
            })();
        ''')

        # 轉換 CDP 格式
        if isinstance(result, list) and len(result) == 2:
            is_dialog_found = result[1].get('value', False) if isinstance(result[1], dict) else result
        else:
            is_dialog_found = result

        if is_dialog_found and show_debug:
            print("[TICKET DIALOG] Seat taken dialog detected and closed, will retry seat selection")

    except Exception as exc:
        if show_debug:
            print(f"[ERROR] Dialog check error: {exc}")

    return is_dialog_found


async def nodriver_ticket_close_dialog_with_retry(tab, config_dict, max_attempts=5, interval=0.3):
    """
    [ticket.com.tw] 多次檢查並關閉對話框

    解決問題：網頁操作太快，對話框出現速度慢，單次檢查會錯過

    Args:
        tab: NoDriver tab
        config_dict: 設定字典
        max_attempts: 最大嘗試次數 (預設 5 次)
        interval: 每次嘗試間隔秒數 (預設 0.3 秒)

    Returns:
        bool: 是否成功關閉對話框
    """
    show_debug = config_dict["advanced"].get("verbose", False)
    dialog_closed = False

    for attempt in range(max_attempts):
        try:
            # 嘗試多種選擇器
            dialog_btn = await tab.query_selector('div.ui-dialog-buttonset > button.ui-button')
            if not dialog_btn:
                dialog_btn = await tab.query_selector('div.ui-dialog-buttonset > button[type="button"]')
            if not dialog_btn:
                dialog_btn = await tab.query_selector('.ui-dialog-buttonset button')

            if dialog_btn:
                await dialog_btn.click()
                dialog_closed = True
                if show_debug:
                    print(f"[TICKET DIALOG] Closed on attempt {attempt + 1}/{max_attempts}")
                # 等待一下讓對話框關閉動畫完成
                await tab.sleep(0.2)
                break
        except Exception as e:
            if show_debug and attempt == max_attempts - 1:
                print(f"[TICKET DIALOG] Close failed after {max_attempts} attempts: {e}")

        # 等待後再嘗試
        if attempt < max_attempts - 1:
            await tab.sleep(interval)

    return dialog_closed


async def nodriver_ticket_allow_not_adjacent_seat(tab, config_dict):
    """
    允許非連續座位

    [TESTED] 已完整測試 - 非連續座位許可

    Reference: chrome_tixcraft.py Line 9209-9228
    Similar to: nodriver_check_checkbox_enhanced (Line 302)
    """
    # 函數開始檢查暫停 [T004修正]
    if await check_and_handle_pause(config_dict):
        return False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Use JavaScript to directly check (NoDriver recommended approach)
    is_checked = await tab.evaluate('''
        (function() {
            const checkbox = document.querySelector('div.panel > span > input[type="checkbox"]');
            if (!checkbox) return false;

            // If already checked, return true
            if (checkbox.checked) return true;

            // Try to click
            try {
                checkbox.click();
                return checkbox.checked;
            } catch(e) {
                // Fallback: directly set checked property
                checkbox.checked = true;
                return checkbox.checked;
            }
        })();
    ''')

    if show_debug_message:
        print(f"[ALLOW NOT ADJACENT] Checkbox checked: {is_checked}")

    return is_checked


async def nodriver_ticket_switch_to_auto_seat(tab):
    """
    切換到自動選座模式
    Reference: chrome_tixcraft.py Line 9268-9304
    """
    is_switch_to_auto_seat = False

    try:
        # Find switch button (same selector as Chrome version)
        btn = await tab.query_selector('input[value="BUY_TYPE_2"]')

        if btn:
            # Check if already selected
            is_checked = await tab.evaluate('''
                (function(elem) {
                    return elem.checked === true;
                })(arguments[0])
            ''', btn)

            if not is_checked:
                # Not selected, click it
                try:
                    await btn.click()
                    is_switch_to_auto_seat = True
                except Exception:
                    # Fallback: use JavaScript to force click
                    try:
                        await tab.evaluate('''
                            (function(elem) { elem.click(); })(arguments[0])
                        ''', btn)
                        is_switch_to_auto_seat = True
                    except:
                        pass
            else:
                # Already selected
                is_switch_to_auto_seat = True

    except Exception:
        pass

    return is_switch_to_auto_seat

def get_nodriver_browser_args():
    """
    取得 nodriver 瀏覽器參數
    參考 stackoverflow.max-everyday.com，使用經過驗證可通過 Cloudflare 的參數
    """
    # 基於文章驗證的可通過 Cloudflare 檢查的參數
    browser_args = [
        "--disable-animations",
        "--disable-app-info-dialog-mac",
        "--disable-background-networking",
        "--disable-backgrounding-occluded-windows",
        "--disable-breakpad",
        "--disable-component-update",
        "--disable-default-apps",
        "--disable-dev-shm-usage",
        "--disable-device-discovery-notifications",
        "--disable-dinosaur-easter-egg",
        "--disable-domain-reliability",
        "--disable-features=IsolateOrigins,site-per-process,TranslateUI",
        "--disable-infobars",
        "--disable-logging",
        "--disable-login-animations",
        "--disable-login-screen-apps",
        "--disable-notifications",
        "--disable-password-generation",
        "--disable-popup-blocking",
        "--disable-renderer-backgrounding",
        "--disable-session-crashed-bubble",
        "--disable-smooth-scrolling",
        "--disable-suggestions-ui",
        "--disable-sync",
        "--disable-translate",
        "--hide-crash-restore-bubble",
        "--homepage=about:blank",
        "--no-default-browser-check",
        "--no-first-run",
        "--no-pings",
        "--no-service-autorun",
        "--password-store=basic",
        # Note: --remote-debugging-host is managed by Config(host=...) when MCP debug is enabled
        "--lang=zh-TW",
    ]

    # 如果啟用專家模式，謹慎加入額外的高風險參數
    if CLOUDFLARE_ENABLE_EXPERT_MODE:
        # 注意：這些參數可能增加被偵測的風險，但提供更強的繞過能力
        expert_args = [
            "--no-sandbox",  # 某些環境需要，有被偵測風險
            "--disable-web-security",  # 高風險但強效的參數
        ]
        browser_args.extend(expert_args)

    return browser_args

def get_maxbot_extension_path(extension_folder):
    app_root = util.get_app_root()
    extension_path = "webdriver"
    extension_path = os.path.join(extension_path, extension_folder)
    config_filepath = os.path.join(app_root, extension_path)
    #print("config_filepath:", config_filepath)

    # double check extesion mainfest
    path = pathlib.Path(config_filepath)
    if path.exists():
        if path.is_dir():
            #print("found extension dir")
            for item in path.rglob("manifest.*"):
                path = item.parent
            #print("final path:", path)
    return config_filepath

def get_extension_config(config_dict, args=None):
    default_lang = "zh-TW"
    no_sandbox=True
    browser_args = get_nodriver_browser_args()
    if len(config_dict["advanced"]["proxy_server_port"]) > 2:
        browser_args.append('--proxy-server=%s' % config_dict["advanced"]["proxy_server_port"])

    # MCP connect mode: Connect to existing Chrome instance (for MCP integration)
    # This allows NoDriver to attach to a Chrome started with --remote-debugging-port
    mcp_connect_port = None
    if args and hasattr(args, 'mcp_connect') and args.mcp_connect:
        mcp_connect_port = args.mcp_connect

    if mcp_connect_port:
        # Connect to existing Chrome (NoDriver will NOT start a new browser)
        print(f"[MCP CONNECT] Connecting to existing Chrome on port {mcp_connect_port}")
        print(f"[MCP CONNECT] Make sure Chrome is running with: --remote-debugging-port={mcp_connect_port}")
        conf = Config(
            host="127.0.0.1",
            port=mcp_connect_port,
            headless=config_dict["advanced"]["headless"]
        )
        # Note: When connecting to existing browser, extensions cannot be loaded
        return conf

    # MCP debug mode: NoDriver uses dynamic CDP port, we output actual port after browser starts
    # Note: NoDriver limitation - cannot use fixed port (browser.py:357-361 treats host+port as
    # "connect to existing browser" mode). We just mark that MCP debug is requested here.
    # The actual port will be printed in main() after browser starts.
    mcp_debug_enabled = False
    if args and hasattr(args, 'mcp_debug') and args.mcp_debug:
        mcp_debug_enabled = True
        print("[MCP DEBUG] Mode enabled - actual port will be shown after browser starts")
    elif config_dict["advanced"].get("mcp_debug_port", 0) > 0:
        mcp_debug_enabled = True
        print("[MCP DEBUG] Mode enabled (via settings.json) - actual port will be shown after browser starts")

    # Ensure Chrome is available (download if needed)
    # This fixes Issue #236: NoDriver fails when Chrome is not installed
    app_root = util.get_app_root()
    webdriver_dir = os.path.join(app_root, "webdriver")
    chrome_path = chrome_downloader.ensure_chrome_available(download_dir=webdriver_dir)
    if not chrome_path:
        print("[ERROR] Chrome not found and download failed.")
        print("[ERROR] Please install Chrome manually or check your internet connection.")
        raise FileNotFoundError("Could not find or download Chrome browser")

    # Normal mode: auto-detect (host=None, port=None) to let NoDriver start the browser
    conf = Config(browser_args=browser_args, lang=default_lang, no_sandbox=no_sandbox, headless=config_dict["advanced"]["headless"], browser_executable_path=chrome_path)
    if config_dict["advanced"]["chrome_extension"]:
        ext = get_maxbot_extension_path(CONST_MAXBOT_EXTENSION_NAME)
        if len(ext) > 0:
            conf.add_extension(ext)
            util.dump_settings_to_maxbot_plus_extension(ext, config_dict, CONST_MAXBOT_CONFIG_FILE)
        ext = get_maxbot_extension_path(CONST_MAXBLOCK_EXTENSION_NAME)
        if len(ext) > 0:
            conf.add_extension(ext)
            util.dump_settings_to_maxblock_plus_extension(ext, config_dict, CONST_MAXBOT_CONFIG_FILE, CONST_MAXBLOCK_EXTENSION_FILTER)
    return conf

async def nodrver_block_urls(tab, config_dict):
    """
    Block unnecessary network requests for performance and privacy

    Strategy for Cityline:
    - Allow: others.min.js (required for buy button and _global_citylineWebBase)
    - Block: Analytics/tracking requests initiated by others.min.js
    """
    NETWORK_BLOCKED_URLS = [
        # General tracking and analytics
        '*.appier.net/*',
        '*.c.appier.net/*',
        '*.clarity.ms/*',
        '*.cloudfront.com/*',
        '*.doubleclick.net/*',  # Covers securepubads.g.doubleclick.net
        '*.lndata.com/*',
        '*.rollbar.com/*',
        '*.smartlook.com/*',
        '*anymind360.com/*',  # Block Anymind360 tracking (loaded by cityline others.min.js)
        '*cdn.cookielaw.org/*',
        '*e2elog.fetnet.net*',
        '*fundingchoicesmessages.google.com/*',

        # Google tracking (broad patterns cover specific URLs)
        '*google-analytics.*',  # Covers www.google-analytics.com/analytics.js & collect
        '*googlesyndication.*',  # Covers pagead2.googlesyndication.com
        '*googletagmanager.*',  # Covers www.googletagmanager.com/gtag/js
        '*googletagservices.*',
        '*googleadservices.com/*',  # Ad conversion tracking
        '*adtrafficquality.google/*',  # Ad quality detection

        # Facebook Pixel tracking (does not affect FB login)
        '*connect.facebook.net/*/fbevents.js',
        '*connect.facebook.net/signals/*',

        # Social media and video
        '*.twitter.com/i/*',
        '*platform.twitter.com/*',
        '*syndication.twitter.com/*',
        '*youtube.com/*',
        '*player.youku.*',
        '*play.google.com/*',

        # Ad scripts
        '*/adblock.js',
        '*/google_ad_block.js',
        '*img.uniicreative.com/*',

        # Cityline: Allow others.min.js (required for buy button), block tracking only
        # '*cityline.com/js/others.min.js',  # DISABLED: Required for buy button rendering

        # Ticketmaster ad scripts
        '*ticketmaster.sg/js/adblock*',
        '*ticketmaster.sg/js/ads.js*',
        #'*ticketmaster.sg/epsf/asset/eps.js*',
        #'*ticketmaster.sg/epsf/asset/eps-gec.js',
        #'*ticketmaster.sg/epsf/asset/eps-mgr',
        '*ticketmaster.com/js/ads.js*',
        '*ticketmaster.com/epsf/asset/eps.js*',
    ]

    if config_dict["advanced"]["hide_some_image"]:
        NETWORK_BLOCKED_URLS.append('*.woff')
        NETWORK_BLOCKED_URLS.append('*.woff2')
        NETWORK_BLOCKED_URLS.append('*.ttf')
        NETWORK_BLOCKED_URLS.append('*.otf')
        NETWORK_BLOCKED_URLS.append('*fonts.googleapis.com/earlyaccess/*')
        NETWORK_BLOCKED_URLS.append('*/ajax/libs/font-awesome/*')
        NETWORK_BLOCKED_URLS.append('*.ico')
        NETWORK_BLOCKED_URLS.append('*ticketimg2.azureedge.net/image/ActivityImage/*')
        NETWORK_BLOCKED_URLS.append('*static.tixcraft.com/images/activity/*')
        NETWORK_BLOCKED_URLS.append('*static.ticketmaster.sg/images/activity/*')
        NETWORK_BLOCKED_URLS.append('*static.ticketmaster.com/images/activity/*')
        NETWORK_BLOCKED_URLS.append('*ticketimg2.azureedge.net/image/ActivityImage/ActivityImage_*')
        NETWORK_BLOCKED_URLS.append('*.azureedge.net/QWARE_TICKET//images/*')
        NETWORK_BLOCKED_URLS.append('*static.ticketplus.com.tw/event/*')

        #NETWORK_BLOCKED_URLS.append('https://kktix.cc/change_locale?locale=*')
        NETWORK_BLOCKED_URLS.append('https://t.kfs.io/assets/logo_*.png')
        NETWORK_BLOCKED_URLS.append('https://t.kfs.io/assets/icon-*.png')
        NETWORK_BLOCKED_URLS.append('https://t.kfs.io/upload_images/*.jpg')

    if config_dict["advanced"]["block_facebook_network"]:
        NETWORK_BLOCKED_URLS.append('*facebook.com/*')
        NETWORK_BLOCKED_URLS.append('*.fbcdn.net/*')

    try:
        await tab.send(cdp.network.enable())
        # Block unnecessary network requests for performance optimization
        await tab.send(cdp.network.set_blocked_ur_ls(urls=NETWORK_BLOCKED_URLS))
    except Exception as exc:
        print(f"Warning: Failed to enable network blocking: {exc}")
        # Continue without network blocking if it fails
    return tab

async def nodriver_resize_window(tab, config_dict):
    if len(config_dict["advanced"]["window_size"]) > 0:
        if "," in config_dict["advanced"]["window_size"]:
            size_array = config_dict["advanced"]["window_size"].split(",")
            position_left = 0
            if len(size_array) >= 3:
                position_left = int(size_array[0]) * int(size_array[2])
            #tab = await driver.main_tab()
            if tab:
                await tab.set_window_size(left=position_left, top=30, width=int(size_array[0]), height=int(size_array[1]))

async def nodriver_current_url(tab):
    is_quit_bot = False
    exit_bot_error_strings = [
        "server rejected WebSocket connection: HTTP 500",
        "[Errno 61] Connect call failed ('127.0.0.1',",
        "[WinError 1225] ",
    ]

    url = ""
    if tab:
        url_dict = {}
        try:
            url_dict = await tab.js_dumps('window.location.href')
        except Exception as exc:
            print(exc)
            str_exc = ""
            try:
                str_exc = str(exc)
            except Exception as exc2:
                pass
            if len(str_exc) > 0:
                for each_error_string in exit_bot_error_strings:
                    if each_error_string in str_exc:
                        #print('quit bot by error:', each_error_string, driver)
                        is_quit_bot = True

        url_array = []
        if url_dict:
            for k in url_dict:
                if k.isnumeric():
                    if "0" in url_dict[k]:
                        url_array.append(url_dict[k]["0"])
            url = ''.join(url_array)
    return url, is_quit_bot

def nodriver_overwrite_prefs(conf):
    #print(conf.user_data_dir)
    prefs_filepath = os.path.join(conf.user_data_dir,"Default")
    if not os.path.exists(prefs_filepath):
        os.mkdir(prefs_filepath)
    prefs_filepath = os.path.join(prefs_filepath,"Preferences")
    
    prefs_dict = {
        "credentials_enable_service": False,
        "ack_existing_ntp_extensions": False,
        "translate":{"enabled": False}}
    prefs_dict["in_product_help"]={}
    prefs_dict["in_product_help"]["snoozed_feature"]={}
    prefs_dict["in_product_help"]["snoozed_feature"]["IPH_LiveCaption"]={}
    prefs_dict["in_product_help"]["snoozed_feature"]["IPH_LiveCaption"]["is_dismissed"]=True
    prefs_dict["in_product_help"]["snoozed_feature"]["IPH_LiveCaption"]["last_dismissed_by"]=4
    prefs_dict["media_router"]={}
    prefs_dict["media_router"]["show_cast_sessions_started_by_other_devices"]={}
    prefs_dict["media_router"]["show_cast_sessions_started_by_other_devices"]["enabled"]=False
    prefs_dict["net"]={}
    prefs_dict["net"]["network_prediction_options"]=3
    prefs_dict["privacy_guide"]={}
    prefs_dict["privacy_guide"]["viewed"]=True
    prefs_dict["privacy_sandbox"]={}
    prefs_dict["privacy_sandbox"]["first_party_sets_enabled"]=False
    prefs_dict["profile"]={}
    #prefs_dict["profile"]["cookie_controls_mode"]=1
    prefs_dict["profile"]["default_content_setting_values"]={}
    prefs_dict["profile"]["default_content_setting_values"]["notifications"]=2
    prefs_dict["profile"]["default_content_setting_values"]["sound"]=2
    prefs_dict["profile"]["name"]=CONST_APP_VERSION
    prefs_dict["profile"]["password_manager_enabled"]=False
    prefs_dict["safebrowsing"]={}
    prefs_dict["safebrowsing"]["enabled"]=False
    prefs_dict["safebrowsing"]["enhanced"]=False
    prefs_dict["sync"]={}
    prefs_dict["sync"]["autofill_wallet_import_enabled_migrated"]=False

    json_str = json.dumps(prefs_dict)
    with open(prefs_filepath, 'w') as outfile:
        outfile.write(json_str)

    state_filepath = os.path.join(conf.user_data_dir,"Local State")
    state_dict = {}
    state_dict["performance_tuning"]={}
    state_dict["performance_tuning"]["high_efficiency_mode"]={}
    state_dict["performance_tuning"]["high_efficiency_mode"]["state"]=1
    state_dict["browser"]={}
    state_dict["browser"]["enabled_labs_experiments"]=[
        "history-journeys@4",
        "memory-saver-multi-state-mode@1",
        "modal-memory-saver@1",
        "read-anything@2"
    ]
    state_dict["dns_over_https"]={}
    state_dict["dns_over_https"]["mode"]="off"
    json_str = json.dumps(state_dict)
    with open(state_filepath, 'w') as outfile:
        outfile.write(json_str)

async def check_refresh_datetime_occur(tab, target_time):
    is_refresh_datetime_sent = False

    system_clock_data = datetime.now()
    current_time = system_clock_data.strftime('%H:%M:%S')
    if target_time == current_time:
        try:
            await tab.reload()
            is_refresh_datetime_sent = True
            print("send refresh at time:", current_time)
        except Exception as exc:
            pass

    return is_refresh_datetime_sent

async def reload_config(config_dict, last_mtime):
    app_root = util.get_app_root()
    config_filepath = os.path.join(app_root, CONST_MAXBOT_CONFIG_FILE)

    if not os.path.exists(config_filepath):
        return config_dict, last_mtime

    try:
        current_mtime = os.path.getmtime(config_filepath)
        if current_mtime > last_mtime:
            await asyncio.sleep(0.1)
            with open(config_filepath, 'r', encoding='utf-8') as json_data:
                new_config = json.load(json_data)

                # Update fields
                fields = [
                    "ticket_number", "date_auto_select", "area_auto_select", "keyword_exclude",
                    "ocr_captcha", "tixcraft", "kktix", "cityline",
                    "refresh_datetime", "contact", "date_auto_fallback", "area_auto_fallback"
                ]
                for field in fields:
                    if field in new_config:
                        config_dict[field] = new_config[field]

                if "advanced" in new_config:
                    if "advanced" not in config_dict:
                        config_dict["advanced"] = {}
                    adv_fields = [
                        "play_sound", "disable_adjacent_seat", "hide_some_image",
                        "auto_guess_options", "user_guess_string", "auto_reload_page_interval", "verbose",
                        "auto_reload_overheat_count", "auto_reload_overheat_cd",
                        "idle_keyword", "resume_keyword", "idle_keyword_second", "resume_keyword_second",
                        "discord_webhook_url", "discount_code"
                    ]
                    for field in adv_fields:
                        if field in new_config["advanced"]:
                            config_dict["advanced"][field] = new_config["advanced"][field]

                print("Configuration reloaded from settings.json")
                return config_dict, current_mtime
    except Exception:
        pass

    return config_dict, last_mtime

# ====================================================================================
# HKTicketing Platform (hkticketing.com / galaxymacau.com / ticketek.com.au)
# ====================================================================================

# HKTicketing error message list for content refresh detection
HKTICKETING_CONTENT_RETRY_STRING_LIST = [
    "Access Denied",
    "Service Unavailable",
    "The service is unavailable",
    "HTTP Error 500",
    "HTTP Error 503",
    "504 Gateway Time-out",
    "502 Bad Gateway",
    "An error occurred while processing your request",
    "The network path was not found",
    "Could not open a connection to SQL Server",
    "Hi fans, you're in the queue to",
    "We will check for the next available purchase slot",
    "please stay on this page and do not refresh",
    "Please be patient and wait a few minutes before trying again",
    "Server Error in '/' Application",
    "The target principal name is incorrect",
    "Cannot generate SSPI context",
    "System.Data.SqlClient.Sql",
    "System.ComponentModel.Win32Exception",
    "Your attempt to access the web site has been blocked by",
    "This request was blocked by"
]

# HKTicketing URL patterns for redirect detection
HKTICKETING_REDIRECT_URL_LIST = [
    'queue.hkticketing.com/hotshow.html',
    '.com/detection.aspx?rt=',
    '/busy_galaxy.'
]
# Add ticketek hot queue URLs (hot0 to hot19)
for _idx in range(20):
    HKTICKETING_REDIRECT_URL_LIST.append('/hot%d.ticketek.com.au/' % (_idx))

# HKTicketing URLs that need content refresh check
HKTICKETING_CHECK_URL_LIST = [
    ".com/default.aspx",
    ".com/shows/show.aspx?sh=",
    ".com/detection.aspx",
    "/entry-hotshow.",
    ".com/_Incapsula_Resource?"
]

# HKTicketing full URL matches for content refresh
HKTICKETING_CHECK_FULL_URL_LIST = [
    "https://premier.hkticketing.com/",
    "https://www.ticketing.galaxymacau.com/",
    "https://ticketing.galaxymacau.com/",
    "https://ticketing.galaxymacau.com/default.aspx"
]

# HKTicketing sold out date keywords
HKTICKETING_DATE_SOLDOUT_KEYWORDS = [
    " Exhausted",
    "No Longer On Sale"
]
HKTICKETING_DATE_SOLDOUT_KEYWORDS_ZH = [
    "Exhausted",
    "No Longer On Sale"
]


async def nodriver_hkticketing_login(tab, account, password):
    """
    HKTicketing auto login
    Reference: chrome_tixcraft.py hkticketing_login (line 5661-5733)
    """
    ret = False
    show_debug_message = True

    if show_debug_message:
        print("[HKTICKETING LOGIN] Starting login process...")

    # Try multiple selectors for email/login code input
    el_email = None
    email_selectors = [
        '#ctl00_uiContent_Login1_tbLoginCode',  # ASP.NET ID format
        'input[name="ctl00$uiContent$Login1$tbLoginCode"]',
        'div#myTick2Col > div.formMod2Col > div.formModule > div.loginContentContainer > input.borInput',
        'input.borInput[type="text"]',
    ]

    for selector in email_selectors:
        try:
            el_email = await tab.query_selector(selector)
            if el_email:
                break
        except Exception as exc:
            pass

    if not el_email:
        if show_debug_message:
            print("[HKTICKETING LOGIN] Email input not found")
        return ret

    # Input account
    is_email_sent = False
    try:
        await el_email.click()
        await asyncio.sleep(0.1)

        # Check if already has value
        inputed_text = await el_email.apply('(el) => el.value')
        if not inputed_text or len(str(inputed_text)) == 0:
            await el_email.send_keys(account)
            is_email_sent = True
            if show_debug_message:
                print(f"[HKTICKETING LOGIN] Account input completed: {account[:3]}***")
        else:
            if str(inputed_text) == account:
                is_email_sent = True
                if show_debug_message:
                    print("[HKTICKETING LOGIN] Account already filled")
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING LOGIN] Account input error: {exc}")

    if not is_email_sent:
        if show_debug_message:
            print("[HKTICKETING LOGIN] Failed to input account")
        return ret

    # Try multiple selectors for password input
    el_pass = None
    password_selectors = [
        '#ctl00_uiContent_Login1_tbPassword',  # ASP.NET ID format
        'input[name="ctl00$uiContent$Login1$tbPassword"]',
        'div.loginContentContainer > input[type="password"]',
        'input[type="password"]',
    ]

    for selector in password_selectors:
        try:
            el_pass = await tab.query_selector(selector)
            if el_pass:
                break
        except Exception as exc:
            pass

    if not el_pass:
        if show_debug_message:
            print("[HKTICKETING LOGIN] Password input not found")
        return ret

    # Input password
    is_password_sent = False
    try:
        await el_pass.click()
        await asyncio.sleep(0.1)

        inputed_text = await el_pass.apply('(el) => el.value')
        if not inputed_text or len(str(inputed_text)) == 0:
            if len(password) > 0:
                await el_pass.send_keys(password)
                is_password_sent = True
                if show_debug_message:
                    print("[HKTICKETING LOGIN] Password input completed")
        else:
            is_password_sent = True
            if show_debug_message:
                print("[HKTICKETING LOGIN] Password already filled")
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING LOGIN] Password input error: {exc}")

    if not is_password_sent:
        if show_debug_message:
            print("[HKTICKETING LOGIN] Failed to input password")
        return ret

    # Click login button
    el_login_btn = None
    login_btn_selectors = [
        '#ctl00_uiContent_Login1_btnLogin',  # ASP.NET ID format
        'input[name="ctl00$uiContent$Login1$btnLogin"]',
        'input.blueButton[type="submit"]',
        'input[value="Login"]',
    ]

    for selector in login_btn_selectors:
        try:
            el_login_btn = await tab.query_selector(selector)
            if el_login_btn:
                break
        except Exception as exc:
            pass

    if el_login_btn:
        try:
            await el_login_btn.click()
            ret = True
            if show_debug_message:
                print("[HKTICKETING LOGIN] Login button clicked")
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING LOGIN] Login button click error: {exc}")
            # Fallback: try pressing Enter on password field
            try:
                await el_pass.send_keys(Keys.ENTER)
                ret = True
                if show_debug_message:
                    print("[HKTICKETING LOGIN] Fallback: pressed Enter key")
            except Exception as exc2:
                if show_debug_message:
                    print(f"[HKTICKETING LOGIN] Enter key fallback error: {exc2}")
    else:
        # No login button found, try pressing Enter
        if show_debug_message:
            print("[HKTICKETING LOGIN] Login button not found, trying Enter key")
        try:
            await el_pass.send_keys(Keys.ENTER)
            ret = True
            if show_debug_message:
                print("[HKTICKETING LOGIN] Pressed Enter key as fallback")
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING LOGIN] Enter key error: {exc}")

    await asyncio.sleep(0.2)
    return ret


async def nodriver_hkticketing_accept_cookie(tab):
    """
    Close cookie consent popup
    Reference: chrome_tixcraft.py hkticketing_accept_cookie (line 7460-7497)
    """
    try:
        el_close = await tab.query_selector('#closepolicy_new')
        if el_close:
            await el_close.click()
    except Exception as exc:
        pass


async def nodriver_hkticketing_date_buy_button_press(tab, config_dict=None):
    """
    Click buy button on date selection page and wait for URL change
    Reference: chrome_tixcraft.py hkticketing_date_buy_button_press (line 7498-7533)
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    is_button_clicked = False

    # Get current URL before clicking
    current_url = ""
    try:
        current_url = await tab.evaluate('window.location.href')
    except:
        pass

    el_btn = None
    try:
        el_btn = await tab.query_selector('#buyButton > input')
    except Exception as exc:
        pass

    if el_btn:
        try:
            is_enabled = await tab.evaluate('''
                (function() {
                    const btn = document.querySelector('#buyButton > input');
                    return btn ? !btn.disabled : false;
                })();
            ''')
            if is_enabled:
                await el_btn.click()
                is_button_clicked = True
                if show_debug_message:
                    print("[HKTICKETING DATE] Buy button clicked")
            else:
                # Try to enable and click via JavaScript
                is_button_clicked = await tab.evaluate('''
                    (function() {
                        const btn = document.querySelector('#buyButton > input');
                        if (btn) {
                            btn.disabled = false;
                            btn.click();
                            return true;
                        }
                        return false;
                    })();
                ''')
                if is_button_clicked and show_debug_message:
                    print("[HKTICKETING DATE] Buy button force-clicked via JS")
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING DATE] Buy button click error: {exc}")

    # Wait for URL change after clicking (prevent re-clicking)
    if is_button_clicked and current_url:
        if show_debug_message:
            print("[HKTICKETING DATE] Waiting for URL change...")
        max_wait = 10  # Max 10 seconds
        wait_interval = 0.5
        waited = 0
        while waited < max_wait:
            await asyncio.sleep(wait_interval)
            waited += wait_interval
            try:
                new_url = await tab.evaluate('window.location.href')
                if new_url != current_url:
                    if show_debug_message:
                        print(f"[HKTICKETING DATE] URL changed to: {new_url}")
                    break
            except:
                break
        if waited >= max_wait and show_debug_message:
            print("[HKTICKETING DATE] URL change timeout")

    return is_button_clicked


async def nodriver_hkticketing_date_assign(tab, config_dict):
    """
    Date assignment core logic
    Reference: chrome_tixcraft.py hkticketing_date_assign (line 7534-7679)

    Returns:
        Tuple[bool, bool, List]:
            - is_date_assigned: whether a date has been selected
            - is_page_ready: whether the page is ready
            - formated_area_list: list of available dates
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get("date_auto_fallback", False)

    if show_debug_message:
        print("[HKTICKETING DATE] date_keyword:", date_keyword)

    matched_blocks = None
    date_keyword = util.format_keyword_string(date_keyword)

    # Check if #p is a select element or hidden input (single performance)
    is_single_performance = False
    try:
        element_type = await tab.evaluate('''
            (function() {
                const el = document.querySelector('#p');
                if (el) {
                    return el.tagName.toLowerCase();
                }
                return null;
            })();
        ''')
        if element_type == 'input':
            # Single performance page - no date selection needed
            is_single_performance = True
            if show_debug_message:
                print("[HKTICKETING DATE] Single performance detected (hidden input)")
    except Exception as exc:
        if show_debug_message:
            print("[HKTICKETING DATE] Check element type error:", exc)

    # If single performance, treat as date already assigned
    if is_single_performance:
        if show_debug_message:
            print("[HKTICKETING DATE] is_date_assigned: True (single performance)")
        return True, True, None

    # Check if date is already assigned (for select element)
    is_date_assigned = False
    selected_text = None
    try:
        selected_text = await tab.evaluate('''
            (function() {
                const select = document.querySelector('#p');
                if (select && select.selectedIndex >= 0) {
                    return select.options[select.selectedIndex].text;
                }
                return null;
            })();
        ''')
    except Exception as exc:
        if show_debug_message:
            print("[HKTICKETING DATE] Check selected date error:", exc)

    # If a date is selected, check if it matches the keyword
    if selected_text and len(selected_text) > 8 and '20' in selected_text:
        if show_debug_message:
            print(f"[HKTICKETING DATE] Currently selected: {selected_text}")

        if len(date_keyword) > 0:
            # Check if selected date matches keyword
            normalized_selected = util.format_keyword_string(selected_text)
            keyword_sets = util.parse_keyword_string_to_array(date_keyword)
            if not keyword_sets:
                keyword_sets = [kw.strip() for kw in date_keyword.split(',') if kw.strip()]

            for keyword_set in keyword_sets:
                keyword_parts = keyword_set.split(' ') if isinstance(keyword_set, str) else [str(keyword_set)]
                is_match = True
                for kw in keyword_parts:
                    kw_formatted = util.format_keyword_string(str(kw))
                    if kw_formatted not in normalized_selected:
                        is_match = False
                        break
                if is_match:
                    is_date_assigned = True
                    if show_debug_message:
                        print(f"[HKTICKETING DATE] Selected date matches keyword, keeping selection")
                    break

            if not is_date_assigned and show_debug_message:
                print(f"[HKTICKETING DATE] Selected date does not match keyword, will select target date")
        else:
            # No keyword specified - only keep selection if date_auto_fallback is enabled
            if date_auto_fallback:
                is_date_assigned = True
                if show_debug_message:
                    print(f"[HKTICKETING DATE] No keyword, date_auto_fallback=true, keeping current selection")
            else:
                if show_debug_message:
                    print(f"[HKTICKETING DATE] No keyword, date_auto_fallback=false, will select based on mode")

    if show_debug_message:
        print("[HKTICKETING DATE] is_date_assigned:", is_date_assigned)

    formated_area_list = None
    is_page_ready = True

    if not is_date_assigned:
        # Get all date options
        area_list = None
        try:
            area_list = await tab.query_selector_all("#p > option")
        except Exception as exc:
            print("[HKTICKETING DATE] find #p options date list fail")
            print(exc)

        if area_list:
            area_list_count = len(area_list)
            if show_debug_message:
                print("[HKTICKETING DATE] date_list_count:", area_list_count)

            if area_list_count == 0:
                is_page_ready = False
            else:
                formated_area_list = []
                # Filter list
                for row in area_list:
                    row_text = ""
                    try:
                        row_html = await row.get_html()
                        row_text = util.remove_html_tags(row_html)
                    except Exception as exc:
                        if show_debug_message:
                            print("[HKTICKETING DATE] get row html error:", exc)
                        break

                    if len(row_text) > 0:
                        # Must contain year (20xx)
                        if '20' not in row_text:
                            row_text = ""
                        # Filter sold out dates
                        if ' Exhausted' in row_text:
                            row_text = ""
                        if 'No Longer On Sale' in row_text:
                            row_text = ""

                    if len(row_text) > 0:
                        formated_area_list.append(row)

        if formated_area_list:
            area_list_count = len(formated_area_list)
            if show_debug_message:
                print("[HKTICKETING DATE] formated_area_list count:", area_list_count)

            if area_list_count > 0:
                if len(date_keyword) == 0:
                    matched_blocks = formated_area_list
                else:
                    if show_debug_message:
                        print("[HKTICKETING DATE] start to match keyword:", date_keyword)

                    matched_blocks = util.get_matched_blocks_by_keyword(config_dict, auto_select_mode, date_keyword, formated_area_list)

                    if show_debug_message:
                        if matched_blocks:
                            print("[HKTICKETING DATE] after match keyword, found count:", len(matched_blocks))
            else:
                print("[HKTICKETING DATE] not found date-time-position")
        else:
            print("[HKTICKETING DATE] date date-time-position is None")

        # Fallback logic (FR-026)
        if not matched_blocks or len(matched_blocks) == 0:
            if date_auto_fallback and formated_area_list and len(formated_area_list) > 0:
                if show_debug_message:
                    print("[HKTICKETING DATE FALLBACK] date_auto_fallback=true, selecting from all available dates")
                matched_blocks = formated_area_list
            else:
                if show_debug_message:
                    print("[HKTICKETING DATE FALLBACK] date_auto_fallback=false, fallback is disabled")

        target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)
        if target_area:
            try:
                await target_area.click()
                is_date_assigned = True
                if show_debug_message:
                    print("[HKTICKETING DATE] Date selected successfully")
            except Exception as exc:
                print("[HKTICKETING DATE] click target_area link fail:", exc)

    return is_date_assigned, is_page_ready, formated_area_list


async def nodriver_hkticketing_date_password_input(tab, config_dict, fail_list):
    """
    Handle password protected date selection page
    Reference: chrome_tixcraft.py hkticketing_date_password_input (line 7681-7736)

    Returns:
        Tuple[bool, List[str]]:
            - is_password_appear: whether password input exists
            - fail_list: updated fail list
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    is_password_appear = False

    el_password = None
    try:
        my_css_selector = "#entitlementPassword > div > div > div > div > input[type='password']"
        el_password = await tab.query_selector(my_css_selector)
    except Exception as exc:
        pass

    if el_password:
        is_password_appear = True

        user_guess_string = config_dict["advanced"]["user_guess_string"]
        if len(user_guess_string) > 0:
            answer_list = user_guess_string.split(",")
            for answer_item in answer_list:
                answer_item = answer_item.strip()
                if answer_item in fail_list:
                    if show_debug_message:
                        print("[HKTICKETING PASSWORD] Skip failed password:", answer_item)
                    continue

                # Try this password
                try:
                    await el_password.click()
                    await el_password.send_keys(answer_item)
                    await el_password.send_keys(Keys.ENTER)

                    if show_debug_message:
                        print("[HKTICKETING PASSWORD] Tried password:", answer_item)

                    # Add to fail list (will be removed if successful)
                    if answer_item not in fail_list:
                        fail_list.append(answer_item)
                    break
                except Exception as exc:
                    if show_debug_message:
                        print("[HKTICKETING PASSWORD] Error:", exc)

    return is_password_appear, fail_list


async def nodriver_hkticketing_date_auto_select(tab, config_dict, fail_list):
    """
    Date auto select integration function
    Reference: chrome_tixcraft.py hkticketing_date_auto_select (line 7738-7821)

    Returns:
        Tuple[bool, List[str]]:
            - is_date_submiting: whether date is being submitted
            - fail_list: updated fail list
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_date_submiting = False

    is_date_assigned, is_page_ready, formated_area_list = await nodriver_hkticketing_date_assign(tab, config_dict)

    # Handle password input if needed
    is_password_appear, fail_list = await nodriver_hkticketing_date_password_input(tab, config_dict, fail_list)

    if is_date_assigned:
        is_button_clicked = await nodriver_hkticketing_date_buy_button_press(tab, config_dict)
        if is_button_clicked:
            is_date_submiting = True
            if show_debug_message:
                print("[HKTICKETING DATE] Buy button clicked, submitting...")

    # Auto reload if page not ready
    if not is_page_ready:
        auto_reload_coming_soon_page = config_dict["tixcraft"].get("auto_reload_coming_soon_page", False)
        if auto_reload_coming_soon_page:
            try:
                await tab.reload()
                if show_debug_message:
                    print("[HKTICKETING DATE] Page not ready, reloading...")
            except Exception as exc:
                pass

            if config_dict["advanced"]["auto_reload_page_interval"] > 0:
                await asyncio.sleep(config_dict["advanced"]["auto_reload_page_interval"])

    return is_date_submiting, fail_list


async def nodriver_hkticketing_area_auto_select(tab, config_dict, area_keyword_item):
    """
    Area auto select
    Reference: chrome_tixcraft.py hkticketing_area_auto_select (line 7822-7961)

    Returns:
        Tuple[bool, bool]:
            - is_need_refresh: whether page needs refresh
            - is_price_assign_by_bot: whether area has been selected
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get("area_auto_fallback", False)

    is_need_refresh = False
    is_price_assign_by_bot = False

    if show_debug_message:
        print("[HKTICKETING AREA] area_keyword:", area_keyword_item)

    # Wait for Angular to finish rendering
    await asyncio.sleep(random.uniform(0.3, 0.6))

    # Get all area options using JavaScript for Angular compatibility
    area_list = []
    try:
        area_count = await tab.evaluate('''
            (function() {
                const items = document.querySelectorAll('ul.seatarea > li');
                return items.length;
            })();
        ''')
        if area_count and area_count > 0:
            # Get elements one by one - select the <a> tag inside <li> for ng-click to work
            for i in range(area_count):
                try:
                    # Target the <a> tag with ng-click, not the <li>
                    el = await tab.query_selector(f'ul.seatarea > li:nth-child({i+1}) > a')
                    if el:
                        area_list.append(el)
                except:
                    pass
    except Exception as exc:
        print("[HKTICKETING AREA] find area list fail:", exc)

    if not area_list:
        return is_need_refresh, is_price_assign_by_bot

    area_list_count = len(area_list)
    if show_debug_message:
        print("[HKTICKETING AREA] area_list_count:", area_list_count)

    if area_list_count == 0:
        return is_need_refresh, is_price_assign_by_bot

    # Check if any area is already selected
    is_area_selected = False
    try:
        selected_check = await tab.evaluate('''
            (function() {
                const items = document.querySelectorAll('#ticketSelectorContainer > ul > li');
                for (let item of items) {
                    if (item.classList.contains('selected')) return true;
                }
                return false;
            })();
        ''')
        is_area_selected = selected_check
    except Exception as exc:
        pass

    if is_area_selected:
        is_price_assign_by_bot = True
        if show_debug_message:
            print("[HKTICKETING AREA] Area already selected")
        return is_need_refresh, is_price_assign_by_bot

    # Filter available areas - get all info in one JS call
    formated_area_list = []  # List of (element, text) tuples for NoDriver
    import json
    try:
        # Get all area info in single JavaScript call
        all_areas_info = await tab.evaluate('''
            (function() {
                var items = document.querySelectorAll('ul.seatarea > li');
                var results = [];
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var nameEl = item.querySelector('.name');
                    var priceEl = item.querySelector('.price');
                    results.push({
                        className: item.className || '',
                        name: nameEl ? (nameEl.innerText || nameEl.textContent || '') : '',
                        price: priceEl ? (priceEl.innerText || priceEl.textContent || '') : ''
                    });
                }
                return JSON.stringify(results);
            })();
        ''')

        # Always print for debugging
        print(f"[HKTICKETING AREA] JS raw type: {type(all_areas_info)}, value: {str(all_areas_info)[:300]}")

        # Parse JSON string
        if all_areas_info and isinstance(all_areas_info, str) and len(all_areas_info) > 2:
            areas_data = json.loads(all_areas_info)
            print(f"[HKTICKETING AREA] Parsed {len(areas_data)} areas")

            for idx, info in enumerate(areas_data):
                class_name = info.get('className', '')
                name_text = info.get('name', '')
                price_text = info.get('price', '')
                row_text = f"{name_text} {price_text}".strip()

                print(f"[HKTICKETING AREA] Item {idx}: class='{class_name}', name='{name_text}', price='{price_text}'")

                # Check if disabled or unavailable
                if 'disabled' in class_name or 'unavailable' in class_name:
                    print(f"[HKTICKETING AREA] Item {idx}: skipped (unavailable)")
                    continue

                if len(row_text.strip()) == 0:
                    continue

                # Apply exclude keywords (returns True if matched = should exclude)
                if util.reset_row_text_if_match_keyword_exclude(config_dict, row_text):
                    continue

                if idx < len(area_list):
                    # Store tuple of (element, text, index) for NoDriver keyword matching
                    formated_area_list.append((area_list[idx], row_text, idx))
                    if show_debug_message:
                        print(f"[HKTICKETING AREA] Added to list: idx={idx}, text={row_text[:40]}")
        else:
            print(f"[HKTICKETING AREA] Invalid JS result, trying fallback")
    except Exception as exc:
        print(f"[HKTICKETING AREA] Filter error: {exc}")

    if show_debug_message:
        print("[HKTICKETING AREA] formated_area_list count:", len(formated_area_list))

    if len(formated_area_list) == 0:
        is_need_refresh = True
        return is_need_refresh, is_price_assign_by_bot

    # Match by keyword - same logic as Chrome version (line 7893-7934)
    matched_blocks = []
    matched_index = -1

    # Skip "Best available" special option when keyword is specified
    BEST_AVAILABLE_KEYWORDS = ['best available', 'best avail', '最佳']

    if len(area_keyword_item.strip()) == 0:
        # No keyword, use all areas (but skip "Best available" if there are other options)
        for element, row_text, orig_idx in formated_area_list:
            row_text_lower = row_text.lower()
            is_best_available = any(ba in row_text_lower for ba in BEST_AVAILABLE_KEYWORDS)
            if not is_best_available:
                matched_blocks.append(element)
        # If only "Best available" exists, use it
        if len(matched_blocks) == 0:
            matched_blocks = [item[0] for item in formated_area_list]
    else:
        # Parse keyword - use json.loads to properly handle quoted strings (same as util.py:1390)
        # Input format: "AAA","BBB CC","VIP 2" -> ['AAA', 'BBB CC', 'VIP 2']
        keyword_sets = util.parse_keyword_string_to_array(area_keyword_item)
        if not keyword_sets:
            # Fallback to simple split if json parsing fails
            keyword_sets = [kw.strip() for kw in area_keyword_item.split(',') if kw.strip()]

        if show_debug_message:
            print(f"[HKTICKETING AREA] Keyword sets: {keyword_sets}")

        # Try each keyword set (OR logic between sets)
        for keyword_set in keyword_sets:
            for element, row_text, orig_idx in formated_area_list:
                # Skip "Best available" when using keywords
                row_text_lower = row_text.lower()
                is_best_available = any(ba in row_text_lower for ba in BEST_AVAILABLE_KEYWORDS)
                if is_best_available:
                    if show_debug_message:
                        print(f"[HKTICKETING AREA] Skipping 'Best available' option: {row_text[:40]}")
                    continue

                # Normalize text for comparison
                normalized_text = util.format_keyword_string(row_text)

                # AND logic within keyword set (space-separated keywords)
                # Same as Chrome version line 7920-7925
                keyword_parts = keyword_set.split(' ')
                is_match = True
                for kw in keyword_parts:
                    kw_formatted = util.format_keyword_string(kw)
                    if kw_formatted not in normalized_text:
                        is_match = False
                        break

                if is_match:
                    matched_blocks.append(element)
                    matched_index = orig_idx
                    if show_debug_message:
                        print(f"[HKTICKETING AREA] Keyword '{keyword_set}' matched: idx={orig_idx}, text={row_text[:50]}")
                    # For "from top to bottom" mode, only need first match
                    if auto_select_mode == CONST_FROM_TOP_TO_BOTTOM:
                        break

            if len(matched_blocks) > 0:
                break  # Found matches with this keyword set, stop trying others

    if show_debug_message:
        if matched_blocks:
            print("[HKTICKETING AREA] after match keyword, found count:", len(matched_blocks))

    # Fallback logic (FR-036)
    if not matched_blocks or len(matched_blocks) == 0:
        if area_auto_fallback and len(formated_area_list) > 0:
            if show_debug_message:
                print("[HKTICKETING AREA FALLBACK] area_auto_fallback=true, selecting from all available areas")
            # Extract elements from tuples (element, text, index)
            matched_blocks = [item[0] for item in formated_area_list]
        else:
            if show_debug_message:
                print("[HKTICKETING AREA FALLBACK] area_auto_fallback=false, fallback is disabled")
            is_need_refresh = True
            return is_need_refresh, is_price_assign_by_bot

    target_area = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)
    if target_area:
        try:
            # Debug: get text of element we're about to click
            if show_debug_message:
                try:
                    click_text = await target_area.apply('(el) => el.innerText || el.textContent')
                    print(f"[HKTICKETING AREA] About to click element: {str(click_text)[:60]}")
                except:
                    pass

            # Random delay before clicking (wait for Angular to stabilize)
            await asyncio.sleep(random.uniform(0.3, 0.8))
            await target_area.click()
            is_price_assign_by_bot = True
            if show_debug_message:
                print("[HKTICKETING AREA] Area selected successfully")
        except Exception as exc:
            print("[HKTICKETING AREA] click target_area fail:", exc)

    return is_need_refresh, is_price_assign_by_bot


async def nodriver_hkticketing_ticket_number_auto_select(tab, config_dict):
    """
    Auto select ticket number
    Reference: chrome_tixcraft.py hkticketing_ticket_number_auto_select (line 7962-7966)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict["ticket_number"]

    is_ticket_number_assigned = False
    try:
        result = await tab.evaluate(f'''
            (function() {{
                const select = document.querySelector('select.shortSelect');
                if (!select) return JSON.stringify({{success: false, error: 'select not found'}});

                for (let i = 0; i < select.options.length; i++) {{
                    if (select.options[i].value == "{ticket_number}") {{
                        select.selectedIndex = i;
                        select.value = "{ticket_number}";

                        // Trigger events for Angular binding
                        select.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        select.dispatchEvent(new Event('change', {{ bubbles: true }}));

                        // Try to trigger Angular's ng-change
                        if (typeof angular !== 'undefined') {{
                            try {{
                                angular.element(select).triggerHandler('change');
                            }} catch(e) {{}}
                        }}

                        return JSON.stringify({{success: true, selected: select.value}});
                    }}
                }}
                return JSON.stringify({{success: false, error: 'value not found', options: select.options.length}});
            }})();
        ''')

        if result:
            import json
            result_obj = json.loads(result) if isinstance(result, str) else result
            is_ticket_number_assigned = result_obj.get('success', False) if isinstance(result_obj, dict) else result
            if show_debug_message:
                print(f"[HKTICKETING TICKET] Set ticket number to {ticket_number}: {result}")
    except Exception as exc:
        if show_debug_message:
            print("[HKTICKETING TICKET] Set ticket number fail:", exc)

    return is_ticket_number_assigned


async def nodriver_hkticketing_ticket_delivery_option(tab, config_dict=None):
    """
    Select ticket delivery option
    Reference: chrome_tixcraft.py hkticketing_ticket_delivery_option (line 8024-8063)
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    is_delivery_selected = False
    try:
        result = await tab.evaluate('''
            (function() {
                const select = document.querySelector('#selectDeliveryType');
                if (!select) return { found: false, selected: false };
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value == "1") {
                        select.selectedIndex = i;
                        select.dispatchEvent(new Event('change', { bubbles: true }));
                        return { found: true, selected: true, value: select.options[i].text };
                    }
                }
                return { found: true, selected: false };
            })();
        ''')
        if isinstance(result, dict):
            is_delivery_selected = result.get('selected', False)
            if show_debug_message:
                if result.get('found'):
                    if is_delivery_selected:
                        print(f"[HKTICKETING DELIVERY] Selected: {result.get('value', 'N/A')}")
                    else:
                        print("[HKTICKETING DELIVERY] Select found but value=1 not available")
                else:
                    print("[HKTICKETING DELIVERY] #selectDeliveryType not found")
        else:
            is_delivery_selected = bool(result)
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING DELIVERY] Error: {exc}")

    return is_delivery_selected


async def nodriver_hkticketing_next_button_press(tab, config_dict=None):
    """
    Click next button and wait for URL change
    Reference: chrome_tixcraft.py hkticketing_next_button_press (line 7979-8001)
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    is_button_clicked = False

    # Get current URL before clicking
    current_url = ""
    try:
        current_url = await tab.evaluate('window.location.href')
    except:
        pass

    try:
        el_btn = await tab.query_selector('#continueBar > div.chooseTicketsOfferDiv > button')
        if el_btn:
            if show_debug_message:
                print("[HKTICKETING NEXT] Found button, clicking...")
            await el_btn.click()
            is_button_clicked = True
            if show_debug_message:
                print("[HKTICKETING NEXT] Button clicked successfully")
        else:
            if show_debug_message:
                print("[HKTICKETING NEXT] Button not found on first attempt")
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING NEXT] First attempt error: {exc}")

    # Retry if first attempt failed
    if not is_button_clicked:
        await asyncio.sleep(0.2)
        try:
            el_btn = await tab.query_selector('#continueBar > div.chooseTicketsOfferDiv > button')
            if el_btn:
                if show_debug_message:
                    print("[HKTICKETING NEXT] Retry: Found button, clicking...")
                await el_btn.click()
                is_button_clicked = True
                if show_debug_message:
                    print("[HKTICKETING NEXT] Retry: Button clicked successfully")
            else:
                if show_debug_message:
                    print("[HKTICKETING NEXT] Retry: Button still not found")
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING NEXT] Retry error: {exc}")

    # Wait for URL change after clicking (prevent re-clicking)
    if is_button_clicked and current_url:
        if show_debug_message:
            print("[HKTICKETING NEXT] Waiting for URL change...")
        max_wait = 10  # Max 10 seconds
        wait_interval = 0.5
        waited = 0
        while waited < max_wait:
            await asyncio.sleep(wait_interval)
            waited += wait_interval
            try:
                new_url = await tab.evaluate('window.location.href')
                if new_url != current_url:
                    if show_debug_message:
                        print(f"[HKTICKETING NEXT] URL changed to: {new_url}")
                    break
            except:
                break
        if waited >= max_wait and show_debug_message:
            print("[HKTICKETING NEXT] URL change timeout")

    return is_button_clicked


async def nodriver_hkticketing_go_to_payment(tab, config_dict=None):
    """
    Click go to payment button and wait for URL change
    Reference: chrome_tixcraft.py hkticketing_go_to_payment (line 8002-8023)
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict.get("advanced", {}).get("verbose", False)

    is_button_clicked = False

    # Get current URL before clicking
    current_url = ""
    try:
        current_url = await tab.evaluate('window.location.href')
    except:
        pass

    try:
        el_btn = await tab.query_selector('#goToPaymentButton')
        if el_btn:
            if show_debug_message:
                print("[HKTICKETING PAYMENT] Found button, clicking...")
            await el_btn.click()
            is_button_clicked = True
            if show_debug_message:
                print("[HKTICKETING PAYMENT] Button clicked successfully")
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING PAYMENT] Click error: {exc}")

    # Wait for URL change after clicking (prevent re-clicking)
    if is_button_clicked and current_url:
        if show_debug_message:
            print("[HKTICKETING PAYMENT] Waiting for URL change...")
        max_wait = 15  # Max 15 seconds for payment page
        wait_interval = 0.5
        waited = 0
        while waited < max_wait:
            await asyncio.sleep(wait_interval)
            waited += wait_interval
            try:
                new_url = await tab.evaluate('window.location.href')
                if new_url != current_url:
                    if show_debug_message:
                        print(f"[HKTICKETING PAYMENT] URL changed to: {new_url}")
                    break
            except:
                break
        if waited >= max_wait and show_debug_message:
            print("[HKTICKETING PAYMENT] URL change timeout")

    return is_button_clicked


async def nodriver_hkticketing_hide_tickets_blocks(tab):
    """
    Hide unnecessary page blocks
    Reference: chrome_tixcraft.py hkticketing_hide_tickets_blocks (line 8064-8098)
    """
    try:
        await tab.evaluate('''
            (function() {
                const actionBlock = document.querySelector('.actionBlock');
                if (actionBlock) actionBlock.innerHTML = '';

                const detailModuleCopy = document.querySelector('.detailModuleCopy');
                if (detailModuleCopy) detailModuleCopy.innerHTML = '';

                const mapWrapper = document.querySelector('.mapWrapper');
                if (mapWrapper) mapWrapper.innerHTML = '';
            })();
        ''')
    except Exception as exc:
        pass


# =============================================================================
# HKTicketing Type 02 Functions (hkt.hkticketing.com SPA)
# URL pattern: hkt.hkticketing.com/hant/#/allEvents/detail/selectTicket
# =============================================================================

async def nodriver_hkticketing_type02_clear_session(tab, config_dict=None):
    """
    Clear cookies and localStorage before login to ensure clean session
    This helps avoid stale session data causing login issues
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        # Clear localStorage related to HKTicketing session
        result = await tab.evaluate('''
            (function() {
                var cleared = [];
                try {
                    // Clear specific HKTicketing session keys
                    var keysToRemove = ['ACCOUNT_INFO', 'TOKEN', 'USER_INFO', 'SESSION'];
                    for (var key of keysToRemove) {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            cleared.push(key);
                        }
                    }
                    // Also check for any keys containing 'token' or 'session'
                    for (var i = 0; i < localStorage.length; i++) {
                        var k = localStorage.key(i);
                        if (k && (k.toLowerCase().includes('token') || k.toLowerCase().includes('session') || k.toLowerCase().includes('account'))) {
                            localStorage.removeItem(k);
                            cleared.push(k);
                        }
                    }
                } catch (e) {}
                return { success: true, cleared: cleared };
            })()
        ''')

        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None

        if show_debug_message and result and isinstance(result, dict):
            cleared = result.get('cleared', [])
            if cleared:
                print(f"[HKTICKETING TYPE02] Cleared localStorage keys: {cleared}")

        # Clear cookies via CDP
        try:
            import nodriver.cdp.network as cdp_network
            await tab.send(cdp_network.clear_browser_cookies())
            if show_debug_message:
                print("[HKTICKETING TYPE02] Browser cookies cleared")
        except Exception as cdp_exc:
            if show_debug_message:
                print(f"[HKTICKETING TYPE02] CDP cookie clear error: {cdp_exc}")

        return True

    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Clear session error: {exc}")
        return False


async def nodriver_hkticketing_type02_check_traffic_overload(tab, config_dict=None):
    """
    Check if page shows traffic overload message and click refresh button if found
    Detection: button.mz-no-data-btn with text "刷新"

    Returns:
        bool: True if traffic overload was detected (and refresh clicked), False otherwise
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        result = await tab.evaluate('''
            (function() {
                // Look for the refresh button that indicates traffic overload
                var refreshBtn = document.querySelector('button.mz-no-data-btn');
                if (refreshBtn) {
                    var text = refreshBtn.textContent || refreshBtn.innerText || '';
                    if (text.includes('刷新') || text.includes('重試') || text.includes('Refresh')) {
                        refreshBtn.click();
                        return { found: true, clicked: true, text: text.trim() };
                    }
                }

                // Also check for any large primary button with refresh text
                var buttons = document.querySelectorAll('button.bui-btn-large, button.bui-btn-primary');
                for (var btn of buttons) {
                    var btnText = btn.textContent || btn.innerText || '';
                    if (btnText.includes('刷新') || btnText.includes('重試') || btnText.includes('重新載入')) {
                        btn.click();
                        return { found: true, clicked: true, text: btnText.trim() };
                    }
                }

                // Check for error/loading page indicators
                var noDataDiv = document.querySelector('.mz-no-data, [class*="no-data"], [class*="error-page"]');
                if (noDataDiv) {
                    return { found: true, clicked: false, reason: 'no_data_page_detected' };
                }

                return { found: false };
            })()
        ''')

        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None

        if result and isinstance(result, dict) and result.get('found'):
            if result.get('clicked'):
                print(f"[HKTICKETING TYPE02] Traffic overload detected, clicked refresh: {result.get('text')}")
            elif show_debug_message:
                print(f"[HKTICKETING TYPE02] No data page detected: {result.get('reason')}")
            return True

    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Traffic check error: {exc}")

    return False


async def nodriver_hkticketing_type02_login(tab, config_dict):
    """
    Semi-automatic login for hkt.hkticketing.com (Type 02 SPA)

    Flow:
    1. Auto-fill account/password
    2. Auto-click login button
    3. User manually handles captcha
    4. Wait for login to complete (max 180 seconds)

    Args:
        tab: browser tab
        config_dict: config dictionary

    Returns:
        bool: whether login was successful
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Get account credentials (password already decrypted in settings.py)
    hkticketing_account = config_dict["accounts"]["hkticketing_account"].strip()
    hkticketing_password = config_dict["accounts"]["hkticketing_password"].strip()

    if not hkticketing_account or not hkticketing_password:
        print("[HKTICKETING TYPE02] No account/password configured, please login manually")
        return False

    # Clear existing session data before login to avoid stale session issues
    print("[HKTICKETING TYPE02] Clearing session data before login...")
    await nodriver_hkticketing_type02_clear_session(tab, config_dict)
    await asyncio.sleep(0.3)

    print("[HKTICKETING TYPE02] Starting semi-automatic login...")

    # Step 1: Fill account
    account_filled = False
    account_selectors = [
        'input[name="userEmail"]',
        'input[placeholder*="電子郵件"]',
        'input[placeholder*="email"]',
        'input[type="text"].bui-input-input',
    ]

    for selector in account_selectors:
        try:
            el_account = await tab.query_selector(selector)
            if el_account:
                await el_account.click()
                await el_account.clear_input()
                await el_account.send_keys(hkticketing_account)
                account_filled = True
                if show_debug_message:
                    print(f"[HKTICKETING TYPE02] Account filled using: {selector}")
                break
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING TYPE02] Account selector failed: {selector}, {exc}")
            continue

    if not account_filled:
        print("[HKTICKETING TYPE02] Failed to fill account")
        return False

    await asyncio.sleep(0.3)

    # Step 2: Fill password
    password_filled = False
    password_selectors = [
        'input[name="password"]',
        'input[type="password"]',
        'input[placeholder*="密碼"]',
    ]

    for selector in password_selectors:
        try:
            el_password = await tab.query_selector(selector)
            if el_password:
                await el_password.click()
                await el_password.clear_input()
                await el_password.send_keys(hkticketing_password)
                password_filled = True
                if show_debug_message:
                    print(f"[HKTICKETING TYPE02] Password filled using: {selector}")
                break
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING TYPE02] Password selector failed: {selector}, {exc}")
            continue

    if not password_filled:
        print("[HKTICKETING TYPE02] Failed to fill password")
        return False

    await asyncio.sleep(0.3)

    # Step 3: Click login button
    login_clicked = False
    login_btn_selectors = [
        'button.register-button',
        'button.mz-button.register-button',
        'button.bui-btn-primary',
    ]

    for selector in login_btn_selectors:
        try:
            el_login_btn = await tab.query_selector(selector)
            if el_login_btn:
                # Check if button text contains "登入"
                btn_text = await tab.evaluate(f'''
                    (function() {{
                        var btn = document.querySelector('{selector}');
                        return btn ? btn.textContent : '';
                    }})();
                ''')
                if '登入' in str(btn_text) or 'Login' in str(btn_text):
                    await el_login_btn.click()
                    login_clicked = True
                    if show_debug_message:
                        print(f"[HKTICKETING TYPE02] Login button clicked using: {selector}")
                    break
        except Exception as exc:
            if show_debug_message:
                print(f"[HKTICKETING TYPE02] Login button selector failed: {selector}, {exc}")
            continue

    if not login_clicked:
        print("[HKTICKETING TYPE02] Failed to click login button, please click manually")

    print("[HKTICKETING TYPE02] Please complete captcha verification if prompted...")
    print("[HKTICKETING TYPE02] Waiting for login to complete (max 180 seconds)...")

    # Step 4: Wait for login to complete - simply check URL change
    import time
    timeout = 180  # 3 minutes
    start_time = time.time()
    check_interval = 2

    while (time.time() - start_time) < timeout:
        try:
            # Check URL change (no longer on login page)
            current_url = await tab.evaluate('window.location.href')
            if '#/login' not in current_url:
                print("[HKTICKETING TYPE02] Login successful (URL changed)")
                return True

            # Progress indicator every 30 seconds
            elapsed = int(time.time() - start_time)
            if elapsed > 0 and elapsed % 30 == 0:
                print(f"[HKTICKETING TYPE02] Waiting for login... ({elapsed}s / {timeout}s)")

        except Exception:
            pass  # Silently ignore connection errors during wait

        await asyncio.sleep(check_interval)

    print("[HKTICKETING TYPE02] Login timeout, please check manually")
    return False


async def nodriver_hkticketing_type02_dismiss_modal(tab, config_dict=None):
    """
    Dismiss modal dialog on Type 02 event page

    DOM Structure:
    - Modal: div.bui-modal.modalAndDrawer___MMXN3
    - Button: div.modalAndDrawerFooter > div > button

    Returns:
        bool: whether modal was dismissed
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        result = await tab.evaluate('''
            (function() {
                // Try multiple selectors for modal button
                var selectors = [
                    'div.modalAndDrawerFooter > div > button',
                    'div.modalAndDrawerFooter button',
                    '.bui-modal button',
                    '.modalAndDrawer___MMXN3 button'
                ];

                for (var i = 0; i < selectors.length; i++) {
                    var btn = document.querySelector(selectors[i]);
                    if (btn && btn.offsetParent !== null) {
                        // Scroll button into view first (needed for English version)
                        btn.scrollIntoView({ behavior: 'instant', block: 'center' });
                        btn.click();
                        return { success: true, selector: selectors[i] };
                    }
                }
                return { success: false, error: 'no modal button found' };
            })();
        ''')

        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None

        if result and isinstance(result, dict) and result.get('success'):
            if show_debug_message:
                print(f"[HKTICKETING TYPE02] Modal dismissed via: {result.get('selector')}")
            return True

    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Dismiss modal error: {exc}")

    return False


async def nodriver_hkticketing_type02_event_page_buy_button(tab, config_dict=None):
    """
    Click buy ticket button on Type 02 event page to enter ticket selection

    DOM Structure:
    - Container: div.pcBottomBtn___NiJXB
    - Button: button (contains text like "立即購票", "Buy Now", etc.)

    Returns:
        bool: whether button was clicked
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        result = await tab.evaluate('''
            (function() {
                // Try multiple selectors for buy button
                var selectors = [
                    'div.pcBottomBtn___NiJXB button',
                    'div.pcBottomBtn___NiJXB > button',
                    '.ticketInfoWrapper___n2g2e button',
                    'button.buyBtn___'
                ];

                for (var i = 0; i < selectors.length; i++) {
                    var btn = document.querySelector(selectors[i]);
                    if (btn && btn.offsetParent !== null) {
                        var text = btn.innerText || '';
                        btn.click();
                        return { success: true, selector: selectors[i], text: text };
                    }
                }

                // Fallback: find any button with buy-related text
                var buttons = document.querySelectorAll('button');
                for (var j = 0; j < buttons.length; j++) {
                    var btnText = buttons[j].innerText || '';
                    if (btnText.includes('購票') || btnText.includes('Buy') ||
                        btnText.includes('立即') || btnText.includes('選購')) {
                        buttons[j].click();
                        return { success: true, selector: 'fallback', text: btnText };
                    }
                }

                return { success: false, error: 'no buy button found' };
            })();
        ''')

        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None

        if result and isinstance(result, dict) and result.get('success'):
            if show_debug_message:
                print(f"[HKTICKETING TYPE02] Buy button clicked: {result.get('text')} via {result.get('selector')}")
            return True

    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Buy button error: {exc}")

    return False


async def nodriver_hkticketing_type02_event_page(tab, config_dict):
    """
    Handle Type 02 event page (even.html)
    - Dismiss any modal dialogs
    - Click buy button to enter ticket selection page

    Returns:
        bool: whether successfully navigated to ticket selection
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    print("[HKTICKETING TYPE02] Processing event page...")

    # Step 1: Wait for page to load and dismiss any modal dialogs
    await asyncio.sleep(1.0)
    modal_dismissed = await nodriver_hkticketing_type02_dismiss_modal(tab, config_dict)
    if modal_dismissed:
        print("[HKTICKETING TYPE02] Modal dialog dismissed")
        await asyncio.sleep(0.5)

    # Step 2: Click buy button
    await asyncio.sleep(0.3)
    is_clicked = await nodriver_hkticketing_type02_event_page_buy_button(tab, config_dict)

    if is_clicked:
        if show_debug_message:
            print("[HKTICKETING TYPE02] Navigating to ticket selection page...")
        await asyncio.sleep(0.5)

    return is_clicked


async def nodriver_hkticketing_type02_date_assign(tab, config_dict):
    """
    Type 02 date selection for hkt.hkticketing.com SPA pages

    DOM Structure:
    - Container: div.sessionListWrapper___gDIN1
    - Items: div.sessionList___al29_
    - Selected: has class fouceStyle___Qr7dA
    - Text: div.eventCaption___LUOTP > span

    Returns:
        bool: whether a date has been selected
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["date_auto_select"]["mode"]
    date_keyword = config_dict["date_auto_select"]["date_keyword"].strip()
    date_auto_fallback = config_dict.get("date_auto_fallback", False)

    if show_debug_message:
        print("[HKTICKETING TYPE02 DATE] date_keyword:", date_keyword)

    date_keyword = util.format_keyword_string(date_keyword)

    # Wait for date elements to be rendered (SPA page)
    date_info = None
    for wait_attempt in range(10):
        try:
            date_info = await tab.evaluate('''
                (function() {
                    var items = document.querySelectorAll('div.sessionList___al29_');
                    return items.length;
                })();
            ''')
            if date_info and int(date_info) > 0:
                if show_debug_message:
                    print(f"[HKTICKETING TYPE02 DATE] Found {date_info} date elements after {wait_attempt + 1} attempts")
                break
        except Exception:
            pass
        await asyncio.sleep(0.3)

    if not date_info or int(date_info) == 0:
        if show_debug_message:
            print("[HKTICKETING TYPE02 DATE] No date elements found after waiting")
        return False

    # Get all date items via JavaScript
    is_date_assigned = False
    try:
        date_info = await tab.evaluate('''
            (function() {
                var items = document.querySelectorAll('div.sessionList___al29_');
                var results = [];
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var textEl = item.querySelector('span');
                    var text = textEl ? textEl.innerText.trim() : item.innerText.trim();
                    var isSelected = item.className.includes('fouceStyle');
                    results.push({
                        index: i,
                        text: text,
                        isSelected: isSelected
                    });
                }
                return JSON.stringify(results);
            })();
        ''')

        if date_info and isinstance(date_info, str) and len(date_info) > 2:
            import json
            dates_data = json.loads(date_info)

            if show_debug_message:
                print(f"[HKTICKETING TYPE02 DATE] Found {len(dates_data)} dates")
                for d in dates_data:
                    print(f"  [{d['index']}] {d['text']} {'(selected)' if d['isSelected'] else ''}")

            # Check if already selected AND matches keyword
            selected_date_text = None
            for d in dates_data:
                if d['isSelected']:
                    selected_date_text = d['text']
                    if show_debug_message:
                        print(f"[HKTICKETING TYPE02 DATE] Currently selected: {d['text']}")
                    break

            # If a date is selected, check if it matches the keyword
            if selected_date_text and len(date_keyword) > 0:
                # Check if selected date matches keyword
                normalized_selected = util.format_keyword_string(selected_date_text)
                keyword_sets = util.parse_keyword_string_to_array(date_keyword)
                if not keyword_sets:
                    keyword_sets = [kw.strip() for kw in date_keyword.split(',') if kw.strip()]

                for keyword_set in keyword_sets:
                    keyword_parts = keyword_set.split(' ') if isinstance(keyword_set, str) else [str(keyword_set)]
                    is_match = True
                    for kw in keyword_parts:
                        kw_formatted = util.format_keyword_string(str(kw))
                        if kw_formatted not in normalized_selected:
                            is_match = False
                            break
                    if is_match:
                        is_date_assigned = True
                        if show_debug_message:
                            print(f"[HKTICKETING TYPE02 DATE] Selected date matches keyword, keeping selection")
                        break

                if not is_date_assigned and show_debug_message:
                    print(f"[HKTICKETING TYPE02 DATE] Selected date does not match keyword, will select target date")
            elif selected_date_text and len(date_keyword) == 0:
                # No keyword specified - only keep selection if date_auto_fallback is enabled
                if date_auto_fallback:
                    is_date_assigned = True
                    if show_debug_message:
                        print(f"[HKTICKETING TYPE02 DATE] No keyword, date_auto_fallback=true, keeping current selection")
                else:
                    if show_debug_message:
                        print(f"[HKTICKETING TYPE02 DATE] No keyword, date_auto_fallback=false, will select based on mode")

            if not is_date_assigned and len(dates_data) > 0:
                # Get actual elements for clicking
                date_elements = await tab.query_selector_all('div.sessionList___al29_')
                if not date_elements:
                    return False

                # Build list for keyword matching
                formated_list = []
                for i, d in enumerate(dates_data):
                    if i < len(date_elements):
                        formated_list.append((date_elements[i], d['text'], i))

                matched_blocks = []

                if len(date_keyword) == 0:
                    # No keyword, use all dates
                    matched_blocks = [item[0] for item in formated_list]
                else:
                    # Parse keywords
                    keyword_sets = util.parse_keyword_string_to_array(date_keyword)
                    if not keyword_sets:
                        keyword_sets = [kw.strip() for kw in date_keyword.split(',') if kw.strip()]

                    if show_debug_message:
                        print(f"[HKTICKETING TYPE02 DATE] Keyword sets: {keyword_sets}")

                    # Try each keyword set (OR logic)
                    for keyword_set in keyword_sets:
                        for element, row_text, idx in formated_list:
                            normalized_text = util.format_keyword_string(row_text)

                            # AND logic within keyword set
                            keyword_parts = keyword_set.split(' ') if isinstance(keyword_set, str) else [str(keyword_set)]
                            is_match = True
                            for kw in keyword_parts:
                                kw_formatted = util.format_keyword_string(str(kw))
                                if kw_formatted not in normalized_text:
                                    is_match = False
                                    break

                            if is_match:
                                matched_blocks.append(element)
                                if show_debug_message:
                                    print(f"[HKTICKETING TYPE02 DATE] Matched: {row_text}")
                                if auto_select_mode == CONST_FROM_TOP_TO_BOTTOM:
                                    break

                        if len(matched_blocks) > 0:
                            break

                # Fallback logic
                if not matched_blocks and date_auto_fallback and len(formated_list) > 0:
                    if show_debug_message:
                        print("[HKTICKETING TYPE02 DATE] Fallback enabled, using all dates")
                    matched_blocks = [item[0] for item in formated_list]

                # Select target
                target = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)
                if target:
                    try:
                        await target.click()
                        is_date_assigned = True
                        if show_debug_message:
                            print("[HKTICKETING TYPE02 DATE] Date clicked successfully")
                        await asyncio.sleep(0.3)
                    except Exception as exc:
                        print(f"[HKTICKETING TYPE02 DATE] Click error: {exc}")

    except Exception as exc:
        print(f"[HKTICKETING TYPE02 DATE] Error: {exc}")

    return is_date_assigned


async def nodriver_hkticketing_type02_area_auto_select(tab, config_dict, area_keyword_item):
    """
    Type 02 area selection for hkt.hkticketing.com SPA pages

    DOM Structure:
    - Container: div.levelInfo___ucWy8
    - Items: div.levelItem___rPZ55
    - Disabled: has class disableClass___BDFqG
    - Text: span.ticketInfoContainer___dLjRV > span

    Returns:
        Tuple[bool, bool]: (is_need_refresh, is_area_assigned)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    auto_select_mode = config_dict["area_auto_select"]["mode"]
    area_auto_fallback = config_dict.get("area_auto_fallback", False)

    is_need_refresh = False
    is_area_assigned = False

    if show_debug_message:
        print("[HKTICKETING TYPE02 AREA] area_keyword:", area_keyword_item)

    # Wait for render
    await asyncio.sleep(random.uniform(0.2, 0.4))

    try:
        # Get all area info via JavaScript
        area_info = await tab.evaluate('''
            (function() {
                var items = document.querySelectorAll('div.levelItem___rPZ55');
                var results = [];
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var textEl = item.querySelector('span.ticketInfoContainer___dLjRV span');
                    var text = textEl ? textEl.innerText.trim() : '';
                    var isDisabled = item.className.includes('disableClass');
                    var signEl = item.querySelector('div.sign___gTvXe');
                    var status = signEl ? signEl.innerText.trim() : '';
                    results.push({
                        index: i,
                        text: text,
                        isDisabled: isDisabled,
                        status: status
                    });
                }
                return JSON.stringify(results);
            })();
        ''')

        if area_info and isinstance(area_info, str) and len(area_info) > 2:
            import json
            areas_data = json.loads(area_info)

            if show_debug_message:
                print(f"[HKTICKETING TYPE02 AREA] Found {len(areas_data)} areas")
                for a in areas_data:
                    status_str = f" [{a['status']}]" if a['status'] else ""
                    disabled_str = " (disabled)" if a['isDisabled'] else ""
                    print(f"  [{a['index']}] {a['text']}{status_str}{disabled_str}")

            # Get actual elements
            area_elements = await tab.query_selector_all('div.levelItem___rPZ55')
            if not area_elements:
                is_need_refresh = True
                return is_need_refresh, is_area_assigned

            # Build list of available areas
            formated_list = []
            for i, a in enumerate(areas_data):
                if a['isDisabled']:
                    continue
                if i < len(area_elements):
                    formated_list.append((area_elements[i], a['text'], i))

            if len(formated_list) == 0:
                is_need_refresh = True
                return is_need_refresh, is_area_assigned

            matched_blocks = []

            if len(area_keyword_item.strip()) == 0:
                # No keyword, use all available areas
                matched_blocks = [item[0] for item in formated_list]
            else:
                # Parse keywords
                keyword_sets = util.parse_keyword_string_to_array(area_keyword_item)
                if not keyword_sets:
                    keyword_sets = [kw.strip() for kw in area_keyword_item.split(',') if kw.strip()]

                if show_debug_message:
                    print(f"[HKTICKETING TYPE02 AREA] Keyword sets: {keyword_sets}")

                # Try each keyword set (OR logic)
                for keyword_set in keyword_sets:
                    for element, row_text, idx in formated_list:
                        normalized_text = util.format_keyword_string(row_text)

                        # AND logic within keyword set
                        keyword_parts = keyword_set.split(' ') if isinstance(keyword_set, str) else [str(keyword_set)]
                        is_match = True
                        for kw in keyword_parts:
                            kw_formatted = util.format_keyword_string(str(kw))
                            if kw_formatted not in normalized_text:
                                is_match = False
                                break

                        if is_match:
                            matched_blocks.append(element)
                            if show_debug_message:
                                print(f"[HKTICKETING TYPE02 AREA] Matched: {row_text}")
                            if auto_select_mode == CONST_FROM_TOP_TO_BOTTOM:
                                break

                    if len(matched_blocks) > 0:
                        break

            # Fallback logic
            if not matched_blocks and area_auto_fallback and len(formated_list) > 0:
                if show_debug_message:
                    print("[HKTICKETING TYPE02 AREA] Fallback enabled, using all areas")
                matched_blocks = [item[0] for item in formated_list]

            if not matched_blocks:
                is_need_refresh = True
                return is_need_refresh, is_area_assigned

            # Select target
            target = util.get_target_item_from_matched_list(matched_blocks, auto_select_mode)
            if target:
                try:
                    await asyncio.sleep(random.uniform(0.2, 0.5))
                    await target.click()
                    is_area_assigned = True
                    if show_debug_message:
                        print("[HKTICKETING TYPE02 AREA] Area clicked successfully")
                except Exception as exc:
                    print(f"[HKTICKETING TYPE02 AREA] Click error: {exc}")

    except Exception as exc:
        print(f"[HKTICKETING TYPE02 AREA] Error: {exc}")

    return is_need_refresh, is_area_assigned


async def nodriver_hkticketing_type02_ticket_number_select(tab, config_dict):
    """
    Type 02 ticket number selection

    DOM Structure:
    - Container: div.ticketNumber___lnycu
    - Quantity area: div.buyNum___a5xrK
    - Decrease button: span with SVG #icon-jian
    - Current number: span (middle child)
    - Increase button: span with SVG #icon-jia

    Returns:
        bool: whether ticket number was set
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict.get("ticket_number", 2)

    if show_debug_message:
        print(f"[HKTICKETING TYPE02 TICKET] Target ticket number: {ticket_number}")

    try:
        # Get current ticket number and click + button if needed
        result = await tab.evaluate(f'''
            (function() {{
                var buyNum = document.querySelector('div.buyNum___a5xrK');
                if (!buyNum) return JSON.stringify({{ success: false, error: 'buyNum not found' }});

                var spans = buyNum.querySelectorAll(':scope > span');
                if (spans.length < 3) return JSON.stringify({{ success: false, error: 'spans not found' }});

                var minusBtn = spans[0];
                var currentSpan = spans[1];
                var plusBtn = spans[2];

                var currentNum = parseInt(currentSpan.innerText) || 1;
                var targetNum = {ticket_number};
                var clickCount = 0;

                // Click + button to increase
                while (currentNum < targetNum && clickCount < 10) {{
                    plusBtn.click();
                    clickCount++;
                    currentNum++;
                }}

                // Verify final number
                var finalNum = parseInt(currentSpan.innerText) || currentNum;
                return JSON.stringify({{
                    success: true,
                    initialNum: {ticket_number} - clickCount,
                    finalNum: finalNum,
                    clickCount: clickCount
                }});
            }})();
        ''')

        if result:
            import json
            data = json.loads(result)
            if data.get('success'):
                if show_debug_message:
                    print(f"[HKTICKETING TYPE02 TICKET] Set to {data.get('finalNum')} (clicked + {data.get('clickCount')} times)")
                return True
            else:
                if show_debug_message:
                    print(f"[HKTICKETING TYPE02 TICKET] Error: {data.get('error')}")

    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02 TICKET] Error: {exc}")

    return False


async def nodriver_hkticketing_type02_next_button_press(tab, config_dict=None):
    """
    Click the next step button on Type 02 page

    Returns:
        bool: whether button was clicked
    """
    show_debug_message = False
    if config_dict:
        show_debug_message = config_dict["advanced"].get("verbose", False)

    is_button_clicked = False

    try:
        # Find button containing "下一步" text
        button_clicked = await tab.evaluate('''
            (function() {
                var buttons = document.querySelectorAll('button');
                for (var i = 0; i < buttons.length; i++) {
                    var btn = buttons[i];
                    if (btn.innerText.includes('下一步') || btn.innerText.includes('Next')) {
                        btn.click();
                        return true;
                    }
                }
                return false;
            })();
        ''')

        if button_clicked:
            is_button_clicked = True
            if show_debug_message:
                print("[HKTICKETING TYPE02] Next button clicked")

    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Next button error: {exc}")

    return is_button_clicked


async def nodriver_hkticketing_type02_performance(tab, config_dict):
    """
    Type 02 ticket selection page integration flow
    Handles date selection and area selection on same page

    Returns:
        bool: whether flow completed successfully
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    if show_debug_message:
        print("[HKTICKETING TYPE02] Starting Type 02 flow...")

    # Step 1: Date selection
    is_date_assigned = False
    if config_dict["date_auto_select"]["enable"]:
        is_date_assigned = await nodriver_hkticketing_type02_date_assign(tab, config_dict)
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Date assigned: {is_date_assigned}")
    else:
        is_date_assigned = True  # Skip if disabled

    if not is_date_assigned:
        return False

    # Step 2: Area selection
    is_area_assigned = False
    if config_dict["area_auto_select"]["enable"]:
        area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()
        is_need_refresh, is_area_assigned = await nodriver_hkticketing_type02_area_auto_select(
            tab, config_dict, area_keyword
        )
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Area assigned: {is_area_assigned}")
    else:
        is_area_assigned = True  # Skip if disabled

    if not is_area_assigned:
        return False

    # Step 3: Ticket number selection (after area is selected, quantity selector appears)
    await asyncio.sleep(0.3)
    await nodriver_hkticketing_type02_ticket_number_select(tab, config_dict)

    # Step 4: Click next button
    await asyncio.sleep(0.3)
    await nodriver_hkticketing_type02_next_button_press(tab, config_dict)

    return True


async def nodriver_hkticketing_type02_confirm_order(tab, config_dict):
    """
    Handle HKTicketing Type02 confirm order page (#/confirmOrder)
    Flow:
    1. Select delivery method (QRcode/二維碼取票)
    2. Click agree checkbox (SVG icon)
    3. Click "同意" button in popup dialog
    4. Click submit button (分配座位)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    print("[HKTICKETING TYPE02] Processing confirm order page...")

    # Wait for page to fully load (SPA needs more time)
    await asyncio.sleep(2.5)

    # Step 1: Select delivery method (QRcode)
    # The delivery method might already be selected, but we click it to ensure
    delivery_js = '''
    (function() {
        // Look for QRcode delivery option
        const methods = document.querySelectorAll('.method-item, [class*="method"]');
        for (const m of methods) {
            const text = m.textContent || m.innerText || '';
            if (text.includes('二維碼') || text.includes('QR') || text.includes('電子')) {
                if (!m.classList.contains('method-active')) {
                    m.click();
                    return {success: true, text: text, action: 'clicked'};
                }
                return {success: true, text: text, action: 'already_selected'};
            }
        }
        // If no QRcode found, check if any method is already selected
        const active = document.querySelector('.method-active, [class*="method"][class*="active"]');
        if (active) {
            return {success: true, text: active.textContent, action: 'default_selected'};
        }
        return {success: false, error: 'no_delivery_method_found'};
    })()
    '''
    try:
        result = await tab.evaluate(delivery_js)
        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None
        if result and isinstance(result, dict) and result.get('success'):
            print(f"[HKTICKETING TYPE02] Delivery method: {result.get('text')} ({result.get('action')})")
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Delivery method error: {exc}")

    await asyncio.sleep(0.3)

    # Step 2: Click agree checkbox
    # Pattern 1: Look for agreements container with checkbox
    # Pattern 2: span.agreementIcon___ with SVG (class contains agreementIcon___)
    # Pattern 3: SVG with #icon-weixuanzhong (unchecked) / #icon-xuanzhong (checked)
    agree_js = '''
    (function() {
        // Helper function to get href from use element (handles xlink:href and href)
        function getUseHref(useElem) {
            return useElem.getAttribute('xlink:href') || useElem.getAttribute('href') || useElem.href?.baseVal || '';
        }

        // Pattern 1: Look for checkbox in agreements container (most reliable for HKTicketing)
        const agreementsContainer = document.querySelector('[class*="agreements"], [class*="agreementCheckBox"]');
        if (agreementsContainer) {
            // Find all use elements and check their href
            const uses = agreementsContainer.querySelectorAll('use');
            for (const use of uses) {
                const href = getUseHref(use);
                if (href === '#icon-weixuanzhong') {
                    // Click the parent span (the clickable element)
                    const clickTarget = use.closest('span[role="img"]') || use.closest('span') || use.closest('svg');
                    if (clickTarget) {
                        clickTarget.click();
                        return {success: true, action: 'agreements_container_checkbox_clicked'};
                    }
                }
            }
            // Check if already checked
            for (const use of uses) {
                const href = getUseHref(use);
                if (href === '#icon-xuanzhong' || href === '#icon-yixuanzhong') {
                    return {success: true, action: 'agreements_container_already_checked'};
                }
            }
        }

        // Pattern 2: Look for agreementIcon span (HKTicketing specific)
        // When unselected: class contains "agreementIcon___" but NOT "Selected"
        // When selected: class contains "agreementIconSelected___"
        const agreementIcons = document.querySelectorAll('span[class*="agreementIcon"]');
        for (const icon of agreementIcons) {
            const classList = icon.className || '';
            // Check if it's NOT selected (no "Selected" in class name)
            if (classList.includes('agreementIcon') && !classList.includes('Selected')) {
                icon.click();
                return {success: true, action: 'agreementIcon_clicked'};
            }
        }
        // Check if agreementIcon is already selected
        for (const icon of agreementIcons) {
            const classList = icon.className || '';
            if (classList.includes('Selected')) {
                return {success: true, action: 'agreementIcon_already_selected'};
            }
        }

        // Pattern 3: Look for unchecked checkbox by xlink:href (general pattern)
        const allUses = document.querySelectorAll('use');
        for (const use of allUses) {
            const href = getUseHref(use);
            if (href === '#icon-weixuanzhong') {
                // Find the clickable parent
                let clickTarget = use.closest('span[role="img"]') || use.closest('span') || use.closest('svg');
                if (clickTarget) {
                    // Make sure it's in a checkbox context (not a general icon)
                    const parent = clickTarget.closest('[class*="agreement"], [class*="checkbox"], [class*="check"]');
                    if (parent) {
                        clickTarget.click();
                        return {success: true, action: 'svg_checkbox_clicked'};
                    }
                }
            }
        }
        // Check if SVG checkbox already checked (by searching all uses)
        for (const use of allUses) {
            const href = getUseHref(use);
            if (href === '#icon-xuanzhong' || href === '#icon-yixuanzhong') {
                const parent = use.closest('[class*="agreement"], [class*="checkbox"]');
                if (parent) {
                    return {success: true, action: 'svg_already_checked'};
                }
            }
        }

        // Fallback: look for any checkbox-like element
        const checkboxes = document.querySelectorAll('input[type="checkbox"]:not(:checked), [class*="checkbox"]:not([class*="checked"])');
        for (const cb of checkboxes) {
            cb.click();
            return {success: true, action: 'fallback_checkbox_clicked'};
        }
        return {success: false, error: 'no_checkbox_found', debug: 'agreements_found:' + !!agreementsContainer + ',uses_count:' + allUses.length};
    })()
    '''
    try:
        result = await tab.evaluate(agree_js)
        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None
        if result and isinstance(result, dict) and result.get('success'):
            print(f"[HKTICKETING TYPE02] Agree checkbox: {result.get('action')}")
        else:
            debug_info = result.get('debug', '') if result and isinstance(result, dict) else ''
            print(f"[HKTICKETING TYPE02] Agree checkbox not found ({debug_info}), continuing...")
    except Exception as exc:
        print(f"[HKTICKETING TYPE02] Agree checkbox error: {exc}")

    await asyncio.sleep(0.5)

    # Step 3: Click "同意" button in popup dialog (appears after checkbox click)
    popup_agree_js = '''
    (function() {
        // Look for popup dialog with "同意" button
        // Button class: bui-btn bui-btn-contained bui-btn-large bui-btn-primary mz-button
        const buttons = document.querySelectorAll('button.bui-btn-large.bui-btn-primary, button.mz-button');
        for (const btn of buttons) {
            const text = btn.textContent || btn.innerText || '';
            // Match "同意" but not "同意並關閉" (cookie banner)
            if (text.trim() === '同意' || text.includes('我同意') || text.includes('確認同意')) {
                if (!btn.disabled && btn.offsetParent !== null) {
                    btn.click();
                    return {success: true, text: text.trim()};
                }
            }
        }
        // No popup found - might not have appeared yet or already dismissed
        return {success: false, error: 'no_popup_agree_button'};
    })()
    '''
    try:
        result = await tab.evaluate(popup_agree_js)
        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None
        if result and isinstance(result, dict) and result.get('success'):
            print(f"[HKTICKETING TYPE02] Popup agree button clicked: {result.get('text')}")
            await asyncio.sleep(0.5)  # Wait for popup to close
        else:
            # No popup is normal - it only appears after checkbox click
            pass
    except Exception as exc:
        if show_debug_message:
            print(f"[HKTICKETING TYPE02] Popup agree button error: {exc}")

    await asyncio.sleep(0.3)

    # Step 4: Click submit button (分配座位)
    submit_js = '''
    (function() {
        // Pattern 1: Look for button inside confirmBtn container (most reliable)
        const confirmBtnContainer = document.querySelector('[class*="confirmBtn"]');
        if (confirmBtnContainer) {
            const btn = confirmBtnContainer.querySelector('button');
            if (btn && !btn.disabled) {
                btn.click();
                return {success: true, text: btn.textContent.trim(), action: 'confirmBtn_container'};
            }
        }

        // Pattern 2: Look for the submit button with specific text
        const buttons = document.querySelectorAll('button.mz-button, button.bui-btn-primary, button[type="button"]');
        for (const btn of buttons) {
            const text = btn.textContent || btn.innerText || '';
            // Look for submit keywords
            if (text.includes('分配座位') || text.includes('確認訂單') || text.includes('提交訂單') || text.includes('確認購買')) {
                if (!btn.disabled) {
                    btn.click();
                    return {success: true, text: text.trim()};
                }
                return {success: false, error: 'button_disabled', text: text.trim()};
            }
        }

        // Pattern 3: Look for primary button in bottom bar area (avoid header buttons)
        const bottomBar = document.querySelector('[class*="BottomBar"], [class*="SubmitInfoBar"]');
        if (bottomBar) {
            const btn = bottomBar.querySelector('button.bui-btn-primary:not(:disabled), button.mz-button:not(:disabled)');
            if (btn) {
                btn.click();
                return {success: true, text: btn.textContent.trim(), action: 'bottom_bar_button'};
            }
        }

        // Fallback: look for primary button but exclude known non-submit buttons
        const allButtons = document.querySelectorAll('button.bui-btn-primary:not(:disabled), button.mz-button:not(:disabled)');
        for (const btn of allButtons) {
            const text = btn.textContent || '';
            // Skip buttons that are clearly not submit buttons
            if (text.includes('搜索') || text.includes('搜尋') || text.includes('關閉') || text.includes('取消')) {
                continue;
            }
            btn.click();
            return {success: true, text: text.trim(), action: 'fallback_filtered'};
        }
        return {success: false, error: 'no_submit_button_found'};
    })()
    '''
    try:
        result = await tab.evaluate(submit_js)
        # Handle case where evaluate returns a list instead of dict
        if isinstance(result, list) and len(result) > 0:
            result = result[0] if isinstance(result[0], dict) else None
        if result and isinstance(result, dict) and result.get('success'):
            print(f"[HKTICKETING TYPE02] Submit button clicked: {result.get('text')}")

            # Wait and check if redirected to checkout page
            await asyncio.sleep(1.5)
            try:
                current_url = await tab.evaluate('window.location.href')
                if '#/generateSeat' in str(current_url):
                    print("[HKTICKETING TYPE02] Successfully entered checkout page!")
                    return True
                elif '#/confirmOrder' in str(current_url):
                    # Still on confirm page, might need to retry
                    print("[HKTICKETING TYPE02] Still on confirm page, will retry...")
            except Exception:
                pass

            return True
        else:
            error = result.get('error', 'unknown') if result and isinstance(result, dict) else 'no_result'
            print(f"[HKTICKETING TYPE02] Submit button failed: {error}")
    except Exception as exc:
        print(f"[HKTICKETING TYPE02] Submit button error: {exc}")

    return False


async def nodriver_hkticketing_performance(tab, config_dict, domain_name):
    """
    Ticket selection page integration flow
    Reference: chrome_tixcraft.py hkticketing_performance (line 8099-8172)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Hide unnecessary blocks
    await nodriver_hkticketing_hide_tickets_blocks(tab)

    # Get area keyword (pass full string, function will handle multiple keywords)
    area_keyword = config_dict["area_auto_select"]["area_keyword"].strip()

    is_price_assign_by_bot = False
    is_need_refresh = False

    # Pass full keyword string - function will try all keywords when areas are found
    is_need_refresh, is_price_assign_by_bot = await nodriver_hkticketing_area_auto_select(tab, config_dict, area_keyword)

    if is_price_assign_by_bot:
        # Set ticket number
        await nodriver_hkticketing_ticket_number_auto_select(tab, config_dict)
        await asyncio.sleep(0.1)

        # Select delivery option (not for Galaxy Macau)
        if 'galaxymacau.com' not in domain_name:
            await nodriver_hkticketing_ticket_delivery_option(tab, config_dict)
            await asyncio.sleep(0.1)

        # Click next button
        await nodriver_hkticketing_next_button_press(tab, config_dict)

    return is_price_assign_by_bot


async def nodriver_hkticketing_escape_robot_detection(tab, url):
    """
    Check for robot detection iframe
    Reference: chrome_tixcraft.py hkticketing_escape_robot_detection (line 8173-8200)
    """
    robot_detection = False

    try:
        el_iframe = await tab.query_selector('#main-iframe')
        if el_iframe:
            robot_detection = True
            print("[HKTICKETING] Robot detection iframe detected!")
    except Exception as exc:
        pass

    return robot_detection


async def nodriver_hkticketing_url_redirect(tab, url, config_dict):
    """
    Handle URL redirect for queue and error pages
    Reference: chrome_tixcraft.py hkticketing_url_redirect (line 8201-8262)
    """
    is_redirected = False

    redirect_to_home_list = ['galaxymacau.com', 'ticketek.com']

    for redirect_url in HKTICKETING_REDIRECT_URL_LIST:
        if redirect_url in url:
            # Default entry URL for hkticketing
            entry_url = 'https://entry-hotshow.hkticketing.com/'

            # For macau / ticketek
            for target_site in redirect_to_home_list:
                if target_site in url:
                    domain_name = url.split('/')[2]
                    entry_url = "https://%s/default.aspx" % (domain_name)
                    break

            try:
                await tab.get(entry_url)
                is_redirected = True
                print(f"[HKTICKETING REDIRECT] Redirected to: {entry_url}")
            except Exception as exc:
                pass

            if config_dict["advanced"]["auto_reload_page_interval"] > 0:
                await asyncio.sleep(config_dict["advanced"]["auto_reload_page_interval"])

            if is_redirected:
                break

    # Handle Access denied (403) on entry page
    if url == 'https://entry-hotshow.hkticketing.com/':
        content_redirect_string_list = ['Access denied (403)', 'Current session has been terminated']
        is_need_refresh = False

        try:
            html_body = await tab.get_content()
            if html_body:
                for each_redirect_string in content_redirect_string_list:
                    if each_redirect_string in html_body:
                        is_need_refresh = True
                        break
        except Exception as exc:
            pass

        if is_need_refresh:
            entry_url = "https://hotshow.hkticketing.com/"
            try:
                await tab.get(entry_url)
                is_redirected = True
                print(f"[HKTICKETING REDIRECT] Access denied, redirected to: {entry_url}")
            except Exception as exc:
                pass

    return is_redirected


async def nodriver_hkticketing_content_refresh(tab, url, config_dict):
    """
    Handle content error and refresh page
    Reference: chrome_tixcraft.py hkticketing_content_refresh (line 8264-8343)
    """
    is_redirected = False

    # Check if URL matches patterns that need content checking
    is_check_access_denied = False
    for current_url in HKTICKETING_CHECK_URL_LIST:
        if current_url in url:
            is_check_access_denied = True
            break

    for current_url in HKTICKETING_CHECK_FULL_URL_LIST:
        if current_url == url:
            is_check_access_denied = True
            break

    if is_check_access_denied:
        domain_name = url.split('/')[2]
        new_url = "https://%s/default.aspx" % (domain_name)

        is_need_refresh = False
        try:
            html_body = await tab.get_content()
            if html_body:
                for each_retry_string in HKTICKETING_CONTENT_RETRY_STRING_LIST:
                    if each_retry_string in html_body:
                        is_need_refresh = True
                        break
        except Exception as exc:
            pass

        if is_need_refresh:
            print("[HKTICKETING CONTENT] Start to automatically refresh page.")
            try:
                await tab.get(new_url)
                is_redirected = True
                print(f"[HKTICKETING CONTENT] Redirected to: {new_url}")
            except Exception as exc:
                pass

            if config_dict["advanced"]["auto_reload_page_interval"] > 0:
                await asyncio.sleep(config_dict["advanced"]["auto_reload_page_interval"])

    return is_redirected


async def nodriver_hkticketing_travel_iframe(tab, config_dict):
    """
    Traverse iframes for error detection
    Reference: chrome_tixcraft.py hkticketing_travel_iframe (line 8345-8400)
    """
    is_redirected = False

    try:
        iframe_count = await tab.evaluate('''
            document.querySelectorAll('iframe').length
        ''')

        for idx in range(iframe_count):
            try:
                # Try to get iframe content (same-origin only)
                iframe_content = await tab.evaluate(f'''
                    (function() {{
                        try {{
                            const iframe = document.querySelectorAll('iframe')[{idx}];
                            if (iframe && iframe.contentDocument) {{
                                return iframe.contentDocument.body.innerHTML;
                            }}
                        }} catch(e) {{
                            // Cross-origin iframe cannot be accessed
                        }}
                        return null;
                    }})();
                ''')

                if iframe_content:
                    for error_string in HKTICKETING_CONTENT_RETRY_STRING_LIST:
                        if error_string in iframe_content:
                            # Trigger redirect
                            url = await tab.evaluate('window.location.href')
                            domain_name = url.split('/')[2]
                            new_url = "https://%s/default.aspx" % (domain_name)
                            await tab.get(new_url)
                            is_redirected = True
                            print(f"[HKTICKETING IFRAME] Error detected in iframe, redirected to: {new_url}")
                            break
            except Exception as exc:
                pass

            if is_redirected:
                break

    except Exception as exc:
        pass

    return is_redirected


async def nodriver_hkticketing_main(tab, url, config_dict):
    """
    HKTicketing platform main flow control function
    Reference: chrome_tixcraft.py hkticketing_main logic (line 8400-8461)
    """
    global hkticketing_dict
    if 'hkticketing_dict' not in globals():
        hkticketing_dict = {}
        hkticketing_dict["is_date_submiting"] = False
        hkticketing_dict["fail_list"] = []
        hkticketing_dict["played_sound_ticket"] = False
        hkticketing_dict["played_sound_order"] = False

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Handle URL redirect (queue pages, error pages)
    is_redirected = await nodriver_hkticketing_url_redirect(tab, url, config_dict)
    if is_redirected:
        return tab

    # Handle content refresh (error pages)
    is_redirected = await nodriver_hkticketing_content_refresh(tab, url, config_dict)
    if is_redirected:
        return tab

    # Handle iframe errors
    is_redirected = await nodriver_hkticketing_travel_iframe(tab, config_dict)
    if is_redirected:
        return tab

    # Close cookie popup
    await nodriver_hkticketing_accept_cookie(tab)

    # ==========================================================================
    # Type 02: hkt.hkticketing.com SPA (Vue/React based)
    # URL patterns:
    #   - Login page: hkt.hkticketing.com/hant/#/login
    #   - Event page: hkt.hkticketing.com/hant/#/allEvents/detail/{activityId}
    #   - Ticket page: hkt.hkticketing.com/hant/#/allEvents/detail/selectTicket?activityId=xxx
    #   - Confirm page: hkt.hkticketing.com/hant/#/confirmOrder?eventIds=xxx
    #   - Checkout page: hkt.hkticketing.com/hant/#/generateSeat/{orderId} (success!)
    # ==========================================================================
    is_type02_site = 'hkt.hkticketing.com' in url

    # Check for traffic overload page and auto-refresh (applies to all Type02 pages)
    if is_type02_site:
        is_traffic_overload = await nodriver_hkticketing_type02_check_traffic_overload(tab, config_dict)
        if is_traffic_overload:
            # Traffic overload detected, refresh was clicked, wait and return
            await asyncio.sleep(1.0)
            return tab

    # Type 02 Login Page - set session via localStorage
    is_type02_login_page = False
    if is_type02_site and '#/login' in url:
        is_type02_login_page = True

    if is_type02_login_page:
        if show_debug_message:
            print("[HKTICKETING] Type 02 Login page detected")

        # Semi-automatic login: auto-fill account/password, wait for user to complete captcha
        login_success = await nodriver_hkticketing_type02_login(tab, config_dict)
        if login_success:
            # Redirect to homepage after successful login
            await asyncio.sleep(0.5)
            homepage = config_dict.get("homepage", "").strip()
            if homepage and 'hkt.hkticketing.com' in homepage:
                await tab.get(homepage)
                if show_debug_message:
                    print(f"[HKTICKETING TYPE02] Redirecting to: {homepage}")
            else:
                await tab.get("https://hkt.hkticketing.com/hant/#/home")
                if show_debug_message:
                    print("[HKTICKETING TYPE02] Redirecting to home page")
        return tab

    is_type02_base = is_type02_site and '#/allEvents/detail' in url

    # Type 02 Ticket Selection Page (selectTicket with activityId)
    is_type02_ticket_page = False
    if is_type02_base and 'selectTicket' in url and 'activityId=' in url:
        is_type02_ticket_page = True

    # Type 02 Event Page (detail page without selectTicket)
    is_type02_event_page = False
    if is_type02_base and 'selectTicket' not in url:
        is_type02_event_page = True

    # Handle Type 02 Event Page (even.html) - click buy button to enter ticket selection
    if is_type02_event_page:
        if show_debug_message:
            print("[HKTICKETING] Type 02 Event page detected")

        # Dismiss any modal dialogs and click buy button
        await nodriver_hkticketing_type02_event_page(tab, config_dict)
        return tab

    # Handle Type 02 Ticket Selection Page (datearea.html)
    if is_type02_ticket_page:
        if show_debug_message:
            print("[HKTICKETING] Type 02 Ticket Selection page detected")

        is_modal_dialog_popup = await nodriver_check_modal_dialog_popup(tab)
        if is_modal_dialog_popup:
            if show_debug_message:
                print("[HKTICKETING TYPE02] Modal dialog popup, skip...")
        else:
            # Play sound when entering ticket page
            if not hkticketing_dict.get("played_sound_ticket", False):
                if config_dict["advanced"]["play_sound"]["ticket"]:
                    play_sound_while_ordering(config_dict)
                hkticketing_dict["played_sound_ticket"] = True

            await nodriver_hkticketing_type02_performance(tab, config_dict)

        return tab

    # Type 02 Confirm Order Page (#/confirmOrder)
    is_type02_confirm_page = False
    if is_type02_site and '#/confirmOrder' in url:
        is_type02_confirm_page = True

    if is_type02_confirm_page:
        if show_debug_message:
            print("[HKTICKETING] Type 02 Confirm Order page detected")

        # Handle confirm order: delivery method, agree checkbox, submit button
        await nodriver_hkticketing_type02_confirm_order(tab, config_dict)
        return tab

    # Type 02 Checkout/Payment Page (#/generateSeat) - SUCCESS!
    is_type02_checkout_page = False
    if is_type02_site and '#/generateSeat' in url:
        is_type02_checkout_page = True

    if is_type02_checkout_page:
        print("[HKTICKETING TYPE02] Checkout page detected - Ticket booking SUCCESS!")

        # Play success sound (order) once
        if not hkticketing_dict.get("played_sound_order", False):
            if config_dict["advanced"]["play_sound"]["order"]:
                play_sound_while_ordering(config_dict)
            send_discord_notification(config_dict, "order", "HKTicketing")
        hkticketing_dict["played_sound_order"] = True

        # Show message once
        if not hkticketing_dict.get("shown_checkout_message", False):
            print("[HKTICKETING TYPE02] Please complete payment within the time limit.")
            hkticketing_dict["shown_checkout_message"] = True

        # Stay idle - do not interfere with payment process
        return tab

    # ==========================================================================
    # Type 01: Traditional HKTicketing (ASP.NET based)
    # URL patterns: shows/show.aspx?, /events/.../performances/...
    # ==========================================================================

    # Login page
    is_hkticketing_sign_in_page = False
    if 'hkticketing.com/Secure/ShowLogin.aspx' in url:
        is_hkticketing_sign_in_page = True
    if 'hkticketing.com/Membership/Login.aspx' in url:
        is_hkticketing_sign_in_page = True

    if is_hkticketing_sign_in_page:
        hkticketing_account = config_dict["accounts"]["hkticketing_account"].strip()
        hkticketing_password = config_dict["accounts"]["hkticketing_password"].strip()
        if len(hkticketing_account) > 4:
            login_success = await nodriver_hkticketing_login(tab, hkticketing_account, hkticketing_password)

            # Wait for login to complete and redirect to homepage
            if login_success:
                await asyncio.sleep(1.0)
                try:
                    current_url = await tab.evaluate('window.location.href')
                    homepage = config_dict.get("homepage", "").strip()

                    # If on default page after login, redirect to homepage
                    if homepage and 'hkticketing.com' in homepage:
                        # Skip if already on homepage or homepage is default page
                        is_same_page = (homepage in current_url) or (current_url in homepage)
                        is_homepage_default = 'default.aspx' in homepage or homepage.rstrip('/').endswith('hkticketing.com')

                        if not is_same_page and not is_homepage_default:
                            if 'default.aspx' in current_url or current_url.endswith('/'):
                                if show_debug_message:
                                    print(f"[HKTICKETING LOGIN] Redirecting to event page: {homepage}")
                                await tab.get(homepage)
                                await asyncio.sleep(1.0)
                except Exception as redirect_error:
                    if show_debug_message:
                        print(f"[HKTICKETING LOGIN] Redirect error: {redirect_error}")

    # Date selection page (shows/show.aspx?)
    if 'shows/show.aspx?' in url:
        is_modal_dialog_popup = await nodriver_check_modal_dialog_popup(tab)
        if is_modal_dialog_popup:
            if show_debug_message:
                print("[HKTICKETING] Modal dialog popup, skip...")
        else:
            is_event_page = False
            if len(url.split('/')) == 5:
                is_event_page = True

            if is_event_page:
                if config_dict["date_auto_select"]["enable"]:
                    if not hkticketing_dict["is_date_submiting"]:
                        hkticketing_dict["is_date_submiting"], hkticketing_dict["fail_list"] = await nodriver_hkticketing_date_auto_select(tab, config_dict, hkticketing_dict["fail_list"])
                    else:
                        # Double check buy button status
                        await nodriver_hkticketing_date_buy_button_press(tab, config_dict)
    else:
        hkticketing_dict["is_date_submiting"] = False
        hkticketing_dict["fail_list"] = []

    # Ticket selection page (/events/.../performances/.../tickets or /seatmap)
    if '/events/' in url and '/performances/' in url:
        robot_detection = await nodriver_hkticketing_escape_robot_detection(tab, url)

        is_modal_dialog_popup = await nodriver_check_modal_dialog_popup(tab)
        if is_modal_dialog_popup:
            if show_debug_message:
                print("[HKTICKETING] Modal dialog popup, skip...")
        else:
            if '/tickets' in url:
                domain_name = url.split('/')[2]
                if config_dict["area_auto_select"]["enable"]:
                    # Play sound when entering ticket page
                    if not hkticketing_dict["played_sound_ticket"]:
                        if config_dict["advanced"]["play_sound"]["ticket"]:
                            play_sound_while_ordering(config_dict)
                        hkticketing_dict["played_sound_ticket"] = True

                    await nodriver_hkticketing_performance(tab, config_dict, domain_name)

            if '/seatmap' in url:
                # Go to payment (no scroll needed - CDP can click directly)
                await nodriver_hkticketing_go_to_payment(tab, config_dict)
    else:
        hkticketing_dict["played_sound_ticket"] = False

    return tab


# =============================================================================
# FunOne Tickets Platform Support
# URL: https://tickets.funone.io
# Features: Cookie login, session selection, ticket selection, order submit
# =============================================================================

# Global state dictionary for FunOne
funone_dict = {}

async def nodriver_funone_inject_cookie(tab, config_dict):
    """
    Inject FunOne session cookie using CDP network.set_cookie

    Args:
        tab: NoDriver tab
        config_dict: Configuration dictionary

    Returns:
        bool: True if injection successful
    """
    import nodriver.cdp as cdp

    show_debug_message = config_dict["advanced"].get("verbose", False)
    funone_session_cookie = config_dict["accounts"].get("funone_session_cookie", "").strip()

    if len(funone_session_cookie) == 0:
        if show_debug_message:
            print("[FUNONE] No session cookie configured")
        return False

    try:
        # Inject ticket_session cookie
        await tab.send(cdp.network.set_cookie(
            name="ticket_session",
            value=funone_session_cookie,
            domain="tickets.funone.io",
            path="/",
            secure=False,
            http_only=True
        ))

        if show_debug_message:
            print("[FUNONE] Session cookie injected successfully")
        return True

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Cookie injection failed: {exc}")
        return False


async def nodriver_funone_check_login_status(tab):
    """
    Check if user is logged in by verifying ticket_session cookie exists

    Returns:
        bool: True if logged in (cookie exists and valid)
    """
    try:
        # Cookie verification - check if ticket_session cookie exists
        cookies = await tab.browser.cookies.get_all()
        session_cookie = next((c for c in cookies if c.name == 'ticket_session'), None)
        if session_cookie and len(session_cookie.value) > 10:
            return True
        return False

    except Exception as exc:
        return False


async def nodriver_funone_verify_login(tab, config_dict):
    """
    Verify login status (cookie is already injected in goto_homepage)

    Returns:
        bool: True if logged in
    """
    global funone_dict
    show_debug_message = config_dict["advanced"].get("verbose", False)

    is_logged_in = await nodriver_funone_check_login_status(tab)

    # Only print when login status changes (reduce repetitive messages)
    if is_logged_in:
        if show_debug_message and funone_dict.get("last_login_status") != True:
            print("[FUNONE] Login status verified - logged in")
            funone_dict["last_login_status"] = True
        return True

    if show_debug_message and funone_dict.get("last_login_status") != False:
        print("[FUNONE] Not logged in - waiting for manual OTP login")
        funone_dict["last_login_status"] = False
    return False


async def nodriver_funone_close_popup(tab):
    """
    Close cookie consent and announcement popups

    Returns:
        bool: True if any popup was closed
    """
    closed_any = False

    try:
        # Close common popups
        close_popup_js = '''
        (function() {
            let closed = 0;

            // Close cookie consent
            const cookieButtons = document.querySelectorAll('button, a');
            for (const btn of cookieButtons) {
                const text = (btn.textContent || '').toLowerCase();
                if (text.includes('accept') || text.includes('got it') || text.includes('ok') || text.includes('close')) {
                    if (btn.closest('.cookie') || btn.closest('[class*="consent"]') || btn.closest('[class*="popup"]')) {
                        btn.click();
                        closed++;
                    }
                }
            }

            // Close modal dialogs with close button
            const closeIcons = document.querySelectorAll('[class*="close"], [aria-label="close"], .modal button');
            for (const icon of closeIcons) {
                const style = window.getComputedStyle(icon);
                if (style.display !== 'none' && style.visibility !== 'hidden') {
                    icon.click();
                    closed++;
                }
            }

            return closed;
        })()
        '''
        result = await tab.evaluate(close_popup_js)
        closed_any = result > 0

    except Exception as exc:
        pass

    return closed_any


async def nodriver_funone_date_auto_select(tab, url, config_dict):
    """
    Auto-select session/date on activity detail page

    Returns:
        bool: True if session selected and next button clicked
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Wait for page to fully load before selecting session
    # Check for key elements: next button or activity info
    wait_js = '''
    (function() {
        const buttons = document.querySelectorAll('button');
        for (const btn of buttons) {
            const text = btn.textContent || '';
            if (text.includes('下一步') || text.includes('Next')) {
                return true;
            }
        }
        // Also check for activity title
        const body = document.body.textContent || '';
        if (body.includes('活動場次') || body.includes('活動時間')) {
            return true;
        }
        return false;
    })()
    '''
    page_ready = await tab.evaluate(wait_js)
    page_ready = util.parse_nodriver_result(page_ready)
    if not page_ready:
        # Page not ready, return False to retry next iteration
        return False

    # Get date keyword from config
    date_keyword = config_dict.get("date_auto_select", {}).get("date_keyword", "")
    auto_select_mode = config_dict.get("date_auto_select", {}).get("mode", "random")
    date_auto_fallback = config_dict.get("date_auto_fallback", False)

    if show_debug_message:
        print(f"[FUNONE] Date selection - keyword: '{date_keyword}', mode: {auto_select_mode}")

    try:
        # Get all session options
        get_sessions_js = '''
        (function() {
            const sessions = [];
            // Look for session buttons/options
            const buttons = document.querySelectorAll('button, [role="button"], .session-item, [class*="session"], [class*="date"]');

            for (const btn of buttons) {
                const text = btn.textContent || '';
                const isDisabled = btn.disabled || btn.classList.contains('disabled') || btn.classList.contains('sold-out');

                // Filter out non-session buttons
                if (text.length > 3 && text.length < 200 && !isDisabled) {
                    // Check if it looks like a date/session
                    if (/\\d{4}|\\d{1,2}[/.-]\\d{1,2}|\\d{1,2}:\\d{2}/.test(text) ||
                        text.includes('場') || text.includes('場次')) {
                        sessions.push({
                            text: text.trim(),
                            index: sessions.length
                        });
                    }
                }
            }
            return sessions;
        })()
        '''
        sessions = await tab.evaluate(get_sessions_js)

        if not sessions or len(sessions) == 0:
            if show_debug_message:
                print("[FUNONE] No sessions found")
            return False

        if show_debug_message:
            print(f"[FUNONE] Found {len(sessions)} sessions")

        # Find matching session by keyword
        target_index = -1

        if date_keyword and len(date_keyword) > 0:
            keywords = util.parse_keyword_string_to_array(date_keyword)

            for i, session in enumerate(sessions):
                session_text = session.get('text', '')
                for kw in keywords:
                    if kw.lower() in session_text.lower():
                        target_index = i
                        if show_debug_message:
                            print(f"[FUNONE] Keyword '{kw}' matched session: {session_text}")
                        break
                if target_index >= 0:
                    break

        # Fallback selection if no keyword match
        if target_index < 0:
            if date_keyword and len(date_keyword) > 0 and not date_auto_fallback:
                if show_debug_message:
                    print("[FUNONE] No keyword match, date_auto_fallback=False, stopping")
                return False

            # Use auto_select_mode for fallback
            target_index = util.get_target_index_by_mode(len(sessions), auto_select_mode)
            if show_debug_message:
                print(f"[FUNONE] Using fallback mode '{auto_select_mode}', selected index: {target_index}")

        if target_index < 0 or target_index >= len(sessions):
            target_index = 0

        # Click the selected session
        click_session_js = f'''
        (function() {{
            const sessions = [];
            const buttons = document.querySelectorAll('button, [role="button"], .session-item, [class*="session"], [class*="date"]');

            for (const btn of buttons) {{
                const text = btn.textContent || '';
                const isDisabled = btn.disabled || btn.classList.contains('disabled') || btn.classList.contains('sold-out');

                if (text.length > 3 && text.length < 200 && !isDisabled) {{
                    if (/\\d{{4}}|\\d{{1,2}}[/.-]\\d{{1,2}}|\\d{{1,2}}:\\d{{2}}/.test(text) ||
                        text.includes('場') || text.includes('場次')) {{
                        sessions.push(btn);
                    }}
                }}
            }}

            if (sessions.length > {target_index}) {{
                sessions[{target_index}].click();
                return true;
            }}
            return false;
        }})()
        '''
        clicked = await tab.evaluate(click_session_js)

        if clicked:
            if show_debug_message:
                print(f"[FUNONE] Session {target_index} clicked")
            await tab.sleep(0.5)

            # Click next button
            click_next_js = '''
            (function() {
                const buttons = document.querySelectorAll('button, a');
                for (const btn of buttons) {
                    const text = (btn.textContent || '').trim();
                    if (text === '下一步' || text === 'Next' || text.includes('下一步')) {
                        btn.click();
                        return true;
                    }
                }
                return false;
            })()
            '''
            next_clicked = await tab.evaluate(click_next_js)

            if next_clicked and show_debug_message:
                print("[FUNONE] Next button clicked")

            return next_clicked

        return False

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Date selection error: {exc}")
        return False


async def nodriver_funone_area_auto_select(tab, url, config_dict):
    """
    Auto-select ticket type on ticket selection page

    Returns:
        bool: True if ticket type selected
    """
    global funone_dict
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Get area keyword from config
    area_keyword = config_dict.get("area_auto_select", {}).get("area_keyword", "")
    auto_select_mode = config_dict.get("area_auto_select", {}).get("mode", "random")
    keyword_exclude = config_dict.get("keyword_exclude", "")
    area_auto_fallback = config_dict.get("area_auto_fallback", False)

    # Only print area selection config once
    area_config_key = f"{area_keyword}_{auto_select_mode}"
    if show_debug_message and funone_dict.get("last_area_config") != area_config_key:
        print(f"[FUNONE] Area selection - keyword: '{area_keyword}', mode: {auto_select_mode}")
        funone_dict["last_area_config"] = area_config_key

    try:
        # Get all ticket areas (FunOne uses div.zone_box elements)
        # IMPORTANT: Only look for .zone_box elements, do NOT fallback to generic buttons
        # Generic button search would incorrectly match ticket type names on quantity selection pages
        get_tickets_js = '''
        (function() {
            const tickets = [];

            // Only FunOne-specific zone_box elements (area selection page)
            const zoneBoxes = document.querySelectorAll('.zone_box');
            if (zoneBoxes.length > 0) {
                for (const box of zoneBoxes) {
                    // Use innerText for more reliable text extraction (rendered text)
                    const fullText = (box.innerText || box.textContent || '').trim().replace(/\\s+/g, ' ');
                    const isDisabled = box.classList.contains('disabled');

                    // Get zone name - try multiple methods
                    let name = '';
                    const zoneName = box.querySelector('.zone_name');
                    if (zoneName) {
                        name = (zoneName.innerText || zoneName.textContent || '').trim();
                    }
                    // Fallback: use first line of fullText
                    if (!name && fullText) {
                        name = fullText.split(/[\\n\\r]|\\u70ed|\\u5df2/)[0].trim();
                    }

                    tickets.push({
                        text: name,
                        fullText: fullText,
                        index: tickets.length,
                        disabled: isDisabled,
                        type: 'zone_box'
                    });
                }
            }

            // No fallback - if no zone_box found, return empty array
            // This page is likely a ticket quantity selection page, not area selection
            return tickets;
        })()
        '''
        tickets = await tab.evaluate(get_tickets_js)

        # Convert CDP format to Python dict if needed
        # NoDriver may return CDP format: {'type': 'object', 'value': [['key', {'type': 'string', 'value': 'val'}], ...]}
        def parse_cdp_value(item):
            if isinstance(item, dict) and 'type' in item and 'value' in item:
                if item['type'] == 'object' and isinstance(item['value'], list):
                    # Convert [['key', {'type': 'string', 'value': 'val'}], ...] to {'key': 'val', ...}
                    result = {}
                    for pair in item['value']:
                        if isinstance(pair, list) and len(pair) == 2:
                            key, val_obj = pair
                            if isinstance(val_obj, dict) and 'value' in val_obj:
                                result[key] = val_obj['value']
                            else:
                                result[key] = val_obj
                    return result
                else:
                    return item['value']
            return item

        if tickets:
            tickets = [parse_cdp_value(t) for t in tickets]

        if not tickets or len(tickets) == 0:
            # Only print "No ticket types found" if we previously found some
            if show_debug_message and funone_dict.get("last_area_count", -1) != 0:
                print("[FUNONE] No ticket types found")
                funone_dict["last_area_count"] = 0
            return False

        # Only print ticket count when it changes
        if show_debug_message and funone_dict.get("last_area_count") != len(tickets):
            print(f"[FUNONE] Found {len(tickets)} ticket types")
            funone_dict["last_area_count"] = len(tickets)

        # Filter out disabled (sold out) tickets first
        available_tickets = [t for t in tickets if not t.get('disabled', False)]
        if show_debug_message and len(available_tickets) != len(tickets):
            sold_out_count = len(tickets) - len(available_tickets)
            print(f"[FUNONE] {sold_out_count} ticket types sold out, {len(available_tickets)} available")

        if len(available_tickets) == 0:
            if show_debug_message:
                print("[FUNONE] All ticket types are sold out")
            return False

        tickets = available_tickets

        # Apply exclude keywords first (using standard util function)
        if keyword_exclude and len(keyword_exclude) > 0:
            filtered_tickets = []
            for ticket in tickets:
                # Use text first, fallback to fullText for keyword matching
                ticket_text = ticket.get('text', '') or ticket.get('fullText', '')
                if ticket_text and util.reset_row_text_if_match_keyword_exclude(config_dict, ticket_text):
                    if show_debug_message:
                        print(f"[FUNONE] Excluding ticket '{ticket_text[:50]}'")
                else:
                    filtered_tickets.append(ticket)
            tickets = filtered_tickets

        if len(tickets) == 0:
            if show_debug_message:
                print("[FUNONE] All tickets filtered out by exclude keywords")
            return False

        # Find matching ticket by keyword
        target_index = -1

        if area_keyword and len(area_keyword) > 0:
            keywords = util.parse_keyword_string_to_array(area_keyword)

            for i, ticket in enumerate(tickets):
                # Use text first, fallback to fullText for keyword matching
                ticket_text = ticket.get('text', '') or ticket.get('fullText', '')
                if not ticket_text:
                    continue
                for kw in keywords:
                    if kw.lower() in ticket_text.lower():
                        target_index = i
                        if show_debug_message:
                            print(f"[FUNONE] Keyword '{kw}' matched ticket: {ticket_text[:50]}")
                        break
                if target_index >= 0:
                    break

        # Fallback selection if no keyword match
        if target_index < 0:
            if area_keyword and len(area_keyword) > 0 and not area_auto_fallback:
                if show_debug_message:
                    print("[FUNONE] No keyword match, area_auto_fallback=False, stopping")
                return False

            target_index = util.get_target_index_by_mode(len(tickets), auto_select_mode)
            if show_debug_message:
                print(f"[FUNONE] Using fallback mode '{auto_select_mode}', selected index: {target_index}")

        if target_index < 0 or target_index >= len(tickets):
            target_index = 0

        # Click the selected ticket type
        original_index = tickets[target_index].get('index', target_index)
        ticket_type = tickets[target_index].get('type', 'button')
        ticket_name = tickets[target_index].get('text', '') or tickets[target_index].get('fullText', '')

        if show_debug_message:
            print(f"[FUNONE] Clicking area '{ticket_name}' (index: {original_index}, type: {ticket_type})")

        click_ticket_js = f'''
        (function() {{
            // First try FunOne-specific zone_box elements
            const zoneBoxes = document.querySelectorAll('.zone_box');
            if (zoneBoxes.length > 0) {{
                const availableBoxes = [];
                for (const box of zoneBoxes) {{
                    if (!box.classList.contains('disabled')) {{
                        availableBoxes.push(box);
                    }}
                }}
                if (availableBoxes.length > {original_index}) {{
                    availableBoxes[{original_index}].click();
                    return true;
                }}
            }}

            // Fallback to generic button search
            const items = document.querySelectorAll('button, [role="button"], .ticket-type, [class*="ticket"], [class*="area"]');
            const tickets = [];

            for (const item of items) {{
                const text = item.textContent || '';
                const isDisabled = item.disabled || item.classList.contains('disabled') || item.classList.contains('sold-out');

                if (text.length > 2 && text.length < 300 && !isDisabled) {{
                    if (/\\$|NT|TWD|\\d+元|區|票/.test(text) || text.includes('票種')) {{
                        tickets.push(item);
                    }}
                }}
            }}

            if (tickets.length > {original_index}) {{
                tickets[{original_index}].click();
                return true;
            }}
            return false;
        }})()
        '''
        clicked = await tab.evaluate(click_ticket_js)

        if clicked and show_debug_message:
            print(f"[FUNONE] Ticket type {target_index} clicked")

        return clicked

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Area selection error: {exc}")
        return False


async def nodriver_funone_check_sold_out(tab, config_dict):
    """
    Check if all tickets are sold out on purchase_choose_ticket_no_map page

    Returns:
        tuple: (is_sold_out: bool, remaining_count: int, ticket_info: list)
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict.get("ticket_number", 2)
    area_keyword = config_dict.get("area_auto_select", {}).get("area_keyword", "")

    # Parse keywords
    keywords = []
    if area_keyword:
        clean_keyword = area_keyword.replace('"', '').replace("'", '')
        keywords = [k.strip() for k in clean_keyword.split(',') if k.strip()]

    try:
        check_sold_out_js = f'''
        (function() {{
            const keywords = {keywords};
            const ticketInfo = [];
            let totalRemaining = 0;
            let matchedRemaining = 0;
            let hasMatchedTicket = false;
            let allSoldOut = true;
            let hasPurchaseButton = false;
            let purchaseButtonDisabled = true;

            // Use TreeWalker to find text nodes containing remaining count
            // This avoids duplicate counting from nested elements
            const pattern = /(?:剩餘|remaining)\\s*(\\d+)/i;
            const processedRows = new Set();

            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            while (node = walker.nextNode()) {{
                const text = node.textContent || '';
                const remainingMatch = text.match(pattern);

                if (remainingMatch) {{
                    const remaining = parseInt(remainingMatch[1]);

                    // Find the ticket row container to get context
                    let container = node.parentElement;
                    if (container) {{
                        container = container.closest('div[class*="ticket"], div[class*="row"], tr, li') || container.parentElement;
                    }}

                    // Use container reference to avoid duplicate processing
                    if (container && processedRows.has(container)) {{
                        continue;
                    }}
                    if (container) {{
                        processedRows.add(container);
                    }}

                    const rowText = container ? container.textContent : text;

                    // Check if this matches any keyword
                    let matched = keywords.length === 0;
                    for (const kw of keywords) {{
                        if (kw && rowText.toLowerCase().includes(kw.toLowerCase())) {{
                            matched = true;
                            break;
                        }}
                    }}

                    ticketInfo.push({{
                        remaining: remaining,
                        text: rowText.substring(0, 100),
                        matched: matched
                    }});

                    totalRemaining += remaining;
                    if (matched) {{
                        matchedRemaining += remaining;
                        hasMatchedTicket = true;
                    }}
                    if (remaining > 0) {{
                        allSoldOut = false;
                    }}
                }}
            }}

            // Check +/- buttons status
            // FUNONE uses SVG icons for +/- buttons, need to check btn-tertiary class
            const buttons = document.querySelectorAll('button');
            let allButtonsDisabled = true;

            for (const btn of buttons) {{
                const btnText = btn.textContent.trim();
                const classList = Array.from(btn.classList);

                // Check for +/- buttons (btn-tertiary, but not refresh button)
                if (classList.includes('btn-tertiary') && !classList.includes('round_info_refresh')) {{
                    // Check if this is a plus button by examining SVG path
                    const svg = btn.querySelector('svg');
                    if (svg) {{
                        const path = svg.querySelector('path');
                        if (path) {{
                            const d = path.getAttribute('d') || '';
                            // Plus button path starts with 'M11 13H' (has vertical line)
                            // Minus button path starts with 'M6 13C' (only horizontal line)
                            if (d.startsWith('M11')) {{
                                // This is a plus button
                                if (!btn.disabled) {{
                                    allButtonsDisabled = false;
                                }}
                            }}
                        }}
                    }}
                }}

                // Check for purchase/submit button (Chinese and English)
                if (btnText.includes('立即購買') || btnText.includes('Purchase') ||
                    btnText.includes('Confirm') || btnText.includes('submit')) {{
                    hasPurchaseButton = true;
                    purchaseButtonDisabled = btn.disabled;
                }}
            }}

            // If no remaining info found, try alternative detection via buttons
            if (ticketInfo.length === 0) {{
                const inputs = document.querySelectorAll('input[type="text"], input[type="number"]');
                for (const input of inputs) {{
                    const parent = input.parentElement;
                    if (parent) {{
                        const plusBtn = parent.querySelector('button:not(:disabled)');
                        if (plusBtn) {{
                            allSoldOut = false;
                        }}
                    }}
                }}
            }}

            // Determine if sold out
            const isSoldOut = (ticketInfo.length > 0 && allSoldOut) ||
                              (allButtonsDisabled && hasPurchaseButton && purchaseButtonDisabled);

            return {{
                isSoldOut: isSoldOut,
                totalRemaining: totalRemaining,
                matchedRemaining: hasMatchedTicket ? matchedRemaining : totalRemaining,
                hasMatchedTicket: hasMatchedTicket,
                ticketInfo: ticketInfo,
                allButtonsDisabled: allButtonsDisabled,
                purchaseButtonDisabled: purchaseButtonDisabled
            }};
        }})()
        '''
        result = await tab.evaluate(check_sold_out_js)
        result = util.parse_nodriver_result(result)

        if result and isinstance(result, dict):
            is_sold_out = result.get('isSoldOut', False)
            remaining = result.get('matchedRemaining', 0) if result.get('hasMatchedTicket') else result.get('totalRemaining', 0)
            ticket_info = result.get('ticketInfo', [])

            if show_debug_message:
                if is_sold_out:
                    print("[FUNONE] All tickets sold out")

            return (is_sold_out, remaining, ticket_info)

        return (False, 0, [])

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Check sold out error: {exc}")
        return (False, 0, [])


async def nodriver_funone_click_refresh_button(tab, config_dict):
    """
    Click the "instant ticket status update" button to refresh ticket status via WebSocket

    Returns:
        bool: True if button clicked successfully
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        click_refresh_js = '''
        (function() {
            // Find the refresh button - look for text containing "instant update" or similar
            const buttons = document.querySelectorAll('button, div[role="button"], a[role="button"]');

            for (const btn of buttons) {
                const text = btn.textContent || '';
                // Match various refresh button patterns
                if (text.includes('instant') || text.includes('Instant') ||
                    text.includes('update') || text.includes('Update') ||
                    text.includes('refresh') || text.includes('Refresh') ||
                    text.includes('reload') || text.includes('Reload')) {
                    if (!btn.disabled) {
                        btn.click();
                        return { success: true, buttonText: text.substring(0, 50) };
                    }
                }
            }

            // Fallback: look for button with refresh icon (SVG with certain classes)
            const iconButtons = document.querySelectorAll('button svg, button i[class*="refresh"], button i[class*="sync"]');
            for (const icon of iconButtons) {
                const btn = icon.closest('button');
                if (btn && !btn.disabled) {
                    btn.click();
                    return { success: true, buttonText: 'icon_button' };
                }
            }

            return { success: false, reason: 'no_refresh_button_found' };
        })()
        '''
        result = await tab.evaluate(click_refresh_js)
        result = util.parse_nodriver_result(result)

        if result and isinstance(result, dict) and result.get('success'):
            if show_debug_message:
                print(f"[FUNONE] Clicked refresh button: {result.get('buttonText', 'unknown')}")
            return True
        else:
            if show_debug_message:
                print("[FUNONE] Refresh button not found")
            return False

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Click refresh button error: {exc}")
        return False


async def nodriver_funone_assign_ticket_number(tab, config_dict):
    """
    Set ticket quantity for the ticket type matching keyword

    Returns:
        bool: True if quantity set successfully
    """
    global funone_dict
    show_debug_message = config_dict["advanced"].get("verbose", False)
    ticket_number = config_dict.get("ticket_number", 2)
    area_keyword = config_dict.get("area_auto_select", {}).get("area_keyword", "")
    keyword_exclude = config_dict.get("keyword_exclude", "")

    # Parse keywords
    keywords = []
    if area_keyword:
        # Remove quotes and split by comma
        clean_keyword = area_keyword.replace('"', '').replace("'", '')
        keywords = [k.strip() for k in clean_keyword.split(',') if k.strip()]

    exclude_keywords = []
    if keyword_exclude:
        clean_exclude = keyword_exclude.replace('"', '').replace("'", '')
        exclude_keywords = [k.strip() for k in clean_exclude.split(',') if k.strip()]

    # Only print setting message once
    if show_debug_message and funone_dict.get("last_ticket_qty") != ticket_number:
        print(f"[FUNONE] Setting ticket quantity to {ticket_number}")
        funone_dict["last_ticket_qty"] = ticket_number

    try:
        # FunOne-specific: Find ticket row by keyword and click its + button
        set_quantity_js = f'''
        (function() {{
            const targetQty = {ticket_number};
            const keywords = {keywords};
            const excludeKeywords = {exclude_keywords};

            // FunOne ticket selection page structure:
            // Each ticket row has: [ticket name] [price] [- button] [textbox] [+ button]
            // We need to find the row matching keyword and click its + button

            // Get all input elements (quantity boxes)
            const inputs = document.querySelectorAll('input');
            let targetInput = null;
            let targetPlusBtn = null;
            let matchedName = '';

            for (const input of inputs) {{
                // Check if this looks like a quantity input
                const val = parseInt(input.value);
                if (isNaN(val) || val < 0 || val > 100) continue;

                // Find the ticket row container (traverse up to find text context)
                let container = input.parentElement;
                let depth = 0;
                let rowText = '';

                // Go up a few levels to find the row containing ticket name
                while (container && depth < 5) {{
                    rowText = container.textContent || '';
                    // Check if this container has ticket info (price pattern)
                    if (/TWD|NT\$|\d+元/.test(rowText)) {{
                        break;
                    }}
                    container = container.parentElement;
                    depth++;
                }}

                if (!rowText) continue;

                // Check exclude keywords first
                let excluded = false;
                for (const exc of excludeKeywords) {{
                    if (exc && rowText.toLowerCase().includes(exc.toLowerCase())) {{
                        excluded = true;
                        break;
                    }}
                }}
                if (excluded) continue;

                // Check if this row matches any keyword
                let matched = keywords.length === 0; // If no keyword, match first valid row
                for (const kw of keywords) {{
                    if (kw && rowText.toLowerCase().includes(kw.toLowerCase())) {{
                        matched = true;
                        matchedName = kw;
                        break;
                    }}
                }}

                if (matched) {{
                    targetInput = input;
                    // Find the + button near this input
                    const parent = input.parentElement;
                    if (parent) {{
                        const children = Array.from(parent.children);
                        const inputIndex = children.indexOf(input);

                        // Find button after the input (+ button)
                        for (let i = inputIndex + 1; i < children.length; i++) {{
                            if (children[i].tagName === 'BUTTON' && !children[i].disabled) {{
                                targetPlusBtn = children[i];
                                break;
                            }}
                        }}

                        // If not found, try sibling buttons
                        if (!targetPlusBtn) {{
                            const buttons = parent.querySelectorAll('button:not([disabled])');
                            for (const btn of buttons) {{
                                // The + button is typically after the input or has no text (icon-based)
                                const btnText = btn.textContent.trim();
                                if (btnText === '+' || btnText === '') {{
                                    // Check position relative to input
                                    const btnIndex = children.indexOf(btn);
                                    if (btnIndex > inputIndex) {{
                                        targetPlusBtn = btn;
                                        break;
                                    }}
                                }}
                            }}
                        }}
                    }}

                    if (targetPlusBtn) break;
                }}
            }}

            // Click the + button to set quantity
            if (targetPlusBtn && targetInput) {{
                const currentVal = parseInt(targetInput.value) || 0;
                const clicksNeeded = targetQty - currentVal;

                if (clicksNeeded > 0) {{
                    for (let i = 0; i < clicksNeeded; i++) {{
                        targetPlusBtn.click();
                    }}
                    return {{ success: true, type: 'keyword_match', value: targetQty, clicks: clicksNeeded, keyword: matchedName }};
                }} else if (clicksNeeded === 0) {{
                    return {{ success: true, type: 'already_set', value: targetQty, keyword: matchedName }};
                }}
            }}

            // Fallback: Try first available quantity control
            for (const input of inputs) {{
                const val = parseInt(input.value);
                if (isNaN(val) || val < 0 || val > 100) continue;

                const parent = input.parentElement;
                if (!parent) continue;

                const children = Array.from(parent.children);
                const inputIndex = children.indexOf(input);

                for (let i = inputIndex + 1; i < children.length; i++) {{
                    if (children[i].tagName === 'BUTTON' && !children[i].disabled) {{
                        const currentVal = parseInt(input.value) || 0;
                        const clicksNeeded = targetQty - currentVal;
                        if (clicksNeeded > 0) {{
                            for (let j = 0; j < clicksNeeded; j++) {{
                                children[i].click();
                            }}
                            return {{ success: true, type: 'fallback', value: targetQty, clicks: clicksNeeded }};
                        }}
                        break;
                    }}
                }}
            }}

            return {{ success: false, reason: 'no_quantity_control_found' }};
        }})()
        '''
        result = await tab.evaluate(set_quantity_js)
        result = util.parse_nodriver_result(result)

        if result and isinstance(result, dict) and result.get('success'):
            if show_debug_message:
                print(f"[FUNONE] Ticket quantity set to {result.get('value')} via {result.get('type')}")
            funone_dict["qty_selector_notfound"] = False  # Reset flag on success
            return True
        else:
            # Only print once when quantity selector not found
            if show_debug_message and not funone_dict.get("qty_selector_notfound"):
                print("[FUNONE] Could not find quantity selector")
                funone_dict["qty_selector_notfound"] = True
            return False

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Set quantity error: {exc}")
        return False


async def nodriver_funone_captcha_handler(tab, config_dict):
    """
    Handle captcha - detect and auto-fill using OCR

    Returns:
        bool: True if captcha is filled or no captcha exists
    """
    global funone_dict
    show_debug_message = config_dict["advanced"].get("verbose", False)
    ocr_enabled = config_dict.get("ocr_captcha", {}).get("enable", False)

    try:
        # Check for captcha image and input
        # FunOne uses img[alt="vCode"] with base64 data URI
        check_captcha_js = '''
        (function() {
            // Look for FunOne captcha image (alt="vCode" with base64 src)
            const captchaImg = document.querySelector('img[alt="vCode"]');
            if (captchaImg) {
                const src = captchaImg.src || '';
                // FunOne captcha is embedded as base64
                if (src.startsWith('data:image')) {
                    // Find the corresponding input field
                    const inputs = document.querySelectorAll('input[type="text"]');
                    let captchaInput = null;
                    for (const input of inputs) {
                        const placeholder = (input.placeholder || '').toLowerCase();
                        if (placeholder.includes('驗證') || placeholder.includes('captcha')) {
                            captchaInput = input;
                            break;
                        }
                    }
                    return {
                        hasCaptcha: true,
                        type: 'base64',
                        base64Data: src,
                        filled: captchaInput ? captchaInput.value.length > 0 : false
                    };
                }
            }

            // Fallback: Look for any captcha-related image
            const imgs = document.querySelectorAll('img');
            for (const img of imgs) {
                const src = img.src || '';
                const alt = img.alt || '';
                if (src.includes('captcha') || alt.includes('captcha') || alt.includes('驗證')) {
                    return { hasCaptcha: true, type: 'image', filled: false };
                }
            }

            // Look for captcha input to check if filled
            const inputs = document.querySelectorAll('input');
            for (const input of inputs) {
                const name = (input.name || '').toLowerCase();
                const placeholder = (input.placeholder || '').toLowerCase();
                if (name.includes('captcha') || placeholder.includes('驗證') || placeholder.includes('captcha')) {
                    const value = input.value || '';
                    return { hasCaptcha: true, type: 'input', filled: value.length > 0 };
                }
            }

            return { hasCaptcha: false };
        })()
        '''
        captcha_info = await tab.evaluate(check_captcha_js)
        captcha_info = util.parse_nodriver_result(captcha_info)

        if not captcha_info or not isinstance(captcha_info, dict) or not captcha_info.get('hasCaptcha'):
            # No captcha found
            return True

        # Only print captcha type once
        captcha_type = captcha_info.get('type')
        if show_debug_message and funone_dict.get("last_captcha_type") != captcha_type:
            print(f"[FUNONE] Captcha detected - type: {captcha_type}")
            funone_dict["last_captcha_type"] = captcha_type

        # Check if already filled
        if captcha_info.get('filled'):
            # Only print once to reduce repetitive messages
            if show_debug_message and not funone_dict.get("captcha_filled_printed"):
                print("[FUNONE] Captcha already filled")
                funone_dict["captcha_filled_printed"] = True
            return True

        # Play sound once to alert user
        if not funone_dict.get("played_sound_ticket", False):
            if config_dict["advanced"]["play_sound"]["ticket"]:
                play_sound_while_ordering(config_dict)
            funone_dict["played_sound_ticket"] = True

        # Try OCR if enabled and we have base64 data
        if ocr_enabled and captcha_info.get('type') == 'base64' and captcha_info.get('base64Data'):
            # Use first 100 chars of base64 as fingerprint to detect image change
            current_captcha_fingerprint = captcha_info.get('base64Data', '')[:100]
            last_fingerprint = funone_dict.get("last_captcha_fingerprint", "")

            # Reset OCR failed flag if captcha image changed
            if current_captcha_fingerprint != last_fingerprint:
                funone_dict["last_captcha_fingerprint"] = current_captcha_fingerprint
                funone_dict["ocr_failed"] = False

            # Only attempt OCR if not already failed for this captcha
            if not funone_dict.get("ocr_failed", False):
                ocr_result = await nodriver_funone_ocr_captcha(tab, config_dict, captcha_info.get('base64Data'))
                if ocr_result:
                    return True

        # Only print waiting message once
        if show_debug_message and not funone_dict.get("waiting_captcha_printed"):
            print("[FUNONE] Waiting for manual captcha input...")
            funone_dict["waiting_captcha_printed"] = True
        return False

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Captcha check error: {exc}")
        return False


async def nodriver_funone_ocr_captcha(tab, config_dict, base64_data):
    """
    Perform OCR on FunOne captcha image and fill the input

    Args:
        tab: Browser tab
        config_dict: Configuration dictionary
        base64_data: Base64 encoded image data (data:image/png;base64,...)

    Returns:
        bool: True if OCR succeeded and input was filled
    """
    global funone_dict
    show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        # Extract base64 content (remove data:image/...;base64, prefix)
        if ',' in base64_data:
            base64_content = base64_data.split(',')[1]
        else:
            base64_content = base64_data

        # Decode base64 to image bytes (use module-level import)
        img_bytes = base64.b64decode(base64_content)

        if show_debug_message:
            print(f"[FUNONE OCR] Image size: {len(img_bytes)} bytes")

        # Use cached OCR instance or create new one (beta mode best for FunOne)
        # Cache in funone_dict to avoid recreating on every call
        if "ocr_instance" not in funone_dict:
            funone_dict["ocr_instance"] = ddddocr.DdddOcr(show_ad=False, beta=True)
        ocr_instance = funone_dict["ocr_instance"]
        ocr_answer = ocr_instance.classification(img_bytes)

        if ocr_answer:
            # FunOne captcha is case-sensitive and uses uppercase letters
            ocr_answer = ocr_answer.upper()

            if show_debug_message:
                print(f"[FUNONE OCR] Result: {ocr_answer} (length: {len(ocr_answer)})")

            # FunOne captcha requires exactly 5 characters
            if len(ocr_answer) != 5:
                if show_debug_message:
                    print(f"[FUNONE OCR] Invalid length: {len(ocr_answer)}, expected 5 chars - please enter manually")
                # Set failed flag to prevent retry loop
                funone_dict["ocr_failed"] = True
                return False

            # Fill the captcha input
            fill_captcha_js = f'''
            (function() {{
                const inputs = document.querySelectorAll('input[type="text"]');
                for (const input of inputs) {{
                    const placeholder = (input.placeholder || '').toLowerCase();
                    if (placeholder.includes('驗證') || placeholder.includes('captcha')) {{
                        input.value = '{ocr_answer}';
                        input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                        input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                        return {{ success: true, value: '{ocr_answer}' }};
                    }}
                }}
                return {{ success: false }};
            }})()
            '''
            fill_result = await tab.evaluate(fill_captcha_js)
            fill_result = util.parse_nodriver_result(fill_result)

            if fill_result and isinstance(fill_result, dict) and fill_result.get('success'):
                if show_debug_message:
                    print(f"[FUNONE OCR] Captcha filled: {ocr_answer}")
                return True

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE OCR] Error: {exc}")

    return False


async def nodriver_funone_detect_step(tab):
    """
    Detect which step of the ticket flow we're on.

    Returns:
        int: Step number (1=Area, 2=Quantity, 3=Form, 4=Payment, 5=Complete, 0=Unknown)
    """
    try:
        detect_step_js = '''
        (function() {
            const url = window.location.href;
            const bodyText = document.body.textContent || '';

            // Priority 1: Check URL patterns (most reliable)
            if (url.includes('purchase_choose_ticket_no_map') || url.includes('purchase_choose_ticket')) {
                // Ticket type/quantity selection page
                return 1;
            }
            if (url.includes('purchase_fill_form')) {
                // Form filling page
                return 3;
            }

            // Priority 2: Check URL for step parameter
            const stepMatch = url.match(/[?&]step=(\d+)/);
            if (stepMatch) {
                return parseInt(stepMatch[1]);
            }

            // Priority 3: Check for specific DOM patterns
            // Step 1: Area/Ticket selection
            const zoneBoxes = document.querySelectorAll('.zone_box');
            if (zoneBoxes.length > 0) {
                return 1;
            }

            // Step 1/2: Ticket type selection - has +/- buttons for quantity
            // Look for ticket price/type layout with quantity controls
            const plusBtns = document.querySelectorAll('button');
            let hasPlusMinusBtn = false;
            for (const btn of plusBtns) {
                const text = btn.textContent.trim();
                if (text === '+' || text === '-') {
                    hasPlusMinusBtn = true;
                    break;
                }
            }
            // Check for ticket selection page (has textbox for quantity input)
            const qtyInputs = document.querySelectorAll('input[type="text"][value="0"]');
            if (hasPlusMinusBtn && qtyInputs.length > 0) {
                // This is ticket selection page, not form filling
                return 1;
            }
            if (hasPlusMinusBtn && (bodyText.includes('張數') || bodyText.includes('票種'))) {
                return 2;
            }

            // Step 3: Form filling - must have actual form inputs (not just quantity inputs)
            const formInputs = document.querySelectorAll('input[type="text"]:not([value="0"]), input[type="email"], input[type="tel"]');
            if (formInputs.length >= 3 && bodyText.includes('填寫')) {
                return 3;
            }

            // Step 4: Payment page - must have specific payment elements
            const hasPaymentForm = document.querySelector('input[name*="credit"], input[name*="card"], select[name*="payment"]');
            if (hasPaymentForm || (bodyText.includes('付款方式') && bodyText.includes('信用卡'))) {
                return 4;
            }

            // Step 5: Complete
            if (bodyText.includes('購票完成') || bodyText.includes('訂單成功')) {
                return 5;
            }

            return 0; // Unknown
        })()
        '''
        step = await tab.evaluate(detect_step_js)
        step = util.parse_nodriver_result(step)
        return int(step) if step else 0

    except Exception as exc:
        return 0


async def nodriver_funone_ticket_agree(tab):
    """
    Check agreement checkboxes

    Returns:
        bool: True if agreements checked
    """
    try:
        check_agree_js = '''
        (function() {
            let checked = 0;

            // FunOne-specific: custom div.checkbox elements
            // Structure: <div class="checkbox_block active"> <div class="checkbox"><svg>...</svg></div> </div>
            // The parent checkbox_block gets 'active' class when checked
            const customCheckboxes = document.querySelectorAll('.checkbox_block .checkbox, div.checkbox');
            for (const cb of customCheckboxes) {
                // Check if not already checked
                // FunOne: parent element gets 'active' class when checked
                const parent = cb.parentElement;
                const parentActive = parent && parent.classList.contains('active');
                const selfChecked = cb.classList.contains('checked') || cb.classList.contains('active');

                if (!parentActive && !selfChecked) {
                    cb.click();
                    checked++;
                }
            }

            if (checked > 0) {
                return checked;
            }

            // Standard input checkboxes
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');

            for (const cb of checkboxes) {
                if (!cb.checked) {
                    // Try multiple ways to find the associated text
                    const label = cb.closest('label') || document.querySelector(`label[for="${cb.id}"]`);
                    let text = label ? label.textContent : '';

                    // If no label text, check parent/sibling elements
                    if (!text && cb.parentElement) {
                        text = cb.parentElement.textContent || '';
                    }

                    // FunOne specific: check for nearby text about terms/agreement
                    const nearbyText = cb.closest('div')?.textContent || '';

                    // Check if it's an agreement checkbox
                    if (text.includes('同意') || text.includes('agree') || text.includes('條款') ||
                        text.includes('terms') || text.includes('規則') || text.includes('閱讀') ||
                        nearbyText.includes('同意') || nearbyText.includes('服務條款')) {
                        cb.click(); // Use click instead of just setting checked for better event handling
                        checked++;
                    }
                }
            }

            // If no checkbox found with text, just click any unchecked checkbox
            if (checked === 0) {
                for (const cb of checkboxes) {
                    if (!cb.checked) {
                        cb.click();
                        checked++;
                        break; // Only click first unchecked checkbox
                    }
                }
            }

            return checked;
        })()
        '''
        result = await tab.evaluate(check_agree_js)
        return result >= 0

    except Exception as exc:
        return False


async def nodriver_funone_order_submit(tab, config_dict, funone_dict_local):
    """
    Submit order - click submit button

    Returns:
        bool: True if order submitted
    """
    global funone_dict
    show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        # Find and click submit button
        submit_js = '''
        (function() {
            const buttons = document.querySelectorAll('button, input[type="submit"]');

            for (const btn of buttons) {
                const text = (btn.textContent || btn.value || '').trim();

                // Submit button patterns - FunOne uses "立即購買"
                if (text.includes('立即購買') || text.includes('確認') || text.includes('送出') ||
                    text.includes('提交') || text.includes('Submit') || text.includes('Confirm') ||
                    text.includes('購買') || text === '確定' || text === '下一步') {

                    // Check if button is visible and enabled
                    const style = window.getComputedStyle(btn);
                    if (style.display !== 'none' && !btn.disabled) {
                        btn.click();
                        return { clicked: true, buttonText: text };
                    }
                }
            }

            return { clicked: false };
        })()
        '''
        result = await tab.evaluate(submit_js)
        result = util.parse_nodriver_result(result)

        if result and isinstance(result, dict) and result.get('clicked'):
            if show_debug_message:
                print(f"[FUNONE] Submit button clicked: {result.get('buttonText')}")
            funone_dict["submit_notfound"] = False  # Reset flag on success
            return True
        else:
            # Only print once when submit button not found
            if show_debug_message and not funone_dict.get("submit_notfound"):
                print("[FUNONE] Submit button not found or not clickable")
                funone_dict["submit_notfound"] = True
            return False

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Order submit error: {exc}")
        return False


async def nodriver_funone_auto_reload(tab, config_dict, funone_dict_local):
    """
    Auto reload page for error handling and coming soon detection

    Returns:
        bool: True if page was reloaded
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Skip auto-reload for non-activity pages (safety check)
    try:
        current_url = tab.url
        if '/purchase_waiting_jump/' in current_url or '/purchase_fill_form/' in current_url:
            return False
    except:
        pass

    try:
        # Check for error pages or coming soon
        check_status_js = '''
        (function() {
            const bodyText = document.body.textContent || '';
            const title = document.title || '';

            // Error page patterns
            if (bodyText.includes('503') || bodyText.includes('502') || bodyText.includes('500') ||
                title.includes('Error') || bodyText.includes('Service Unavailable')) {
                return { status: 'error', reason: 'server_error' };
            }

            // Coming soon / not yet available
            if (bodyText.includes('即將開賣') || bodyText.includes('尚未開放') ||
                bodyText.includes('Coming Soon') || bodyText.includes('Not Available')) {
                return { status: 'coming_soon', reason: 'not_available' };
            }

            // Sold out detection - be smart about it
            // On FunOne area selection page, "已售完" appears next to disabled areas
            // Only trigger sold out if ALL available areas are sold out

            // Check if we're on area selection page (has zone_box elements)
            const zoneBoxes = document.querySelectorAll('.zone_box');
            if (zoneBoxes.length > 0) {
                // On area selection page - check if any area is available
                let hasAvailable = false;
                for (const box of zoneBoxes) {
                    if (!box.classList.contains('disabled')) {
                        hasAvailable = true;
                        break;
                    }
                }
                if (!hasAvailable) {
                    return { status: 'sold_out', reason: 'all_areas_sold_out' };
                }
                // Some areas available, not sold out
                return { status: 'ok' };
            }

            // Check if we're on quantity selection page (Step 2)
            // Has ticket info table but may show "熱賣中" etc - not sold out
            const step2Indicators = document.querySelectorAll('.ticket_info, [class*="step2"], [class*="quantity"]');
            if (step2Indicators.length > 0 || bodyText.includes('張數') || bodyText.includes('票種')) {
                // On quantity page, don't trigger sold out unless specific message
                if (bodyText.includes('已無票券') || bodyText.includes('No tickets available')) {
                    return { status: 'sold_out', reason: 'no_tickets_message' };
                }
                return { status: 'ok' };
            }

            // For other pages, check for actual sold out indicators
            // Only if the page seems to be a final "sold out" page
            const soldOutPatterns = ['已售完', 'Sold Out', 'sold out'];
            let hasSoldOutText = false;
            for (const pattern of soldOutPatterns) {
                if (bodyText.includes(pattern)) {
                    hasSoldOutText = true;
                    break;
                }
            }

            // Only report sold out if the entire page seems to be about sold out
            // Not just a label next to some areas
            if (hasSoldOutText) {
                // Check if there are any actionable buttons (if yes, not sold out page)
                const actionButtons = document.querySelectorAll('button:not(:disabled)');
                let hasActionButton = false;
                for (const btn of actionButtons) {
                    const text = btn.textContent || '';
                    if (text.includes('購買') || text.includes('下一步') || text.includes('確認') ||
                        text.includes('選') || text.includes('+')) {
                        hasActionButton = true;
                        break;
                    }
                }
                if (!hasActionButton) {
                    return { status: 'sold_out', reason: 'no_tickets' };
                }
            }

            return { status: 'ok' };
        })()
        '''
        status = await tab.evaluate(check_status_js)
        status = util.parse_nodriver_result(status)

        if status and isinstance(status, dict):
            page_status = status.get('status')
            reason = status.get('reason', '')

            if page_status == 'error':
                if show_debug_message:
                    print(f"[FUNONE] Error page detected: {reason}, reloading...")
                await tab.reload()
                return True

            elif page_status == 'coming_soon':
                auto_reload_coming_soon = config_dict.get("tixcraft", {}).get("auto_reload_coming_soon_page", True)
                if auto_reload_coming_soon:
                    if show_debug_message:
                        print("[FUNONE] Coming soon page, auto-reloading...")
                    await tab.sleep(1)
                    await tab.reload()
                    return True

            elif page_status == 'sold_out':
                if show_debug_message:
                    print("[FUNONE] Sold out detected")
                return False

        return False

    except Exception as exc:
        if show_debug_message:
            print(f"[FUNONE] Auto reload error: {exc}")
        return False


async def nodriver_funone_error_handler(tab, error, config_dict, funone_dict_local):
    """
    Handle various error types

    Returns:
        bool: True if error was handled
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    error_str = str(error).lower()

    if 'timeout' in error_str:
        if show_debug_message:
            print("[FUNONE] Timeout error, reloading page...")
        try:
            await tab.reload()
            return True
        except:
            pass

    if 'network' in error_str or 'connection' in error_str:
        if show_debug_message:
            print("[FUNONE] Network error, waiting and retrying...")
        await tab.sleep(2)
        try:
            await tab.reload()
            return True
        except:
            pass

    return False


async def nodriver_funone_main(tab, url, config_dict):
    """
    Main control function for FunOne Tickets platform

    Args:
        tab: NoDriver tab
        url: Current page URL
        config_dict: Configuration dictionary

    Returns:
        tab: Updated NoDriver tab
    """
    global funone_dict

    # Check pause state
    if await check_and_handle_pause(config_dict):
        return tab

    # Initialize state dictionary
    if 'is_session_selecting' not in funone_dict:
        funone_dict = {
            "is_session_selecting": False,
            "is_ticket_selecting": False,
            "played_sound_ticket": False,
            "played_sound_order": False,
            "fail_list": [],
            "reload_count": 0,
            # State tracking for log deduplication
            "last_page_type": None,
            "last_step": None,
            "last_login_status": None,
            "last_area_count": None,
            "last_area_config": None,
            "last_ticket_qty": None,
            "qty_selector_notfound": False,
            "submit_notfound": False,
            "last_captcha_type": None,
            "waiting_captcha_printed": False,
            "captcha_filled_printed": False,
            "next_button_clicked": False,
            # Sold-out refresh tracking
            "refresh_retry_count": 0,
            "last_sold_out_logged": False,
            "max_retry_logged": False
        }

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Determine page type
    page_type = "UNKNOWN"

    if 'tickets.funone.io' in url:
        if '/activity/activity_detail/' in url:
            page_type = "ACTIVITY_DETAIL"
        elif '/login' in url:
            page_type = "LOGIN"
        elif '/member' in url:
            page_type = "MEMBER"
        elif url.rstrip('/') == 'https://tickets.funone.io':
            page_type = "HOME"
        elif '/purchase_waiting_jump/' in url:
            page_type = "WAITING"
        else:
            # Check for ticket selection or order pages dynamically
            page_type = "TICKET_FLOW"

    # Only print when page type changes (reduce repetitive messages)
    if funone_dict.get("last_page_type") != page_type:
        if show_debug_message:
            print(f"[FUNONE] Page type: {page_type}, URL: {url[:80]}...")
        funone_dict["last_page_type"] = page_type
        # Reset flags when page type changes
        funone_dict["waiting_page_logged"] = False
        funone_dict["next_button_clicked"] = False
        # Reset sold-out refresh tracking
        funone_dict["refresh_retry_count"] = 0
        funone_dict["last_sold_out_logged"] = False
        funone_dict["max_retry_logged"] = False

    # Close popups first
    await nodriver_funone_close_popup(tab)

    # Handle different page types
    if page_type == "HOME":
        # On homepage, just ensure logged in
        await nodriver_funone_verify_login(tab, config_dict)

    elif page_type == "ACTIVITY_DETAIL":
        # Activity detail page - select session and click next
        is_logged_in = await nodriver_funone_verify_login(tab, config_dict)

        if is_logged_in:
            if not funone_dict.get("is_session_selecting", False):
                funone_dict["is_session_selecting"] = True
                success = await nodriver_funone_date_auto_select(tab, url, config_dict)
                funone_dict["is_session_selecting"] = False
                # Mark if navigation was triggered (next button clicked)
                # This prevents auto_reload from running during page transition
                if success:
                    funone_dict["next_button_clicked"] = True

    elif page_type == "LOGIN":
        # Login page - try cookie injection
        await nodriver_funone_verify_login(tab, config_dict)

    elif page_type == "WAITING":
        # Waiting/queue page - do nothing, just wait for auto-redirect
        if show_debug_message and not funone_dict.get("waiting_page_logged", False):
            print("[FUNONE] Waiting page detected, waiting for auto-redirect...")
            funone_dict["waiting_page_logged"] = True
        # Don't take any action - page will redirect automatically when it's user's turn

    elif page_type == "TICKET_FLOW":
        # Ticket selection flow
        is_logged_in = await nodriver_funone_verify_login(tab, config_dict)

        if is_logged_in:
            # Detect which step we're on
            step = await nodriver_funone_detect_step(tab)

            # Only print when step changes (reduce repetitive messages)
            if show_debug_message and funone_dict.get("last_step") != step:
                print(f"[FUNONE] Detected step: {step}")
                funone_dict["last_step"] = step

            if step == 1:
                # Step 1: Ticket type/quantity selection
                # FunOne: purchase_choose_ticket_no_map is a combined ticket selection + quantity page

                # Check if on purchase_choose_ticket_no_map page - apply sold-out detection
                if '/purchase_choose_ticket_no_map/' in url:
                    # Wait for page to fully load before checking sold-out status
                    # Check for key elements: purchase button or ticket price
                    wait_js = '''
                    (function() {
                        const purchaseBtn = document.querySelector('button');
                        if (purchaseBtn) {
                            const text = purchaseBtn.textContent || '';
                            if (text.includes('立即購買') || text.includes('Purchase')) {
                                return true;
                            }
                        }
                        // Also check for ticket price (TWD)
                        const body = document.body.textContent || '';
                        if (body.includes('TWD') || body.includes('票種')) {
                            return true;
                        }
                        return false;
                    })()
                    '''
                    page_ready = await tab.evaluate(wait_js)
                    page_ready = util.parse_nodriver_result(page_ready)
                    if not page_ready:
                        # Page not ready, wait and retry next iteration
                        await tab.sleep(0.3)
                        return tab

                    # Check sold-out status first
                    is_sold_out, remaining, ticket_info = await nodriver_funone_check_sold_out(tab, config_dict)
                    ticket_number = config_dict.get("ticket_number", 2)
                    auto_reload_interval = config_dict["advanced"].get("auto_reload_page_interval", 2)

                    # Handle sold-out or insufficient tickets
                    if is_sold_out or (remaining > 0 and remaining < ticket_number):
                        # Increment retry counter (no limit - keep refreshing until tickets available)
                        funone_dict["refresh_retry_count"] = funone_dict.get("refresh_retry_count", 0) + 1

                        # Log status (only once per state)
                        if is_sold_out:
                            if not funone_dict.get("last_sold_out_logged", False):
                                print(f"[FUNONE] Sold out, clicking refresh button...")
                                funone_dict["last_sold_out_logged"] = True
                        else:
                            print(f"[FUNONE] Remaining {remaining} < needed {ticket_number}, refreshing...")

                        # Click refresh button to trigger WebSocket update
                        refresh_clicked = await nodriver_funone_click_refresh_button(tab, config_dict)

                        if refresh_clicked:
                            # Wait for WebSocket response - use asyncio.sleep for reliable timing
                            if show_debug_message:
                                print(f"[FUNONE] Waiting {auto_reload_interval} seconds...")
                            await asyncio.sleep(auto_reload_interval)
                        else:
                            # Fallback: reload page if refresh button not found
                            if show_debug_message:
                                print("[FUNONE] Refresh button not found, reloading page...")
                            await tab.reload()
                            await asyncio.sleep(auto_reload_interval)

                        return tab  # Next iteration will re-check status

                    # Tickets available - reset retry counter and proceed
                    funone_dict["refresh_retry_count"] = 0
                    funone_dict["last_sold_out_logged"] = False

                # Try area selection first (for zone_box pages)
                area_selected = await nodriver_funone_area_auto_select(tab, url, config_dict)

                # If no area selected (no zone_box elements), this is a quantity selection page
                # Proceed to set quantity, agreements, and submit
                if not area_selected:
                    # Set ticket number
                    qty_set = await nodriver_funone_assign_ticket_number(tab, config_dict)
                    await tab.sleep(0.3)

                    # Check agreements
                    await nodriver_funone_ticket_agree(tab)
                    await tab.sleep(0.2)

                    # Step 1 (purchase_choose_ticket_no_map) has no captcha
                    # Directly click purchase button if quantity is set
                    if qty_set:
                        await nodriver_funone_order_submit(tab, config_dict, funone_dict)
                else:
                    await tab.sleep(0.5)
                    # Page should navigate to step 2 after area selection

            elif step == 2:
                # Step 2: Quantity selection
                # Set ticket number
                qty_set = await nodriver_funone_assign_ticket_number(tab, config_dict)
                await tab.sleep(0.3)

                # Check agreements
                await nodriver_funone_ticket_agree(tab)
                await tab.sleep(0.2)

                # Handle captcha
                captcha_done = await nodriver_funone_captcha_handler(tab, config_dict)

                if captcha_done and qty_set:
                    # FunOne: Do not auto-submit, let user manually review and submit
                    print("[FUNONE] Captcha filled, waiting for manual submit")
                    submit_result = False

                    if submit_result:
                        # Play order success sound
                        if not funone_dict.get("played_sound_order", False):
                            if config_dict["advanced"]["play_sound"]["order"]:
                                play_sound_while_ordering(config_dict)
                            send_discord_notification(config_dict, "order", "FunOne")
                            funone_dict["played_sound_order"] = True
                        print("[FUNONE] Order submitted successfully!")

            elif step >= 3:
                # Step 3+: Form filling, payment, etc.
                # Check if we're on the fill form page - this means ticket secured!
                if 'purchase_fill_form' in url:
                    if not funone_dict.get("played_sound_order", False):
                        if config_dict["advanced"]["play_sound"]["order"]:
                            play_sound_while_ordering(config_dict)
                        send_discord_notification(config_dict, "order", "FunOne")
                        funone_dict["played_sound_order"] = True
                        print("[FUNONE] Reached fill form page - order notification sent!")

                # Handle captcha if present
                await nodriver_funone_captcha_handler(tab, config_dict)

            else:
                # Unknown step - try area selection first, then quantity
                area_selected = await nodriver_funone_area_auto_select(tab, url, config_dict)

                if not area_selected:
                    # Maybe we're already past area selection, try quantity
                    await nodriver_funone_assign_ticket_number(tab, config_dict)
                    await tab.sleep(0.3)
                    await nodriver_funone_ticket_agree(tab)
                    captcha_done = await nodriver_funone_captcha_handler(tab, config_dict)
                    if captcha_done:
                        # FunOne: Do not auto-submit, let user manually review and submit
                        print("[FUNONE] Captcha filled, waiting for manual submit")

    elif page_type == "MEMBER":
        # Member page - verify login status
        await nodriver_funone_verify_login(tab, config_dict)

    # Auto reload check - only for ACTIVITY_DETAIL page
    # Skip if next button was clicked (page is navigating to waiting page)
    if page_type == "ACTIVITY_DETAIL":
        if not funone_dict.get("next_button_clicked", False):
            await nodriver_funone_auto_reload(tab, config_dict, funone_dict)

    return tab


# =============================================================================
# FANSI GO Platform Support
# URL: https://go.fansi.me
# Features: Multi-show selection, multi-section selection, Cookie login
# =============================================================================

# Global state dictionary for FANSI GO
fansigo_dict = {}

# FANSI GO URL patterns
FANSIGO_URL_PATTERNS = {
    "domain": r"go\.fansi\.me",
    "event_page": r"go\.fansi\.me/events/(\d+)",
    "show_page": r"go\.fansi\.me/tickets/show/(\d+)",
    "checkout_page": r"go\.fansi\.me/tickets/payment/checkout/",
    "order_result": r"go\.fansi\.me/tickets/payment/orderresult/",
}


def is_fansigo_url(url: str) -> bool:
    """Check if URL is a FANSI GO URL"""
    import re
    if url is None:
        return False
    return bool(re.search(FANSIGO_URL_PATTERNS["domain"], url))


def get_fansigo_page_type(url: str) -> str:
    """Get FANSI GO page type from URL

    Returns:
        str: "event", "show", "checkout", "order_result", or "unknown"
    """
    import re
    if url is None:
        return "unknown"

    if re.search(FANSIGO_URL_PATTERNS["checkout_page"], url):
        return "checkout"
    if re.search(FANSIGO_URL_PATTERNS["order_result"], url):
        return "order_result"
    if re.search(FANSIGO_URL_PATTERNS["event_page"], url):
        return "event"
    if re.search(FANSIGO_URL_PATTERNS["show_page"], url):
        return "show"

    return "unknown"


async def nodriver_fansigo_inject_cookie(tab, config_dict):
    """Inject FansiAuthInfo cookie for FANSI GO login

    Args:
        tab: NoDriver tab
        config_dict: Configuration dictionary

    Returns:
        bool: True if injection successful or no cookie configured
    """
    import nodriver.cdp as cdp

    show_debug_message = config_dict["advanced"].get("verbose", False)
    fansigo_cookie = config_dict["accounts"].get("fansigo_cookie", "").strip()

    if len(fansigo_cookie) == 0:
        if show_debug_message:
            print("[FANSIGO] No cookie configured, continuing as guest")
        return True

    try:
        # Set FansiAuthInfo cookie
        await tab.send(cdp.network.set_cookie(
            name="FansiAuthInfo",
            value=fansigo_cookie,
            domain="go.fansi.me",
            path="/",
            secure=True,
            http_only=True,
        ))

        if show_debug_message:
            print("[FANSIGO] Cookie injected successfully")
        return True

    except Exception as e:
        print(f"[FANSIGO] Cookie injection failed: {e}")
        return False


async def nodriver_fansigo_get_shows(tab, config_dict) -> list:
    """Get all available shows from event page using tab.evaluate()

    NoDriver's query_selector_all() fails on Next.js SPA pages,
    but tab.evaluate() (direct JS execution) works reliably.

    Args:
        tab: NoDriver tab
        config_dict: Configuration dictionary

    Returns:
        list: List of show dictionaries with href, text, name, datetime, venue
    """
    import re

    show_debug_message = config_dict["advanced"].get("verbose", False)
    shows = []

    try:
        # Wait for Next.js SPA to render content
        try:
            await tab.find("請選擇活動場次進行購買", timeout=5)
        except Exception:
            if show_debug_message:
                print("[FANSIGO] Waiting for event page to render...")
            return shows

        # Extract show data via JavaScript
        # Wrap array in object for util.parse_nodriver_result() compatibility
        js_raw = await tab.evaluate('''
            (function() {
                var links = document.querySelectorAll('a[href*="/tickets/show/"]');
                var items = [];
                for (var i = 0; i < links.length; i++) {
                    items.push({
                        href: links[i].href,
                        text: links[i].textContent.trim()
                    });
                }
                return {items: items, count: items.length};
            })()
        ''')
        js_parsed = util.parse_nodriver_result(js_raw)
        js_result = js_parsed.get('items', []) if isinstance(js_parsed, dict) else []

        if not js_result or len(js_result) == 0:
            return shows

        for item in js_result:
            href = item.get("href", "")
            text = item.get("text", "")
            if not text:
                continue

            # Normalize whitespace
            normalized_text = re.sub(r'\s+', ' ', text).strip()

            name = normalized_text
            datetime_str = ""
            venue = ""

            # Extract datetime
            datetime_match = re.search(r"(\d{4}/\d{2}/\d{2})\s*(\d{2}:\d{2})", normalized_text)
            if datetime_match:
                datetime_str = datetime_match.group(1) + " " + datetime_match.group(2)
                name_end = datetime_match.start()
                if name_end > 0:
                    name = normalized_text[:name_end].strip()
                after_time = normalized_text[datetime_match.end():].strip()
                venue_match = re.match(r"(.+?)(?:\s+\d{3}|$)", after_time)
                if venue_match:
                    venue = venue_match.group(1).strip()

            if show_debug_message:
                print(f"[FANSIGO] Show: name={name}, date={datetime_str}, venue={venue}")

            shows.append({
                "href": href,
                "text": normalized_text,
                "name": name,
                "datetime": datetime_str,
                "venue": venue,
            })

        if show_debug_message:
            print(f"[FANSIGO] Found {len(shows)} shows")

    except Exception as e:
        if show_debug_message:
            print(f"[FANSIGO] Error getting shows: {e}")

    return shows


async def nodriver_fansigo_click_show(tab, show_dict, config_dict):
    """Navigate to show page directly using href

    Uses tab.get() for direct navigation instead of click(),
    which avoids Next.js opening new tabs.

    Args:
        tab: NoDriver tab
        show_dict: Show dictionary with href
        config_dict: Configuration dictionary
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    href = show_dict.get("href", "")

    if not href:
        raise Exception("No href in show_dict")

    # Build full URL if relative
    if href.startswith("/"):
        href = "https://go.fansi.me" + href

    if show_debug_message:
        print(f"[FANSIGO] Navigating to show: {href}")

    await tab.get(href)


def fansigo_match_by_keyword(items: list, keyword_string: str, text_key: str = "text") -> dict:
    """Match item by keyword string

    Args:
        items: List of item dictionaries
        keyword_string: Keyword string (semicolon separated for multiple)
        text_key: Key to use for text matching

    Returns:
        dict: Matched item or None
    """
    if not keyword_string or len(keyword_string.strip()) == 0:
        return None

    for item in items:
        item_text = item.get(text_key, "")
        if util.is_text_match_keyword(keyword_string, item_text):
            return item

    return None


async def nodriver_fansigo_date_auto_select(tab, url, config_dict) -> bool:
    """Auto select show/date on event page

    Args:
        tab: NoDriver tab
        url: Current URL
        config_dict: Configuration dictionary

    Returns:
        bool: True if show selected or not on event page
    """
    import re

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Check if date auto select is enabled
    date_auto_select = config_dict.get("date_auto_select", {})
    if not date_auto_select.get("enable", True):
        return True

    # Only process event pages
    if not re.search(FANSIGO_URL_PATTERNS["event_page"], url):
        return True

    # Get all shows
    shows = await nodriver_fansigo_get_shows(tab, config_dict)

    if len(shows) == 0:
        if show_debug_message:
            print("[FANSIGO] No shows found on event page")
        return False

    # Single show - click directly
    if len(shows) == 1:
        if show_debug_message:
            print(f"[FANSIGO] Single show found, selecting: {shows[0]['name']}")
        try:
            await nodriver_fansigo_click_show(tab, shows[0], config_dict)
            return True
        except Exception as e:
            print(f"[FANSIGO] Error clicking show: {e}")
            return False

    # Multiple shows - use keyword matching
    date_keyword = date_auto_select.get("date_keyword", "")

    if show_debug_message:
        print(f"[FANSIGO] Matching with date_keyword: {date_keyword}")
        for show in shows:
            print(f"[FANSIGO]   Show text: {show['text'][:80]}")

    if date_keyword:
        matched = fansigo_match_by_keyword(shows, date_keyword)
    else:
        matched = None

    if matched:
        if show_debug_message:
            print(f"[FANSIGO] Show matched by keyword: {matched['name']}")
        try:
            await nodriver_fansigo_click_show(tab, matched, config_dict)
            return True
        except Exception as e:
            print(f"[FANSIGO] Error clicking matched show: {e}")
            return False

    if not date_keyword:
        # No keyword set = accept all, select by mode
        mode = date_auto_select.get("mode", CONST_FROM_TOP_TO_BOTTOM)
        target = util.get_target_item_from_matched_list(shows, mode)
        if target:
            if show_debug_message:
                print(f"[FANSIGO] No keyword set, selecting by mode: {target['name']}")
            try:
                await nodriver_fansigo_click_show(tab, target, config_dict)
                return True
            except Exception as e:
                print(f"[FANSIGO] Error clicking show: {e}")
                return False
        return False

    # Keyword set but no match - check fallback
    date_auto_fallback = config_dict.get("date_auto_fallback", False)
    if date_auto_fallback:
        mode = date_auto_select.get("mode", CONST_FROM_TOP_TO_BOTTOM)
        target = util.get_target_item_from_matched_list(shows, mode)
        if target:
            if show_debug_message:
                print(f"[FANSIGO] Using fallback, selecting: {target['name']}")
            try:
                await nodriver_fansigo_click_show(tab, target, config_dict)
                return True
            except Exception as e:
                print(f"[FANSIGO] Error clicking fallback show: {e}")
                return False
        return False

    if show_debug_message:
        print("[FANSIGO] No matching show found and fallback disabled")
    return False


async def nodriver_fansigo_get_sections(tab, config_dict) -> list:
    """Get all available ticket sections from show page using tab.evaluate()

    Args:
        tab: NoDriver tab
        config_dict: Configuration dictionary

    Returns:
        list: List of section dictionaries with index, name, status, text
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    sections = []

    try:
        # Wait for Next.js SPA to render ticket sections
        try:
            await tab.find("選擇票券種類", timeout=5)
        except Exception:
            if show_debug_message:
                print("[FANSIGO] Waiting for show page to render...")
            return sections

        # Extract section data via JavaScript
        # Wrap array in object for util.parse_nodriver_result() compatibility
        js_raw = await tab.evaluate('''
            (function() {
                var elems = document.querySelectorAll('li.list-none');
                var items = [];
                for (var i = 0; i < elems.length; i++) {
                    var text = elems[i].textContent.trim();
                    var h3 = elems[i].querySelector('h3');
                    var name = h3 ? h3.textContent.trim() : '';
                    if (!name) {
                        var p = elems[i].querySelector('p');
                        name = p ? p.textContent.trim() : '';
                    }
                    var hasButton = elems[i].querySelectorAll('button').length > 0;
                    var status = 'unavailable';
                    if (text.indexOf('尚未開賣') >= 0) status = 'coming_soon';
                    else if (text.indexOf('已售完') >= 0 || text.indexOf('你已太晚') >= 0) status = 'sold_out';
                    else if (hasButton) status = 'on_sale';
                    items.push({index: i, name: name, text: text, status: status});
                }
                return {items: items, count: items.length};
            })()
        ''')
        js_parsed = util.parse_nodriver_result(js_raw)
        js_result = js_parsed.get('items', []) if isinstance(js_parsed, dict) else []

        if not js_result:
            return sections

        for item in js_result:
            if not item.get("name"):
                continue

            if show_debug_message:
                print(f"[FANSIGO] Section: {item['name']}, status={item['status']}")

            sections.append({
                "index": item["index"],
                "name": item["name"],
                "status": item["status"],
                "text": item.get("text", ""),
            })

        if show_debug_message:
            available = [s for s in sections if s["status"] == "on_sale"]
            print(f"[FANSIGO] Found {len(sections)} sections, {len(available)} available")

    except Exception as e:
        if show_debug_message:
            print(f"[FANSIGO] Error getting sections: {e}")

    return sections


async def nodriver_fansigo_area_auto_select(tab, url, config_dict) -> int:
    """Auto select ticket section/area on show page

    Args:
        tab: NoDriver tab
        url: Current URL
        config_dict: Configuration dictionary

    Returns:
        int: Selected section index, or -1 if no section selected
    """
    import re

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Check if area auto select is enabled
    area_auto_select = config_dict.get("area_auto_select", {})
    if not area_auto_select.get("enable", True):
        return 0

    # Only process show pages
    if not re.search(FANSIGO_URL_PATTERNS["show_page"], url):
        return 0

    # Get all sections
    sections = await nodriver_fansigo_get_sections(tab, config_dict)

    # Filter to available sections only
    available_sections = [s for s in sections if s["status"] == "on_sale"]

    if len(available_sections) == 0:
        if show_debug_message:
            print("[FANSIGO] No available sections found")
        return -1

    # Apply exclude keywords
    keyword_exclude = config_dict.get("keyword_exclude", "")
    if keyword_exclude:
        exclude_keywords = [k.strip() for k in keyword_exclude.split(";") if k.strip()]
        filtered_sections = []
        for section in available_sections:
            excluded = False
            for exclude_kw in exclude_keywords:
                if exclude_kw.lower() in section["name"].lower():
                    excluded = True
                    break
            if not excluded:
                filtered_sections.append(section)
        available_sections = filtered_sections

    if len(available_sections) == 0:
        if show_debug_message:
            print("[FANSIGO] All sections excluded by keyword_exclude")
        return -1

    # Use keyword matching
    area_keyword = area_auto_select.get("area_keyword", "")

    if area_keyword:
        matched = fansigo_match_by_keyword(available_sections, area_keyword, "name")
    else:
        matched = None

    target_section = None

    if matched:
        target_section = matched
        if show_debug_message:
            print(f"[FANSIGO] Section matched by keyword: {matched['name']}")
    elif not area_keyword:
        # No keyword set = accept all, select by mode
        mode = area_auto_select.get("mode", CONST_FROM_TOP_TO_BOTTOM)
        target_section = util.get_target_item_from_matched_list(available_sections, mode)
        if show_debug_message and target_section:
            print(f"[FANSIGO] No keyword set, selecting by mode: {target_section['name']}")
    else:
        # Keyword set but no match - check fallback
        area_auto_fallback = config_dict.get("area_auto_fallback", False)
        if area_auto_fallback:
            mode = area_auto_select.get("mode", CONST_FROM_TOP_TO_BOTTOM)
            target_section = util.get_target_item_from_matched_list(available_sections, mode)
            if show_debug_message and target_section:
                print(f"[FANSIGO] Using fallback, selecting: {target_section['name']}")
        else:
            if show_debug_message:
                print("[FANSIGO] No matching section found and fallback disabled")
            return -1

    # Click the section to select it
    if target_section:
        try:
            section_index = target_section["index"]
            await tab.evaluate('''
                (function() {
                    var items = document.querySelectorAll('li.list-none');
                    if (items[%d]) { items[%d].click(); }
                })()
            ''' % (section_index, section_index))
            await asyncio.sleep(0.3)
            return section_index
        except Exception as e:
            print(f"[FANSIGO] Error clicking section: {e}")
            return -1

    return -1


async def nodriver_fansigo_assign_ticket_number(tab, config_dict, section_index=0) -> bool:
    """Set ticket quantity on show page using tab.evaluate()

    Args:
        tab: NoDriver tab
        config_dict: Configuration dictionary
        section_index: Target section index from area_auto_select

    Returns:
        bool: True if quantity set successfully
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)
    target_count = config_dict.get("ticket_number", 1)

    if target_count < 1:
        target_count = 1

    try:
        # Click + button one at a time with delay for React state updates
        # React 18 batches synchronous state updates, so clicking N times
        # in a single JS execution only registers as 1 click.
        js_click_once = '''
        (function() {
            var sections = document.querySelectorAll('li.list-none');
            var target = sections[%d];
            if (!target) return {success: false, error: 'section_not_found'};
            var btns = target.querySelectorAll('button');
            if (btns.length >= 2) {
                btns[1].click();
                return {success: true};
            }
            return {success: false, error: 'button_not_found'};
        })()
        ''' % section_index

        for i in range(target_count):
            result = await tab.evaluate(js_click_once)
            result = util.parse_nodriver_result(result)
            if not (isinstance(result, dict) and result.get('success')):
                error_msg = result.get('error', 'unknown') if isinstance(result, dict) else 'no_result'
                print(f"[FANSIGO] Failed to click + button: {error_msg}")
                return False
            if i < target_count - 1:
                await asyncio.sleep(0.2)

        if show_debug_message:
            print(f"[FANSIGO] Set ticket quantity to {target_count} for section {section_index}")

        return True

    except Exception as e:
        print(f"[FANSIGO] Error setting ticket quantity: {e}")
        return False


async def nodriver_fansigo_click_checkout(tab, config_dict) -> bool:
    """Click checkout/submit button on show page using JavaScript

    Args:
        tab: NoDriver tab
        config_dict: Configuration dictionary

    Returns:
        bool: True if checkout button clicked
    """
    show_debug_message = config_dict["advanced"].get("verbose", False)

    try:
        # Find and click checkout button via JavaScript
        checkout_keywords_js = '["checkout","submit","buy","next","continue","取得訂單","結帳","購買","下一步"]'

        js_click_checkout = '''
        (function() {
            var keywords = %s;
            var buttons = document.querySelectorAll('button');
            for (var i = 0; i < buttons.length; i++) {
                var text = (buttons[i].textContent || '').trim().toLowerCase();
                for (var j = 0; j < keywords.length; j++) {
                    if (text.indexOf(keywords[j]) >= 0) {
                        buttons[i].click();
                        return {clicked: true, text: buttons[i].textContent.trim()};
                    }
                }
            }
            return {clicked: false};
        })()
        ''' % checkout_keywords_js

        result = await tab.evaluate(js_click_checkout)
        result = util.parse_nodriver_result(result)

        if isinstance(result, dict) and result.get('clicked'):
            if show_debug_message:
                print(f"[FANSIGO] Clicked checkout button: {result.get('text', '')}")
            return True

        if show_debug_message:
            print("[FANSIGO] Checkout button not found")
        return False

    except Exception as e:
        print(f"[FANSIGO] Error clicking checkout: {e}")
        return False


async def nodriver_fansigo_main(tab, url, config_dict):
    """Main control function for FANSI GO platform

    Args:
        tab: NoDriver tab
        url: Current page URL
        config_dict: Configuration dictionary

    Returns:
        tab: Updated NoDriver tab
    """
    global fansigo_dict

    show_debug_message = config_dict["advanced"].get("verbose", False)

    # Check pause state
    if await check_and_handle_pause(config_dict):
        return tab

    # Initialize state dictionary
    if 'is_cookie_injected' not in fansigo_dict:
        fansigo_dict = {
            "is_cookie_injected": False,
            "played_sound_ticket": False,
            "last_page_type": None,
            "qty_set_url": None,
        }

    # Get page type
    page_type = get_fansigo_page_type(url)

    # Log page type change
    if page_type != fansigo_dict.get("last_page_type"):
        if show_debug_message:
            print(f"[FANSIGO] Page type: {page_type}")
        fansigo_dict["last_page_type"] = page_type

    # Inject cookie (once)
    if not fansigo_dict["is_cookie_injected"]:
        fansigo_dict["is_cookie_injected"] = await nodriver_fansigo_inject_cookie(tab, config_dict)

    # Handle checkout page - stop automation
    if page_type == "checkout" or page_type == "order_result":
        if not fansigo_dict["played_sound_ticket"]:
            print("[FANSIGO] Checkout page reached, automation stopped")
            play_mp3 = config_dict.get("advanced", {}).get("play_ticket_sound", True)
            if play_mp3:
                util.play_mp3_async(config_dict)
            fansigo_dict["played_sound_ticket"] = True
        return tab

    # Handle event page - select show
    if page_type == "event":
        fansigo_dict["qty_set_url"] = None
        await nodriver_fansigo_date_auto_select(tab, url, config_dict)
        return tab

    # Handle show page - select section, set quantity, checkout
    if page_type == "show":
        # If quantity already set for this URL, skip to checkout only
        if fansigo_dict.get("qty_set_url") == url:
            await asyncio.sleep(0.3)
            await nodriver_fansigo_click_checkout(tab, config_dict)
            return tab

        # Select section (returns index, or -1 if failed)
        section_index = await nodriver_fansigo_area_auto_select(tab, url, config_dict)

        if section_index >= 0:
            # Set ticket quantity for the selected section
            await asyncio.sleep(0.3)
            qty_set = await nodriver_fansigo_assign_ticket_number(tab, config_dict, section_index)

            if qty_set:
                fansigo_dict["qty_set_url"] = url
                # Click checkout
                await asyncio.sleep(0.3)
                await nodriver_fansigo_click_checkout(tab, config_dict)

        return tab

    return tab


async def main(args):
    config_dict = get_config_dict(args)

    driver = None
    tab = None
    if not config_dict is None:
        sandbox = False
        conf = get_extension_config(config_dict, args)
        nodriver_overwrite_prefs(conf)
        # PS: nodrirver run twice always cause error:
        # Failed to connect to browser
        # One of the causes could be when you are running as root.
        # In that case you need to pass no_sandbox=True
        #driver = await uc.start(conf, sandbox=sandbox, headless=config_dict["advanced"]["headless"])
        driver = await uc.start(conf)
        if not driver is None:
            # Output actual CDP port for MCP connection (when mcp_debug is requested)
            mcp_debug_requested = (args and hasattr(args, 'mcp_debug') and args.mcp_debug) or \
                                  config_dict["advanced"].get("mcp_debug_port", 0) > 0
            if mcp_debug_requested:
                actual_port = driver.config.port
                print(f"[MCP DEBUG] Browser started on actual port: {actual_port}")
                print(f"[MCP DEBUG] Update .mcp.json with: --browserUrl http://127.0.0.1:{actual_port}")
                # Write port to file for /mcpstart command auto-update
                try:
                    port_file = os.path.join(os.path.dirname(__file__), '..', '.temp', 'mcp_port.txt')
                    os.makedirs(os.path.dirname(port_file), exist_ok=True)
                    with open(port_file, 'w') as f:
                        f.write(str(actual_port))
                    print(f"[MCP DEBUG] Port saved to .temp/mcp_port.txt")
                except Exception as e:
                    print(f"[MCP DEBUG] Warning: Could not save port to file: {e}")
            tab = await nodriver_goto_homepage(driver, config_dict)
            tab = await nodrver_block_urls(tab, config_dict)
            if not config_dict["advanced"]["headless"]:
                await nodriver_resize_window(tab, config_dict)
        else:
            print("無法使用nodriver，程式無法繼續工作")
            sys.exit()
    else:
        print("Load config error!")

    url = ""
    last_url = ""
    last_paused_state = False  # Track pause state changes

    fami_dict = {}
    fami_dict["fail_list"] = []
    fami_dict["last_activity"]=""

    ticketplus_dict = {}
    ticketplus_dict["fail_list"]=[]
    ticketplus_dict["is_popup_confirm"] = False

    ocr = None
    Captcha_Browser = None
    try:
        if config_dict["ocr_captcha"]["enable"]:
            ocr = ddddocr.DdddOcr(show_ad=False, beta=config_dict["ocr_captcha"]["beta"])
            ocr.set_ranges(1)  # Restrict to lowercase letters only (a-z) for TixCraft captchas
            Captcha_Browser = NonBrowser()
            if len(config_dict["accounts"]["tixcraft_sid"]) > 1:
                #set_non_browser_cookies(driver, config_dict["homepage"], Captcha_Browser)
                pass
    except Exception as exc:
        print(exc)
        pass

    maxbot_last_reset_time = time.time()
    is_quit_bot = False
    is_refresh_datetime_sent = False

    # Initialize config mtime
    app_root = util.get_app_root()
    config_filepath = os.path.join(app_root, CONST_MAXBOT_CONFIG_FILE)
    config_mtime = 0
    if os.path.exists(config_filepath):
        config_mtime = os.path.getmtime(config_filepath)

    while True:
        await asyncio.sleep(0.05)

        config_dict, config_mtime = await reload_config(config_dict, config_mtime)

        # pass if driver not loaded.
        if driver is None:
            print("nodriver not accessible!")
            break

        if not is_quit_bot:
            url, is_quit_bot = await nodriver_current_url(tab)
            #print("url:", url)

        if is_quit_bot:
            try:
                await driver.stop()
                driver = None
            except Exception as e:
                pass
            break

        if url is None:
            continue
        else:
            if len(url) == 0:
                continue

        if not is_refresh_datetime_sent:
            is_refresh_datetime_sent = await check_refresh_datetime_occur(tab, config_dict["refresh_datetime"])

        is_maxbot_paused = await check_and_handle_pause(config_dict)

        # Detect pause state change and show message immediately
        if is_maxbot_paused and not last_paused_state:
            print("BOT Paused.")
        last_paused_state = is_maxbot_paused

        if len(url) > 0 :
            if url != last_url:
                print(url)
                write_last_url_to_file(url)
            last_url = url

        if is_maxbot_paused:
            if 'kktix.c' in url:
                await nodriver_kktix_paused_main(tab, url, config_dict)
            # sleep more when paused.
            await asyncio.sleep(0.1)
            continue

        # for kktix.cc and kktix.com
        if 'kktix.c' in url:
            is_quit_bot = await nodriver_kktix_main(tab, url, config_dict)
            if is_quit_bot:
                print("KKTIX ticket purchase completed")
                # 不自動暫停：讓多開實例可獨立運作
                # 保留 is_quit_bot = False 以防止程式結束，但不建立暫停檔案
                is_quit_bot = False

        tixcraft_family = False
        if 'tixcraft.com' in url:
            tixcraft_family = True

        if 'indievox.com' in url:
            tixcraft_family = True

        if 'ticketmaster.' in url:
            tixcraft_family = True

        if tixcraft_family:
            is_quit_bot = await nodriver_tixcraft_main(tab, url, config_dict, ocr, Captcha_Browser)
            if is_quit_bot:
                print("TixCraft ticket purchase completed")
                # 不自動暫停：讓多開實例可獨立運作
                # 保留 is_quit_bot = False 以防止程式結束，但不建立暫停檔案
                is_quit_bot = False

        if 'famiticket.com' in url:
            await nodriver_famiticket_main(tab, url, config_dict)

        if 'ibon.com' in url:
            await nodriver_ibon_main(tab, url, config_dict, ocr, Captcha_Browser)

        kham_family = False
        if 'kham.com.tw' in url:
            kham_family = True

        if 'ticket.com.tw' in url:
            kham_family = True

        if 'tickets.udnfunlife.com' in url:
            kham_family = True

        if kham_family:
            tab = await nodriver_kham_main(tab, url, config_dict, ocr)

        # https://ticketplus.com.tw/*
        if 'ticketplus.com' in url:
            await nodriver_ticketplus_main(tab, url, config_dict, ocr, Captcha_Browser)

            # 檢查是否購票完成（包含確認頁面處理），如果完成則跳出迴圈
            if 'ticketplus_dict' in globals():
                if ticketplus_dict.get("purchase_completed", False):
                    if config_dict["advanced"].get("verbose", False):
                        print("[SUCCESS] TicketPlus 購票完成")
                    # 不自動暫停：讓多開實例可獨立運作
                    # 保留 is_quit_bot = False 以防止程式結束，但不建立暫停檔案
                    is_quit_bot = False
                elif ticketplus_dict.get("is_ticket_assigned", False) and '/confirm/' in url.lower():
                    # 如果在確認頁面且已指派票券，也可以結束
                    if config_dict["advanced"].get("verbose", False):
                        print("[SUCCESS] TicketPlus 已在確認頁面，購票流程成功")
                    # 不自動暫停：讓多開實例可獨立運作
                    # 保留 is_quit_bot = False 以防止程式結束，但不建立暫停檔案
                    is_quit_bot = False

        if 'urbtix.hk' in url:
            #urbtix_main(driver, url, config_dict)
            pass

        if 'cityline.com' in url:
            tab = await nodriver_cityline_main(tab, url, config_dict)

        softix_family = False
        if 'hkticketing.com' in url:
            softix_family = True
        if 'galaxymacau.com' in url:
            softix_family = True
        if 'ticketek.com' in url:
            softix_family = True
        if softix_family:
            tab = await nodriver_hkticketing_main(tab, url, config_dict)

        # FunOne Tickets
        if 'tickets.funone.io' in url:
            tab = await nodriver_funone_main(tab, url, config_dict)

        # FANSI GO
        if 'go.fansi.me' in url:
            tab = await nodriver_fansigo_main(tab, url, config_dict)

        # for facebook
        facebook_login_url = 'https://www.facebook.com/login.php?'
        if url[:len(facebook_login_url)]==facebook_login_url:
            await nodriver_facebook_main(tab, config_dict)

def cli():
    parser = argparse.ArgumentParser(
            description="MaxBot Aggument Parser")

    parser.add_argument("--input",
        help="config file path",
        type=str)

    parser.add_argument("--homepage",
        help="overwrite homepage setting",
        type=str)

    parser.add_argument("--ticket_number",
        help="overwrite ticket_number setting",
        type=int)

    #default="False",
    parser.add_argument("--headless",
        help="headless mode",
        type=str)

    parser.add_argument("--browser",
        help="overwrite browser setting",
        default='',
        choices=['chrome','firefox','edge','safari','brave'],
        type=str)

    parser.add_argument("--window_size",
        help="Window size",
        type=str)

    parser.add_argument("--proxy_server",
        help="overwrite proxy server, format: ip:port",
        type=str)

    parser.add_argument("--date_auto_select_mode",
        help="overwrite date_auto_select mode",
        choices=['random', 'center', 'from top to bottom', 'from bottom to top'],
        type=str)

    parser.add_argument("--date_keyword",
        help="overwrite date_auto_select date_keyword",
        type=str)

    parser.add_argument("--area_auto_select_mode",
        help="overwrite area_auto_select mode",
        choices=['random', 'center', 'from top to bottom', 'from bottom to top'],
        type=str)

    parser.add_argument("--area_keyword",
        help="overwrite area_auto_select area_keyword",
        type=str)

    parser.add_argument("--mcp_debug",
        help="Enable MCP debug mode with fixed CDP port (default: 9222)",
        nargs='?',
        const=9222,
        type=int)

    parser.add_argument("--mcp_connect",
        help="Connect to existing Chrome on specified port (e.g., --mcp_connect 9222)",
        type=int,
        metavar="PORT")

    args = parser.parse_args()
    uc.loop().run_until_complete(main(args))

if __name__ == "__main__":
    cli()
